{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BAV API Python SDK - <code>bavapi</code>","text":"<p>WPPBAV provides a python consumer for the WPPBAV Fount API.</p> <p>It is published as <code>wpp-bavapi</code> in PyPI and hosted on GitHub.</p> <p>With <code>bavapi</code> you can access the full BAV data catalog, the largest and most comprehensive database of brand data in the world.</p> <p>Queries are validated automatically thanks to <code>pydantic</code> and retrieved asynchronously via the <code>httpx</code> package.</p> <p>For more information about the Fount API, see the API documentation website.</p>"},{"location":"#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p><code>bavapi</code> should work with any Python installation above version 3.8.</p> <p>Install <code>bavapi</code> using pip:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>See Installation for more detailed instructions.</p>"},{"location":"#example-usage","title":"Example usage","text":"<p>Protected access</p> <p> To use <code>bavapi</code>, you will need a Fount API token. Read more in the Authentication section.</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; result = bavapi.brands(\"TOKEN\", name=\"Swatch\") # (1)\n&gt;&gt;&gt; result\n</code></pre> <ol> <li> Replace \"TOKEN\" with your token.</li> </ol> sector_id sector_name id name ... 0 233 Apparel &amp; Accessories 8635 Swatch ... ... ... ... ... ... ..."},{"location":"#features","title":"Features","text":"<ul> <li>Support for all endpoints in the Fount API. Extended support for the <code>audiences</code>, <code>brands</code>, <code>brandscape-data</code> and <code>studies</code> endpoints.<ul> <li>Other endpoints are available via the <code>raw_query</code> functions and methods.</li> </ul> </li> <li>Validates query parameters are of the correct types.<ul> <li>Provides type hints for better IDE support.</li> </ul> </li> <li>Retrieve multiple pages of data simultaneously.<ul> <li>Monitors and prevents exceeding API rate limit.</li> </ul> </li> <li>Both synchronous and asynchronous APIs for accessing BAV data.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>To start using <code>bavapi</code>, go to the Getting Started section.</p> <p>After going through the \"Getting Started\" section, please see Basic Usage.</p> <p>For more advanced topics, see the Advanced Usage section.</p> <p>Each Fount API endpoint may behave slightly differently. You can find detailed explanations in the Endpoints section.</p> <p>You can also find a detailed SDK reference in the Code Reference section.</p>"},{"location":"#issues","title":"Issues","text":"<p>For bug reports and feature requests, please open an issue on GitHub.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute to <code>bavapi</code>, please read the Contributing section of the documentation.</p>"},{"location":"contributing/","title":"Contributing to <code>bavapi</code>","text":"<p><code>bavapi</code> is an open source library provided by WPPBAV, and we're happy to accept contributions from the community.</p> <p>In order to keep a high level of quality and accessibility for our users, there are certain code style and testing requirements that we ask to accept your contributions.</p> <p><code>bavapi</code> uses <code>nox</code> to run development scripts.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>The easiest way to contribute when you see something wrong is to open an issue on GitHub. You can do so here.</p> <p>Please read the instructions in the issue template and fill out as much information as possible.</p> <p>Info</p> <p>This should be your first stop to start contributing to <code>bavapi</code>. We kindly ask that you let us know if you would like to contribute any changes to the code base by opening an issue on GitHub.</p> <p>Please return to this page once you have opened an issue on GitHub and are ready to start contributing.</p>"},{"location":"contributing/#cloning-bavapi-repository","title":"Cloning <code>bavapi</code> repository","text":"<p>In order to make sure you work on the latest version of <code>bavapi</code>, please fork the GitHub repository into your account and clone your fork of <code>bavapi</code> into your machine:</p> <pre><code>git clone https://github.com/{your-username}/bavapi-sdk-python\n</code></pre> <p>Once cloned, enter the newly created directory, create a virtual environment and install all optional dependencies in edit mode:</p> <pre><code>pip install -e .[dev, doc, test, lint]\n</code></pre> <p>This will install all optional dependencies which are necessary for contributing to the code base.</p>"},{"location":"contributing/#fount-api-key","title":"Fount API Key","text":"<p>You will need a Fount API key to perform requests to the API through <code>bavapi</code>.</p> <p>To get and use an API key, see the Authentication section of the Getting Started guide.</p> <p>In order to run integration tests, you will need to use an <code>.env</code> file to store your Fount API key. See the instructions for more details.</p>"},{"location":"contributing/#tools-and-frameworks","title":"Tools and frameworks","text":"<p><code>bavapi</code> uses the following frameworks for development:</p> <ul> <li>Fully type-hinted and tested with <code>mypy</code>.</li> <li>Unit and integration tests using <code>pytest</code>.</li> <li>Full test coverage using <code>coverage</code>.</li> <li>Run development scripts in multiple Python versions with <code>nox</code>.</li> <li>Documentation using <code>mkdocs-material</code>.</li> <li>Code auto-formatting with <code>black</code>.</li> <li>Linting with <code>pylint</code>.</li> <li>Requirements management with <code>pip-tools</code>.</li> </ul> <p>Please familiarize yourself with using these libraries in order to get started with contributing to <code>bavapi</code>.</p>"},{"location":"contributing/#developing-in-windows","title":"Developing in Windows","text":"<p>It is highly recommended that you use <code>mamba</code> to manage Python environments in Windows. It is a faster implementation of <code>conda</code> and testing of <code>bavapi</code> on multiple versions of Python is set up to use <code>mamba</code> on Windows.</p> <p>Once you have <code>mamba</code> installed in your system, you should be able to run <code>nox</code> commands.</p>"},{"location":"contributing/#nox-commands","title":"Nox commands","text":"<p>To run <code>nox</code> commands, run the following command in your terminal:</p> <pre><code>nox -s {command_name}\n</code></pre>"},{"location":"contributing/#available-nox-commands","title":"Available <code>nox</code> commands","text":"<p>To see a list of all available <code>nox</code> commands, run <code>nox -l</code> in your terminal. Here is a quick summary:</p> <ul> <li><code>tests</code> and <code>tests_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information. Suitable for CI/CD pipeline and for Linux (would require <code>pyenv</code> to manage Python versions).</li> <li><code>tests_mamba</code> and <code>tests_mamba_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information, using <code>mamba</code> to run multiple versions of Python. Suitable for testing on Windows.</li> <li>The commands above, ending with <code>_nocov</code>: run <code>pytest</code> unit (or end-to-end) tests without collecting <code>coverage</code> information.</li> <li><code>coverage</code>: combine and report coverage results.</li> <li><code>requirements</code>: update <code>requirements.txt</code> with latest dependencies from <code>pyproject.toml</code>.</li> <li><code>build</code>: build distributable files for <code>bavapi</code>. Suitable for CI/CD pipeline.</li> <li><code>publish</code>: publish <code>bavapi</code> to PyPI. Suitable for CI/CD pipeline.</li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":"<p><code>bavapi</code> supports Python 3.8 and above, so your code should be able to run in all the latest versions of python.</p> <ol> <li>Run <code>black bavapi</code> after writing or modifying code. This way the code style of the whole project will remain consistent.</li> <li>Run <code>mypy bavapi</code> after writing or modifying code to make sure type hints are correctly defined.</li> <li>Fully test your code using <code>pytest</code> and make sure you covered all your changes in the repository by running <code>nox -s tests_mamba</code>, <code>nox -s tests_mamba_e2e</code> and <code>nox -s coverage</code>.</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>If your contribution changes the functionality of the library, you will need to update the documentation.</p> <p><code>mkdocs-material</code> will automatically generate documentation for your code by parsing docstrings with <code>mkdocstrings</code>. Please make sure that the docstrings in your code follow the <code>numpydoc</code> standard.</p> <p>If your contribution changes the basic or advanced functionality of the library, or changes how the library is installed, please update those sections of the documentation.</p> <p>Each fully implemented endpoint should have a corresponding documentation page in the <code>endpoints</code> folder. Please follow the same structure as other endpoint pages for consistency.</p>"},{"location":"contributing/#cicd","title":"CI/CD","text":"<p><code>bavapi</code> has a CI/CD pipeline set up that checks for testing and coverage. All code must be tested and will fail integration if test coverage is not 100%.</p> <p>One way to ensure success is to run the three testing commands mentioned above. You can copy/paste the following command for convenience:</p> <pre><code>nox -s tests_mamba &amp;&amp; nox -s tests_mamba_e2e &amp;&amp; nox -s coverage\n</code></pre>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>In order to integrate changes into <code>bavapi</code>, you must create a pull request on GitHub.</p> <p>Please follow the instructions in the pull request template and fill out as much information as possible.</p> <p>GitHub actions will automatically run tests on the pull request content.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#version-06","title":"Version 0.6","text":""},{"location":"release-notes/#version-060-july-13th-2023","title":"Version 0.6.0 (July 13th, 2023)","text":""},{"location":"release-notes/#internal","title":"Internal","text":"<ul> <li> Upgraded <code>pydantic</code> to v2. Use <code>bavapi</code> v0.5 for compatibility with <code>pydantic</code> v1.</li> </ul>"},{"location":"release-notes/#typing","title":"Typing","text":"<ul> <li> Fixed use of <code>type</code> in type hints not compatible with Python. 3.8</li> <li> Cleaned up type hints in tests.</li> </ul>"},{"location":"roadmap/","title":"<code>bavapi</code> Roadmap","text":"<p>This is a non-exhaustive list of potential features &amp; changes to <code>bavapi</code> before it is ready for full release:</p>"},{"location":"roadmap/#core-tooling","title":"Core tooling","text":"<ul> <li><code>pydantic</code> V2 support </li> <li>Strict <code>mypy</code> support with PEP 692 <code>Unpack</code> and <code>TypedDict</code></li> </ul>"},{"location":"roadmap/#known-issues","title":"Known issues","text":"<ul> <li>Fix sporadic <code>SSL: CERTIFICATE_VERIFY_FAILED</code> errors when making requests to the Fount API.</li> </ul>"},{"location":"roadmap/#new-fully-supported-endpoints","title":"New fully-supported endpoints","text":"<p>Eventually, the plan is to support all endpoints. This is the current priority list:</p> <ol> <li>Categories</li> <li>Collections</li> <li>Brand Metrics</li> <li>Sectors</li> <li>Brand Metric Groups</li> </ol>"},{"location":"roadmap/#stretch-goals","title":"Stretch goals","text":"<ul> <li>Smarter flattening of JSON responses, possibly through <code>pandas.json_normalize</code>.</li> </ul>"},{"location":"endpoints/","title":"Endpoints","text":"<p>As of <code>v0.6</code>, there are four endpoints that have been fully implemented in <code>bavapi</code>:</p> <ul> <li><code>audiences</code></li> <li><code>brands</code></li> <li><code>brandscape-data</code></li> <li><code>studies</code></li> </ul> <p>\"Implemented\" meaning that the endpoint has a corresponding function, <code>Client</code> method, and filters class associated with them. More info in each endpoint's respective section linked above.</p> <p>If an existing endpoint does not appear in the list above, you can still perform queries to them using the <code>raw_query</code> methods (see below), but <code>bavapi</code> won't validate filter parameters.</p> <p>Examples for each endpoint are available in each of their individual sections, both for the top-level, synchronous functions, and the asynchronous methods in <code>bavapi.Client</code>.</p> <p>For a summary of all existing Fount endpoints, as well as their parameters and supported filters, please see the Resources section of the Fount API documentation.</p>"},{"location":"endpoints/#other-endpoints","title":"Other endpoints","text":"<p>While there are some commonly used endpoints with more extensive validation support, there are a lot of additional endpoints available for querying.</p> <p>With the <code>raw_query</code> functions and methods, you can perform requests to any endpoint in the Fount, even if it's not supported with dedicated code.</p> Endpoint Function <code>Client</code> method Filters class <code>{any}</code> <code>raw_query</code> <code>Client.raw_query</code> <code>FountFilters</code> <p>Queries from <code>raw_query</code> functions and methods return a list of JSON dictionaries, instead of a <code>pandas</code> DataFrame.</p> <p>Note</p> <p>You need to use a <code>Query</code> instance to perform queries with <code>raw_query</code> methods. More info</p>"},{"location":"endpoints/#usage","title":"Usage","text":"AsyncSync <pre><code>import bavapi\nasync with bavapi.Client(\"TOKEN\") as fount:\nresult = await fount.raw_query(\"companies\", bavapi.Query())\n</code></pre> <pre><code>import bavapi\nresult = bavapi.raw_query(\"TOKEN\", \"companies\", bavapi.Query())\n</code></pre> <p>Since the result of these queries will be a list of JSON dictionaries, you can use the <code>parse_response</code> function in the <code>bavapi.parsing.responses</code> module to parse the JSON response into a DataFrame:</p> <pre><code>import bavapi\nfrom bavapi.parsing.responses import parse_response\nasync with bavapi.Client(\"TOKEN\") as fount:\nresult = await fount.raw_query(\"companies\", bavapi.Query())\nparsed = parse_response(result)  # will return a DataFrame\n</code></pre>"},{"location":"endpoints/audiences/","title":"Audiences","text":"<p>The <code>audiences</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"audiences\"</code> <code>audiences</code> <code>Client.audiences</code> <code>AudiencesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>audiences</code> endpoint.</p>"},{"location":"endpoints/audiences/#usage","title":"Usage","text":"AsyncSync Using Client asynchronously<pre><code>import bavapi\nasync with bavapi.Client(\"TOKEN\") as bav:\nresult = await bav.audiences(name=\"All Adults\")\n</code></pre> Using top-level functions<pre><code>import bavapi\nresult = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre>"},{"location":"endpoints/brands/","title":"Brands","text":"<p>The <code>brands</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brands\"</code> <code>brands</code> <code>Client.brands</code> <code>BrandsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brands</code> endpoint.</p>"},{"location":"endpoints/brands/#usage","title":"Usage","text":"AsyncSync Using Client asynchronously<pre><code>import bavapi\nasync with bavapi.Client(\"TOKEN\") as bav:\nresult = await bav.brands(name=\"Facebook\")\n</code></pre> Using top-level functions<pre><code>import bavapi\nresult = bavapi.brands(\"TOKEN\", name=\"Facebook\")\n</code></pre>"},{"location":"endpoints/brandscape-data/","title":"Brandscape Data","text":"<p>The <code>brandscape-data</code> endpoint has full support, including query validation.</p> <p>This is the main entry point to WPPBAV's extensive brand data catalog.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brandscape-data\"</code> <code>brandscape_data</code> <code>Client.brandscape_data</code> <code>BrandscapeFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brandscape-data</code> endpoint.</p>"},{"location":"endpoints/brandscape-data/#usage","title":"Usage","text":"AsyncSync Using Client asynchronously<pre><code>import bavapi\nasync with bavapi.Client(\"TOKEN\") as bav:\nresult = await bav.brandscape_data(name=\"Facebook\")\n</code></pre> Using top-level functions<pre><code>import bavapi\nresult = bavapi.brandscape_data(\"TOKEN\", name=\"Facebook\")\n</code></pre> <p>Warning</p> <p><code>brandscape-data</code> has filters which have a slightly different name than for other endpoints:</p> <ul> <li><code>year_number</code> instead of <code>year_numbers</code>.</li> <li><code>country_code</code> instead of <code>country_codes</code>.</li> </ul> <p>This is to maintain parity with the way the API is structured. Using the wrong spelling of these parameters will likely result in an error.</p>"},{"location":"endpoints/brandscape-data/#required-filters","title":"Required filters","text":"<p><code>brandscape-data</code> can retrieve brand datasets from an arbitrary combination of studies, audiences and years, so it is possible that the request becomes too large for the server to deliver effectively for all users.</p> <p>Thus, the <code>brandscape-data</code> endpoint has been restricted to require at least one of these specific set of filters:</p> <ul> <li><code>studies</code></li> <li><code>brand_name</code>/<code>brands</code></li> <li><code>year_number</code>/<code>years</code> and <code>brands</code>/<code>brand_name</code></li> <li><code>country_code</code>/<code>countries</code> and <code>brands</code>/<code>brand_name</code></li> <li><code>year_number</code>/<code>years</code> and <code>country_code</code>/<code>countries</code></li> </ul> <p>If a query does not have any of these combinations of filters, it will raise a <code>ValidationError</code>:</p> <pre><code>bavapi.brandscape_data(\"TOKEN\")  # Error, no filters specified\nbavapi.brandscape_data(\"TOKEN\", year_number=2022) # Error, not enough filters\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\") # OK\nbavapi.brandscape_data(\"TOKEN\", country_code=\"UK\", brands=123)  # OK\n</code></pre>"},{"location":"endpoints/brandscape-data/#default-includes","title":"Default includes","text":"<p>In order to provide critical information about the data retrieved from <code>brandscape-data</code>, and to move its structure in line with data downloads from the Fount or BAV's Cultural Rank Tool (CRT), some <code>include</code> values are requested by default: <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code>.</p> <p>If you add any of these values in the <code>include</code> field by themselves, the default won't be used, and <code>bavapi</code> will make a request with the specified <code>include</code> instead.</p> <p>If, on the other hand, you request an <code>include</code> that is not part of the default values, <code>bavapi</code> will append that new value to the default <code>include</code> values.</p> <pre><code># All default includes will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\")\n# Only the \"brand\" include will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"brand\")\n# The \"company\" include will be appended to the default \"include\" values\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"company\")\n</code></pre>"},{"location":"endpoints/brandscape-data/#clashing-column-names","title":"Clashing column names","text":"<p>Some includes can have clashing column names with the original data. This happens, for example, with the <code>\"brand\"</code> include, which when expanded will have column names such as <code>\"brand_name\"</code>, which is already present in the <code>brandscape-data</code> table.</p> <p>To circumvent this issue, the response parsing function will append the <code>\"global_\"</code> prefix to includes with potentially clashing names.</p> <p>As a result, you will see a set of columns, extracted from the <code>\"brand\"</code> include, which will have a <code>\"global_\"</code> prefix in their names.</p> <p>Warning</p> <p>This may change in future versions of <code>bavapi</code> as the parsing logic is upgraded.</p>"},{"location":"endpoints/brandscape-data/#metric-keys","title":"Metric keys","text":"<p><code>brandscape-data</code> functions and methods provide a parameter to specify the data columns that the response should contain: <code>metric_keys</code>.</p> <p>You can specify the metrics that your response should contain, and the API will include all score types for that metric.</p> <p>Example</p> <p>Setting <code>metric_keys</code> to <code>[\"differentiation\", \"relevance\"]</code> will instruct the request to only return the following columns:</p> <ul> <li><code>differentiation_c</code></li> <li><code>differentiation_rank</code></li> <li><code>relevance_c</code></li> <li><code>relevance_rank</code></li> <li>Brand information such as <code>id</code>, <code>brand_name</code>, and <code>category_name</code></li> <li>Any additional columns from the <code>include</code> parameter</li> </ul> <pre><code>bavapi.brandscape_data(studies=111, metric_keys=\"differentiation\") # (1)\n</code></pre> <ol> <li>Will only return <code>differentiation_c</code> and <code>differentiation_rank</code> data.</li> </ol>"},{"location":"endpoints/studies/","title":"Studies","text":"<p>The <code>studies</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"studies\"</code> <code>studies</code> <code>Client.studies</code> <code>StudiesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>studies</code> endpoint.</p>"},{"location":"endpoints/studies/#usage","title":"Usage","text":"AsyncSync Using Client asynchronously<pre><code>import bavapi\nasync with bavapi.Client(\"TOKEN\") as bav:\nresult = await bav.studies(country_codes=\"US\")\n</code></pre> Using top-level functions<pre><code>import bavapi\nresult = bavapi.studies(\"TOKEN\", country_codes=\"US\")\n</code></pre>"},{"location":"getting-started/authentication/","title":"Authentication","text":"<p>The first thing you will need to use <code>bavapi</code> is a Fount API authentication token (a.k.a. key).</p> <p>This token is a specific code that is assigned to you and is needed to confirm that you have access to the Fount data.</p>"},{"location":"getting-started/authentication/#getting-a-fount-api-token","title":"Getting a Fount API token","text":"<p>Please follow the instructions in the Authentication section of the Fount API documentation.</p> <p>Warning</p> <p>Do NOT share your API token publicly or with anyone else. That token is tied to your account exclusively. If somebody else needs a token, they should create their own from their account settings.</p>"},{"location":"getting-started/authentication/#recommended-way-to-manage-api-keys","title":"Recommended way to manage API keys","text":"<p>In order to keep your API token secure, you should avoid using your token directly in your code and applications. Instead, place the code in a <code>.env</code> file at the top of your project directory, and use <code>python-dotenv</code> to load the token into your environment:</p> <pre><code>my-project-folder\n\u251c\u2500\u2500\u2500 .env\n\u2514\u2500\u2500\u2500 ... (other stuff)\n</code></pre> <p>Create this <code>.env</code> file (note the leading dot) in the top level of your working directory, and write down your token like so:</p> <pre><code>FOUNT_API_TOKEN = \"your_token_here\"\n</code></pre> <p>To now use this file, you will need to install the <code>python-dotenv</code> package:</p> <pre><code>pip install python-dotenv\n</code></pre> <p>Now, paste this code at the top of your Python files or Jupyter Notebooks:</p> <pre><code>import os\nfrom dotenv import load_dotenv\nload_dotenv()  # (1)\nTOKEN = os.environ[\"FOUNT_API_TOKEN\"]  # (2)\n</code></pre> <ol> <li>Load variables from <code>.env</code> into the system's environment</li> <li>Assign the <code>\"FOUNT_API_TOKEN\"</code> environment variable to our <code>TOKEN</code> local variable</li> </ol> <p>Now you can use <code>TOKEN</code> in your API requests:</p> <pre><code>bavapi.brands(TOKEN, name=\"Swatch\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<p><code>bavapi</code> requires python 3.8 or higher to run.</p> <p>If you don't have python installed, you can download it from the official Python website or Anaconda.</p> <p>You will also need a Fount API bearer token to peform requests to the Fount. For instructions on how to get your own API token, see the Authentication section.</p> <p>Once you have installed Python and have acquired your Fount API token, return to this page to continue.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p><code>bavapi</code> depends on the following excellent libraries:</p> <ul> <li><code>httpx</code> for communication with the Fount API.</li> <li><code>pandas</code> for processing retrieved data into tables.</li> <li><code>pydantic</code> to validate query and filter parameters.</li> <li><code>nest-asyncio</code> to support Jupyter notebooks.</li> <li><code>tqdm</code> to show helpful progress bars.</li> <li><code>typing-extensions</code> for type checking compatibility in Python &lt; 3.10.</li> </ul> <p>These libraries will be installed automatically when you install <code>bavapi</code>.</p>"},{"location":"getting-started/installation/#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p>Once you have your virtual environment activated, you can install <code>bavapi</code> with the following command:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>Installing with <code>conda</code></p> <p><code>bavapi</code> is not currently available from <code>conda</code> directly, though it should be possible to install and use it within a <code>conda</code> environment.</p> <p>Use the following commands to maximize compatibility between <code>conda</code> and <code>pip</code>:</p> <pre><code>conda install httpx, pandas, pydantic, nest-asyncio, tqdm, typing_extensions\n\npip install wpp-bavapi --no-deps\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from source","text":"<p>To install from source, clone the GitHub repository into your local machine:</p> <pre><code>git clone https://github.com/wppbav/bavapi-sdk-python.git\n</code></pre> <p>Go into the cloned directory and install <code>bavapi</code>:</p> <pre><code>cd bavapi-sdk-python\npip install .\n</code></pre>"},{"location":"getting-started/reference-classes/","title":"Installing <code>bavapi</code> Reference classes","text":"<p><code>bavapi</code> can generate some convenience reference classes which map Fount resource IDs with a more readable name, both for ease of use and for autocompletion in IDEs.</p> <p>These classes are automatically generated by a console command that becomes available once <code>bavapi</code> is installed.</p> <p>Protected Access</p> <p>A Fount API token is required to generate reference files. See the Authentication section for more information and instructions for using <code>.env</code> files.</p> <p>As of <code>v0.6</code> the following reference classes will be generated in a folder named <code>bavapi_refs</code>:</p> <ul> <li><code>Audiences</code>: encodes audience IDs</li> <li><code>Countries</code>: encodes country IDs</li> </ul> <p>A sample reference class would look like this:</p> <pre><code>class Audiences(Enum):\nALL_ADULTS = 27  # Random ID\n...\n</code></pre> <p>And could be used to have better visibility when filtering API responses:</p> Using Reference classNot using Reference class Explicit audience filter<pre><code>fountapi.brandscape_data(country_code=\"US\", year=2022, audiences=Audiences.ALL_ADULTS)\n</code></pre> Audience filter not human-readable<pre><code>fountapi.brandscape_data(country_code=\"US\", year=2022, audiences=27)\n</code></pre> <p>Warning</p> <p>Don't commit reference classes to public repositories. Add <code>bavapi_refs/</code> to your <code>.gitignore</code> file.</p> <p>To generate these reference classes, run the following command:</p> <pre><code>bavapi-gen-refs --all\n</code></pre> <p>Alternatively, you can specify the name of the reference class to generate:</p> <pre><code>bavapi-gen-refs --name audiences\n</code></pre> <p>To update existing reference classes with the latest data, re-run <code>bavapi-gen-refs --all</code> on your terminal.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>client</li> <li>exceptions</li> <li>filters</li> <li>http</li> <li>jupyter</li> <li>parsing<ul> <li>params</li> <li>responses</li> </ul> </li> <li>query</li> <li>reference<ul> <li>generate_reference</li> </ul> </li> <li>sync</li> </ul>"},{"location":"reference/client/","title":"client","text":"<p>Fount API interface.</p>"},{"location":"reference/client/#client.Client","title":"<code>Client</code>","text":"<p>Asynchronous API to interact with the WPPBAV Fount.</p> <p>This class uses <code>asyncio</code> to perform asynchronous requests to the Fount API.</p> <p>Asynchronous requests allow you to make multiple requests at the same time, extremely helpful for working with a paginated API like the Fount. (returns data in multiple pages or requests instead of one single download)</p> <p>To use the Client class, you will need to precede calls with <code>await</code>:</p> <pre><code>fount = Client(\"TOKEN\")  # creating instance does not use `await`\ndata = await fount.brands(\"Swatch\")  # must use `await`\n</code></pre> <p>For more information, see the <code>asyncio</code> documentation for Python.</p> <p>Either <code>auth_token</code> or <code>client</code> are required to instantiate a Client.</p> <p>Parameters:</p> Name Type Description Default <code>auth_token</code> <code>str</code> <p>Fount API authorization token, by default <code>''</code></p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, by default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, by default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>client</code> <code>HTTPClient</code> <p>Authenticated async client from <code>bavapi.http</code>, by default None</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>auth_token</code> nor <code>client</code> are provided</p> <p>Examples:</p> <p>Use <code>async with</code> to get data and close the connection.</p> <p>This way you get the benefits from <code>httpx</code> speed improvements and closes the connection when exiting the async with block.</p> <pre><code>&gt;&gt;&gt; async with Client(\"TOKEN\") as fount:\n...     data = await fount.brands(\"Swatch\")\n</code></pre> <p>When not using <code>async with</code>, close the connection manually by awaiting <code>aclose</code>.</p> <pre><code>&gt;&gt;&gt; client = Client(\"TOKEN\")\n&gt;&gt;&gt; data = await fount.brands(\"Swatch\")\n&gt;&gt;&gt; await client.aclose()\n</code></pre> Source code in <code>bavapi\\client.py</code> <pre><code>class Client:\n\"\"\"Asynchronous API to interact with the WPPBAV Fount.\n    This class uses `asyncio` to perform asynchronous requests to the Fount API.\n    Asynchronous requests allow you to make multiple requests at the same time,\n    extremely helpful for working with a paginated API like the Fount. (returns\n    data in multiple pages or requests instead of one single download)\n    To use the Client class, you will need to precede calls with `await`:\n    ```python\n    fount = Client(\"TOKEN\")  # creating instance does not use `await`\n    data = await fount.brands(\"Swatch\")  # must use `await`\n    ```\n    For more information, see the `asyncio` documentation for Python.\n    Either `auth_token` or `client` are required to instantiate a Client.\n    Parameters\n    ----------\n    auth_token : str, optional\n        Fount API authorization token, by default `''`\n    per_page : int, optional\n        Default number of entries per page, by default 100\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verify : bool or str, optional\n        Verify SSL credentials, by default True\n        Also accepts a path string to an SSL certificate file.\n    client : HTTPClient, optional\n        Authenticated async client from `bavapi.http`, by default None\n    Raises\n    ------\n    ValueError\n        If neither `auth_token` nor `client` are provided\n    Examples\n    --------\n    Use `async with` to get data and close the connection.\n    This way you get the benefits from `httpx` speed improvements\n    and closes the connection when exiting the async with block.\n    &gt;&gt;&gt; async with Client(\"TOKEN\") as fount:\n    ...     data = await fount.brands(\"Swatch\")\n    When not using `async with`, close the connection manually by awaiting `aclose`.\n    &gt;&gt;&gt; client = Client(\"TOKEN\")\n    &gt;&gt;&gt; data = await fount.brands(\"Swatch\")\n    &gt;&gt;&gt; await client.aclose()\n    \"\"\"\n@overload\ndef __init__(self, auth_token: str) -&gt; None:\n...\n@overload\ndef __init__(\nself,\nauth_token: str,\nper_page: int = 100,\ntimeout: float = 30.0,\nverify: Union[bool, str] = True,\n) -&gt; None:\n...\n@overload\ndef __init__(\nself,\n*,\nclient: HTTPClient = ...,\nper_page: int = 100,\n) -&gt; None:\n...\ndef __init__(\nself,\nauth_token: str = \"\",\nper_page: int = 100,\ntimeout: float = 30.0,\nverify: Union[bool, str] = True,\n*,\nclient: Optional[HTTPClient] = None,\n) -&gt; None:\nif client is not None:\nself._client = client\nelse:\nif not auth_token:\nraise ValueError(\"You must provide `auth_token` or `client`.\")\nself._client = HTTPClient(\nbase_url=BASE_URL,\nper_page=per_page,\ntimeout=timeout,\nverify=verify,\nheaders={\n\"Authorization\": f\"Bearer {auth_token}\",\n\"Accept\": \"application/json\",\n},\n)\n@property\ndef per_page(self) -&gt; int:\n\"\"\"Default number of items to retrieve per page.\"\"\"\nreturn self._client.per_page\n@per_page.setter\ndef per_page(self, value: int) -&gt; None:\nself._client.per_page = value\nasync def __aenter__(self) -&gt; \"Client\":\nawait self._client.__aenter__()\nreturn self\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_value: Optional[BaseException] = None,\ntraceback: \"Optional[TracebackType]\" = None,\n) -&gt; None:\nawait self._client.__aexit__(exc_type, exc_value, traceback)\nasync def aclose(self) -&gt; None:\n\"\"\"Close existing HTTP connections.\"\"\"\nreturn await self._client.aclose()\nasync def raw_query(self, endpoint: str, params: Query[F]) -&gt; List[JSONDict]:\n\"\"\"Perform a raw GET query to the Fount API, returning the response JSON data\n        instead of a `pandas` DataFrame.\n        Parameters\n        ----------\n        endpoint : str\n            Endpoint name\n        params : Query\n            Query `pydantic` model with query parameters.\n        Returns\n        -------\n        list[dict[str, Any]]\n            List of JSON response data\n        \"\"\"\nreturn list(await self._client.query(endpoint, params))\nasync def audiences(\nself,\nname: Optional[str] = None,\naudience_id: Optional[int] = None,\nactive: Literal[0, 1] = 0,\ninactive: Literal[0, 1] = 0,\npublic: Literal[0, 1] = 0,\nprivate: Literal[0, 1] = 0,\ngroups: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `audiences` endpoint.\n        Parameters\n        ----------\n        name : str, optional\n            Search audiences by name, by default None\n        audience_id : int, optional\n            Fount audience ID, by default None\n            If an audience ID is provided, only that audience will be returned\n        active : Literal[0, 1]\n            Return active audiences only if set to `1`, by default 0\n        inactive : Literal[0, 1]\n            Return inactive audiences only if set to `1`, by default 0\n        public : Literal[0, 1]\n            Return active audiences only if set to `1`, by default 0\n        private : Literal[0, 1]\n            Return inactive audiences only if set to `1`, by default 0\n        groups : int or list[int], optional\n            Audience group ID or list of audience group IDs, by default None\n        filters : AudiencesFilters or dict of filters, optional\n            AudiencesFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n            To sort in descending (highest first) order, use a `-` before the field name:\n            `sort=\"-differentiation_rank\"`\n            Sorts by item ID by default.\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brands` endpoint results.\n        \"\"\"\nfilters = _filters.AudiencesFilters.ensure(\nfilters,\nname=name,\nactive=active,\ninactive=inactive,\npublic=public,\nprivate=private,\ngroups=groups,\n)\nquery: Query[_filters.AudiencesFilters] = Query(\nid=audience_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"audiences\", query)\nreturn parse_response(items, expand=stack_data)\nasync def brands(\nself,\nname: Optional[str] = None,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nbrand_id: Optional[int] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brands` endpoint.\n        Parameters\n        ----------\n        name : str, optional\n            Search brands by name, by default None\n        country_codes: str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_numbers : int or list[int], optional\n            Study years, by default None\n        brand_id : int, optional\n            Fount brand ID, by default None\n            If a brand ID is provided, only that brand will be returned\n        studies : int or list[int], optional\n            Fount study IDs, by default None\n        filters : BrandsFilters or dict of filters, optional\n            BrandsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n            To sort in descending (highest first) order, use a `-` before the field name:\n            `sort=\"-differentiation_rank\"`\n            Sorts by item ID by default.\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brands` endpoint results.\n        \"\"\"\nfilters = _filters.BrandsFilters.ensure(\nfilters,\nname=name,\ncountry_codes=country_codes,\nyear_numbers=year_numbers,\nstudies=studies,\n)\nquery: Query[_filters.BrandsFilters] = Query(\nid=brand_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"brands\", query)\nreturn parse_response(items, expand=stack_data)\nasync def brandscape_data(\nself,\ncountry_code: OptionalListOr[str] = None,\nyear_number: OptionalListOr[int] = None,\naudiences: OptionalListOr[int] = None,\nbrand_name: Optional[str] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nmetric_keys: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brandscape-data` endpoint.\n        This endpoint requires at least one of the following combinations of filters:\n        - `studies`\n        - `brand_name`\n        - `brands`\n        - `year_number`/`years` and `brands`/`brand_name`\n        - `country_code`/`countries` and `brands`/`brand_name`\n        - `year_number`/`years` and `country_code`/`countries`\n        An audience filter is also highly recommended, as otherwise the API will return\n        data for all audiences (there are more than 30 standard audiences).\n        The `Audiences` class is provided to make it easier to filter audiences.\n        Note that this endpoint has a default set of `include` resources:\n        - `brand`\n        - `study`\n        - `category`\n        - `audience`\n        Any additional valid includes will be added to the default set.\n        If any of the default includes are used in `include`, then only that resource\n        will be retrieved. This is to allow requesting individual includes if they are\n        part of the default.\n        Parameters\n        ----------\n        country_code : str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_number : int or list[int], optional\n            Study years, by default None\n        audiences : int or list[int], optional\n            Audiences to retrieve by audience ID, by default None\n            The `Audiences` class can help with this filter.\n        brand_name : str, optional\n            Search by brand name, by default None\n        studies : int or list[int], optional\n            Fount studies IDs, by default None\n        filters : BrandscapeFilters or dict of filters, optional\n            BrandscapeFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        metric_keys: str or list[str], optional\n            Key or list of keys for the metrics included in the response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n            To sort in descending (highest first) order, use a `-` before the field name:\n            `sort=\"-differentiation_rank\"`\n            Sorts by item ID by default.\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brandscape-data` endpoint results.\n        Raises\n        ------\n        ValidationError\n            If used with an invalid combination of parameters (see above)\n        \"\"\"\nfilters = _filters.BrandscapeFilters.ensure(\nfilters,\ncountry_code=country_code,\nyear_number=year_number,\naudiences=audiences,\nbrand_name=brand_name,\nstudies=studies,\n)\nquery: Query[_filters.BrandscapeFilters] = Query(\nfilters=filters,\nfields=fields,\ninclude=_default_brandscape_include(include),\nmetric_keys=metric_keys,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"brandscape-data\", query)\n# Prefix 'global' to avoid clashing with 'brand_name' on 'brand' includes\nreturn parse_response(items, \"global\", expand=stack_data)\nasync def studies(\nself,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nfull_year: Literal[0, 1] = 0,\nstudy_id: Optional[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `studies` endpoint.\n        Parameters\n        ----------\n        country_codes: str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_numbers : int or list[int], optional\n            Study years, by default None\n        full_year : Literal[0, 1], optional\n            Include or exclude studies which are not \"full year\" studies,\n            such as US quarterly studies or special studies, by default 0\n            A value of 1 will filter non-full-year studies.\n        study_id : int, optional\n            Fount study ID, by default None\n            If a study ID is provided, only that study will be returned\n        filters : StudiesFilters or dict of filters, optional\n            StudiesFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n            To sort in descending (highest first) order, use a `-` before the field name:\n            `sort=\"-differentiation_rank\"`\n            Sorts by item ID by default.\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `studies` endpoint results.\n        \"\"\"\nfilters = _filters.StudiesFilters.ensure(\nfilters,\ncountry_codes=country_codes,\nyear_numbers=year_numbers,\nfull_year=full_year,\n)\nquery: Query[_filters.StudiesFilters] = Query(\nid=study_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"studies\", query)\nreturn parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.per_page","title":"<code>per_page: int</code>  <code>writable</code> <code>property</code>","text":"<p>Default number of items to retrieve per page.</p>"},{"location":"reference/client/#client.Client.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Close existing HTTP connections.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def aclose(self) -&gt; None:\n\"\"\"Close existing HTTP connections.\"\"\"\nreturn await self._client.aclose()\n</code></pre>"},{"location":"reference/client/#client.Client.audiences","title":"<code>audiences(name=None, audience_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search audiences by name, by default None</p> <code>None</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, by default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, by default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict of filters</code> <p>AudiencesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def audiences(\nself,\nname: Optional[str] = None,\naudience_id: Optional[int] = None,\nactive: Literal[0, 1] = 0,\ninactive: Literal[0, 1] = 0,\npublic: Literal[0, 1] = 0,\nprivate: Literal[0, 1] = 0,\ngroups: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `audiences` endpoint.\n    Parameters\n    ----------\n    name : str, optional\n        Search audiences by name, by default None\n    audience_id : int, optional\n        Fount audience ID, by default None\n        If an audience ID is provided, only that audience will be returned\n    active : Literal[0, 1]\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1]\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1]\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1]\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n    filters : AudiencesFilters or dict of filters, optional\n        AudiencesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results.\n    \"\"\"\nfilters = _filters.AudiencesFilters.ensure(\nfilters,\nname=name,\nactive=active,\ninactive=inactive,\npublic=public,\nprivate=private,\ngroups=groups,\n)\nquery: Query[_filters.AudiencesFilters] = Query(\nid=audience_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"audiences\", query)\nreturn parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brands","title":"<code>brands(name=None, country_codes=None, year_numbers=None, brand_id=None, studies=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brands by name, by default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, by default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict of filters</code> <p>BrandsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brands(\nself,\nname: Optional[str] = None,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nbrand_id: Optional[int] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brands` endpoint.\n    Parameters\n    ----------\n    name : str, optional\n        Search brands by name, by default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    brand_id : int, optional\n        Fount brand ID, by default None\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, by default None\n    filters : BrandsFilters or dict of filters, optional\n        BrandsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results.\n    \"\"\"\nfilters = _filters.BrandsFilters.ensure(\nfilters,\nname=name,\ncountry_codes=country_codes,\nyear_numbers=year_numbers,\nstudies=studies,\n)\nquery: Query[_filters.BrandsFilters] = Query(\nid=brand_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"brands\", query)\nreturn parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brandscape_data","title":"<code>brandscape_data(country_code=None, year_number=None, audiences=None, brand_name=None, studies=None, *, filters=None, fields=None, include=None, metric_keys=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of filters:</p> <ul> <li><code>studies</code></li> <li><code>brand_name</code></li> <li><code>brands</code></li> <li><code>year_number</code>/<code>years</code> and <code>brands</code>/<code>brand_name</code></li> <li><code>country_code</code>/<code>countries</code> and <code>brands</code>/<code>brand_name</code></li> <li><code>year_number</code>/<code>years</code> and <code>country_code</code>/<code>countries</code></li> </ul> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 30 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code> - <code>audience</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>Parameters:</p> Name Type Description Default <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, by default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, by default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict of filters</code> <p>BrandscapeFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brandscape_data(\nself,\ncountry_code: OptionalListOr[str] = None,\nyear_number: OptionalListOr[int] = None,\naudiences: OptionalListOr[int] = None,\nbrand_name: Optional[str] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nmetric_keys: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brandscape-data` endpoint.\n    This endpoint requires at least one of the following combinations of filters:\n    - `studies`\n    - `brand_name`\n    - `brands`\n    - `year_number`/`years` and `brands`/`brand_name`\n    - `country_code`/`countries` and `brands`/`brand_name`\n    - `year_number`/`years` and `country_code`/`countries`\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 30 standard audiences).\n    The `Audiences` class is provided to make it easier to filter audiences.\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n    - `audience`\n    Any additional valid includes will be added to the default set.\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n    Parameters\n    ----------\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_number : int or list[int], optional\n        Study years, by default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, by default None\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, by default None\n    studies : int or list[int], optional\n        Fount studies IDs, by default None\n    filters : BrandscapeFilters or dict of filters, optional\n        BrandscapeFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results.\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\nfilters = _filters.BrandscapeFilters.ensure(\nfilters,\ncountry_code=country_code,\nyear_number=year_number,\naudiences=audiences,\nbrand_name=brand_name,\nstudies=studies,\n)\nquery: Query[_filters.BrandscapeFilters] = Query(\nfilters=filters,\nfields=fields,\ninclude=_default_brandscape_include(include),\nmetric_keys=metric_keys,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"brandscape-data\", query)\n# Prefix 'global' to avoid clashing with 'brand_name' on 'brand' includes\nreturn parse_response(items, \"global\", expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.raw_query","title":"<code>raw_query(endpoint, params)</code>  <code>async</code>","text":"<p>Perform a raw GET query to the Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>params</code> <code>Query</code> <p>Query <code>pydantic</code> model with query parameters.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def raw_query(self, endpoint: str, params: Query[F]) -&gt; List[JSONDict]:\n\"\"\"Perform a raw GET query to the Fount API, returning the response JSON data\n    instead of a `pandas` DataFrame.\n    Parameters\n    ----------\n    endpoint : str\n        Endpoint name\n    params : Query\n        Query `pydantic` model with query parameters.\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\nreturn list(await self._client.query(endpoint, params))\n</code></pre>"},{"location":"reference/client/#client.Client.studies","title":"<code>studies(country_codes=None, year_numbers=None, full_year=0, study_id=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, by default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, by default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict of filters</code> <p>StudiesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def studies(\nself,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nfull_year: Literal[0, 1] = 0,\nstudy_id: Optional[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `studies` endpoint.\n    Parameters\n    ----------\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, by default 0\n        A value of 1 will filter non-full-year studies.\n    study_id : int, optional\n        Fount study ID, by default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict of filters, optional\n        StudiesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results.\n    \"\"\"\nfilters = _filters.StudiesFilters.ensure(\nfilters,\ncountry_codes=country_codes,\nyear_numbers=year_numbers,\nfull_year=full_year,\n)\nquery: Query[_filters.StudiesFilters] = Query(\nid=study_id,\nfilters=filters,\nfields=fields,\ninclude=include,\n**kwargs,  # type: ignore[arg-type]\n)\nitems = await self._client.query(\"studies\", query)\nreturn parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>Exceptions for handling errors with the Fount API.</p>"},{"location":"reference/exceptions/#exceptions.APIError","title":"<code>APIError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for errors interacting with APIs.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class APIError(Exception):\n\"\"\"Exception for errors interacting with APIs.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.DataNotFoundError","title":"<code>DataNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for when the request returns no data.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class DataNotFoundError(Exception):\n\"\"\"Exception for when the request returns no data.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.RateLimitExceededError","title":"<code>RateLimitExceededError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for when the request exceeds the rate limit.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class RateLimitExceededError(Exception):\n\"\"\"Exception for when the request exceeds the rate limit.\"\"\"\n</code></pre>"},{"location":"reference/filters/","title":"filters","text":"<p>Filter objects for Fount API queries based on <code>pydantic</code>.</p>"},{"location":"reference/filters/#filters.AudiencesFilters","title":"<code>AudiencesFilters</code>","text":"<p>         Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/audiences for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>Literal[0, 1], optional</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>inactive</code> <code>Literal[0, 1], optional</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>public</code> <code>Literal[0, 1], optional</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>private</code> <code>Literal[0, 1], optional</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>groups</code> <code>int or list[int], optional</code> <p>Audience group ID or list of audience group IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>str, date or datetime</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class AudiencesFilters(FountFilters):\n\"\"\"Filters for the `brands` endpoint.\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/audiences&gt;\n    for more info.\n    Attributes\n    ----------\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\nactive: Literal[0, 1] = 0\ninactive: Literal[0, 1] = 0\npublic: Literal[0, 1] = 0\nprivate: Literal[0, 1] = 0\ngroups: OptionalListOr[int] = None\n</code></pre>"},{"location":"reference/filters/#filters.BrandsFilters","title":"<code>BrandsFilters</code>","text":"<p>         Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>Filters other than <code>country_codes</code> and <code>year_numbers</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brands for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>str or list[str], optional</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_numbers</code> <code>int or list[int], optional</code> <p>Study years in numerical format (not IDs), by default None</p> <code>categories</code> <code>int or list[int], optional</code> <p>Fount category ID or list of category IDs, by default None</p> <code>countries</code> <code>int or list[int], optional</code> <p>Fount country ID or list of country IDs, by default None</p> <code>regions</code> <code>int or list[int], optional</code> <p>Fount region ID or list of region IDs, by default None</p> <code>sectors</code> <code>int or list[int], optional</code> <p>Fount sector ID or list of sector IDs, by default None</p> <code>studies</code> <code>int or list[int], optional</code> <p>Fount study ID or list of study IDs, by default None</p> <code>years</code> <code>int or list[int], optional</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>str, date or datetime</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandsFilters(FountFilters):\n\"\"\"Filters for the `brands` endpoint.\n    Filters other than `country_codes` and `year_numbers` filter by\n    the Fount IDs of the specific resources.\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brands&gt;\n    for more info.\n    Attributes\n    ----------\n    country_codes : str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    categories : int or list[int], optional\n        Fount category ID or list of category IDs, by default None\n    countries : int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n    regions : int or list[int], optional\n        Fount region ID or list of region IDs, by default None\n    sectors : int or list[int], optional\n        Fount sector ID or list of sector IDs, by default None\n    studies : int or list[int], optional\n        Fount study ID or list of study IDs, by default None\n    years : int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\ncountry_codes: OptionalListOr[str] = None\nyear_numbers: OptionalListOr[int] = None\ncategories: OptionalListOr[int] = None\ncountries: OptionalListOr[int] = None\nregions: OptionalListOr[int] = None\nsectors: OptionalListOr[int] = None\nstudies: OptionalListOr[int] = None\nyears: OptionalListOr[int] = None\n</code></pre>"},{"location":"reference/filters/#filters.BrandscapeFilters","title":"<code>BrandscapeFilters</code>","text":"<p>         Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>audiences</code>, <code>countries</code>, <code>studies</code>, <code>years</code>, <code>brands</code> and <code>categories</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brandscape-data for more info.</p> <p>The <code>brandscape-data</code> endpoint requires the use of, at minimum, these filters:</p> <ul> <li><code>studies</code></li> <li><code>brand_name</code> or <code>brands</code></li> <li><code>country_code</code> or <code>countries</code> and <code>brands</code> or <code>brand_name</code></li> <li><code>year_number</code> or <code>years</code> and <code>country_code</code> or <code>countries</code></li> </ul> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 30 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Attributes:</p> Name Type Description <code>country_code</code> <code>str or list[str], optional</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_number</code> <code>int or list[int], optional</code> <p>Study years in numerical format (not IDs), by default None</p> <code>audiences</code> <code>int or list[int], optional</code> <p>Fount ID of the desired audience, by default None</p> <p>The <code>Audiences</code> class can help with using audience IDs.</p> <code>brand_name</code> <code>str, optional</code> <p>Perform a search on the brand name, by default None</p> <code>brands</code> <code>int or list[int], optional</code> <p>Fount brand ID or list of brand IDs, by default None</p> <code>categories</code> <code>int or list[int], optional</code> <p>Fount category ID or list of category IDs, by default None</p> <code>countries</code> <code>int or list[int], optional</code> <p>Fount country ID or list of country IDs, by default None</p> <p>The <code>Countries</code> class can help with using country IDs.</p> <code>studies</code> <code>int or list[int], optional</code> <p>Fount study ID or list of study IDs, by default None</p> <code>years</code> <code>int or list[int], optional</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>str, date or datetime</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandscapeFilters(FountFilters):\n\"\"\"Filters for the `studies` endpoint.\n    `audiences`, `countries`, `studies`, `years`, `brands` and `categories` filter by\n    the Fount IDs of the specific resources.\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brandscape-data&gt;\n    for more info.\n    The `brandscape-data` endpoint requires the use of, at minimum, these filters:\n    - `studies`\n    - `brand_name` or `brands`\n    - `country_code` or `countries` and `brands` or `brand_name`\n    - `year_number` or `years` and `country_code` or `countries`\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 30 standard audiences).\n    The `Audiences` class is provided to make it easier to filter audiences.\n    Attributes\n    ----------\n    country_code : str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_number : int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    audiences : int or list[int], optional\n        Fount ID of the desired audience, by default None\n        The `Audiences` class can help with using audience IDs.\n    brand_name : str, optional\n        Perform a search on the brand name, by default None\n    brands : int or list[int], optional\n        Fount brand ID or list of brand IDs, by default None\n    categories : int or list[int], optional\n        Fount category ID or list of category IDs, by default None\n    countries : int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n        The `Countries` class can help with using country IDs.\n    studies : int or list[int], optional\n        Fount study ID or list of study IDs, by default None\n    years : int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\ncountry_code: OptionalListOr[str] = None\nyear_number: OptionalListOr[int] = None\naudiences: OptionalListOr[int] = None\nbrand_name: Optional[str] = None\nstudies: OptionalListOr[int] = None\ncountries: OptionalListOr[int] = None\nyears: OptionalListOr[int] = None\nbrands: OptionalListOr[int] = None\ncategories: OptionalListOr[int] = None\n@model_validator(mode=\"before\")\n@classmethod\ndef _check_params(cls, values: Dict[str, object]) -&gt; Dict[str, object]:\nif not (\n\"brands\" in values\nor \"brand_name\" in values\nor \"studies\" in values\nor (\n(\"country_code\" in values or \"countries\" in values)\nand (\"year_number\" in values or \"years\" in values)\n)\n):\nraise ValueError(\n\"You need to apply either the `brands`, or `studies`, or `brand_name` \"\n\"filters, or the `country_code`/`countries` \"\n\"and `year_number`/`years` filters together.\"\n)\nreturn values\n</code></pre>"},{"location":"reference/filters/#filters.FountFilters","title":"<code>FountFilters</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Base class for Fount API Filters.</p> <p>Can be used with <code>raw_query</code> endpoints.</p> <p>Attributes:</p> Name Type Description <code>updated_since</code> <code>str, date or datetime, optional</code> <p>Request items that have been updated since the specified date, by default None</p> <code>**kwargs</code> <code>str, int or float, or list of str, int or floats, optional</code> <p>Any additional filters to apply to the request, including for columns within the response data.</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class FountFilters(BaseModel):\n\"\"\"Base class for Fount API Filters.\n    Can be used with `raw_query` endpoints.\n    Attributes\n    ----------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    **kwargs : str, int or float, or list of str, int or floats, optional\n        Any additional filters to apply to the request, including for columns within\n        the response data.\n    \"\"\"\n# Allow arbitrary filters for compatibility with raw_query\nmodel_config = {\"extra\": \"allow\"}\nupdated_since: DTValues = None\n@field_validator(\"updated_since\", mode=\"before\")\n@classmethod\ndef _parse_date(cls, value: DTValues) -&gt; Optional[str]:\nif value is None:\nreturn value\nreturn parse_date(value)\n@classmethod\ndef ensure(\ncls: Type[F],\nfilters: Optional[FiltersOrMapping[\"FountFilters\"]],\n**addl_filters: InputSequenceOrValues,\n) -&gt; Optional[F]:\n\"\"\"Ensure FountFilters class from dictionary or other FountFilters class.\n        Parameters\n        ----------\n        filters : FountFilters or dict of filter values, optional\n            Dictionary of filters or FountFilters class.\n        **addl_filters : SequenceOrValues, optional\n            Additional filters to add to the new FountFilters instance.\n        Returns\n        -------\n        FountFilters, optional\n            FountFilters class or None if `filters` is None and no additional filters are passed.\n        Notes\n        -----\n        Defaults to values passed to `filters` when any additional filters overlap.\n        \"\"\"\naddl_filters = {k: v for k, v in addl_filters.items() if v}\nif filters is None:\nif not addl_filters:\nreturn None\nreturn cls(**addl_filters)  # type: ignore[arg-type]\nnew_filters = addl_filters.copy()\nif isinstance(filters, Mapping):\nnew_filters.update(filters)\nelse:\nnew_filters.update(filters.model_dump(exclude_defaults=True))\nreturn cls(**new_filters)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/filters/#filters.FountFilters.ensure","title":"<code>ensure(filters, **addl_filters)</code>  <code>classmethod</code>","text":"<p>Ensure FountFilters class from dictionary or other FountFilters class.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FountFilters or dict of filter values</code> <p>Dictionary of filters or FountFilters class.</p> required <code>**addl_filters</code> <code>SequenceOrValues</code> <p>Additional filters to add to the new FountFilters instance.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FountFilters, optional</code> <p>FountFilters class or None if <code>filters</code> is None and no additional filters are passed.</p>"},{"location":"reference/filters/#filters.FountFilters.ensure--notes","title":"Notes","text":"<p>Defaults to values passed to <code>filters</code> when any additional filters overlap.</p> Source code in <code>bavapi\\filters.py</code> <pre><code>@classmethod\ndef ensure(\ncls: Type[F],\nfilters: Optional[FiltersOrMapping[\"FountFilters\"]],\n**addl_filters: InputSequenceOrValues,\n) -&gt; Optional[F]:\n\"\"\"Ensure FountFilters class from dictionary or other FountFilters class.\n    Parameters\n    ----------\n    filters : FountFilters or dict of filter values, optional\n        Dictionary of filters or FountFilters class.\n    **addl_filters : SequenceOrValues, optional\n        Additional filters to add to the new FountFilters instance.\n    Returns\n    -------\n    FountFilters, optional\n        FountFilters class or None if `filters` is None and no additional filters are passed.\n    Notes\n    -----\n    Defaults to values passed to `filters` when any additional filters overlap.\n    \"\"\"\naddl_filters = {k: v for k, v in addl_filters.items() if v}\nif filters is None:\nif not addl_filters:\nreturn None\nreturn cls(**addl_filters)  # type: ignore[arg-type]\nnew_filters = addl_filters.copy()\nif isinstance(filters, Mapping):\nnew_filters.update(filters)\nelse:\nnew_filters.update(filters.model_dump(exclude_defaults=True))\nreturn cls(**new_filters)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/filters/#filters.StudiesFilters","title":"<code>StudiesFilters</code>","text":"<p>         Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>years</code>, <code>countries</code> and <code>regions</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/studies for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>str or list[str], optional</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_numbers</code> <code>int or list[int], optional</code> <p>Study years in numerical format (not IDs), by default None</p> <code>full_year</code> <code>Literal[0, 1], optional</code> <p>Return full year studies when set to <code>1</code> (excludes US quarterly), by default 0</p> <code>released</code> <code>Literal[0, 1], optional</code> <p>Return released studies when set to <code>1</code>, by default 0</p> <code>unreleased</code> <code>Literal[0, 1], optional</code> <p>Return unreleased studies when set to <code>1</code>, by default 0</p> <code>open_survey</code> <code>Literal[0, 1], optional</code> <p>Return studies with open brand requests when set to <code>1</code>, by default 0</p> <code>active</code> <code>Literal[0, 1], optional</code> <p>Return active audiences when set to <code>1</code>, by default 0</p> <code>inactive</code> <code>Literal[0, 1], optional</code> <p>Return inactive audiences when set to <code>1</code>, by default 0</p> <code>bav_study</code> <code>Literal[0, 1], optional</code> <p>Return full BAV studies when set to <code>1</code>, by default 0</p> <code>data_updated_since</code> <code>DTValues, optional</code> <p>Return studies updated since datetime value, by default None</p> <code>countries</code> <code>int or list[int], optional</code> <p>Fount country ID or list of country IDs, by default None</p> <code>regions</code> <code>int or list[int], optional</code> <p>Fount region ID or list of region IDs, by default None</p> <code>years</code> <code>int or list[int], optional</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>str, date or datetime</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class StudiesFilters(FountFilters):\n\"\"\"Filters for the `studies` endpoint.\n    `years`, `countries` and `regions` filter by the Fount IDs of the specific resources.\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/studies&gt;\n    for more info.\n    Attributes\n    ----------\n    country_codes: str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_numbers: int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    full_year: Literal[0, 1], optional\n        Return full year studies when set to `1` (excludes US quarterly), by default 0\n    released: Literal[0, 1], optional\n        Return released studies when set to `1`, by default 0\n    unreleased: Literal[0, 1], optional\n        Return unreleased studies when set to `1`, by default 0\n    open_survey: Literal[0, 1], optional\n        Return studies with open brand requests when set to `1`, by default 0\n    active: Literal[0, 1], optional\n        Return active audiences when set to `1`, by default 0\n    inactive: Literal[0, 1], optional\n        Return inactive audiences when set to `1`, by default 0\n    bav_study: Literal[0, 1], optional\n        Return full BAV studies when set to `1`, by default 0\n    data_updated_since: DTValues, optional\n        Return studies updated since datetime value, by default None\n    countries: int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n    regions: int or list[int], optional\n        Fount region ID or list of region IDs, by default None\n    years: int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\ncountry_codes: OptionalListOr[str] = None\nyear_numbers: OptionalListOr[int] = None\nfull_year: Literal[0, 1] = 0\nreleased: Literal[0, 1] = 0\nunreleased: Literal[0, 1] = 0\nopen_survey: Literal[0, 1] = 0\nactive: Literal[0, 1] = 0\ninactive: Literal[0, 1] = 0\nbav_study: Literal[0, 1] = 0\ndata_updated_since: DTValues = None\nyears: OptionalListOr[int] = None\ncountries: OptionalListOr[int] = None\nregions: OptionalListOr[int] = None\n@field_validator(\"data_updated_since\", mode=\"before\")\n@classmethod\ndef _parse_date(cls, value: DTValues) -&gt; Optional[str]:\nif value is None:\nreturn value\nreturn parse_date(value)\n</code></pre>"},{"location":"reference/http/","title":"http","text":"<p>Class for interacting with paginated APIs over HTTP.</p>"},{"location":"reference/http/#http.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>HTTP client for interacting with paginated API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the API.</p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, by default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 5.0</p> <code>5.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, by default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>headers</code> <code>dict[str, str]</code> <p>Collection of headers to send with each request, by default None</p> <code>None</code> <code>client</code> <code>httpx.AsyncClient</code> <p>Authenticated <code>httpx.AsyncClient</code>, by default None</p> <code>None</code> Source code in <code>bavapi\\http.py</code> <pre><code>class HTTPClient:\n\"\"\"HTTP client for interacting with paginated API.\n    Parameters\n    ----------\n    base_url : str\n        The base URL of the API.\n    per_page : int, optional\n        Default number of entries per page, by default 100\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 5.0\n    verify : bool or str, optional\n        Verify SSL credentials, by default True\n        Also accepts a path string to an SSL certificate file.\n    headers : dict[str, str], optional\n        Collection of headers to send with each request, by default None\n    client : httpx.AsyncClient, optional\n        Authenticated `httpx.AsyncClient`, by default None\n    \"\"\"\nC = TypeVar(\"C\", bound=\"HTTPClient\")\n@overload\ndef __init__(\nself,\nbase_url: str,\nper_page: int = 100,\ntimeout: float = 5.0,\nverify: Union[bool, str] = True,\n*,\nheaders: Optional[Dict[str, str]] = None,\n) -&gt; None:\n...\n@overload\ndef __init__(self, *, client: httpx.AsyncClient = ..., per_page: int = 100) -&gt; None:\n...\ndef __init__(\nself,\nbase_url: str = \"\",\nper_page: int = 100,\ntimeout: float = 5.0,\nverify: Union[bool, str] = True,\n*,\nheaders: Optional[Dict[str, str]] = None,\nclient: Optional[httpx.AsyncClient] = None,\n) -&gt; None:\nself.per_page = per_page\nif client is not None:\nself.client = client\nelse:\nself.client = httpx.AsyncClient(\nheaders=headers,\ntimeout=timeout,\nverify=verify,\nbase_url=base_url,\n)\nasync def __aenter__(self: C) -&gt; C:\nawait self.client.__aenter__()\nreturn self\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_value: Optional[BaseException] = None,\ntraceback: \"Optional[TracebackType]\" = None,\n) -&gt; None:\nawait self.client.__aexit__(exc_type, exc_value, traceback)\nasync def aclose(self) -&gt; None:\n\"\"\"Asynchronously close all client connections.\"\"\"\nreturn await self.client.aclose()\nasync def get(self, endpoint: str, params: Query) -&gt; httpx.Response:\n\"\"\"Perform GET request on the given endpoint.\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n        Returns\n        -------\n        httpx.Response\n            Requested response object.\n        Raises\n        ------\n        APIError\n            If request fails.\n        \"\"\"\nif params.item_id is not None:\nresp = await self.client.get(f\"{endpoint}/{params.item_id}\")\nelse:\nresp = await self.client.get(\nendpoint,\nparams=params.to_params(endpoint),\n)\nif resp.status_code != 200:\ntry:\nmessage = resp.json()[\"message\"]\nexcept (KeyError, JSONDecodeError):\nmessage = \"An error occurred with the Fount.\"\nraise APIError(f\"Error {resp.status_code}:\\n{message}\\nurl={resp.url}\")\nreturn resp\nasync def get_pages(\nself, endpoint: str, params: Query, n_pages: int\n) -&gt; List[httpx.Response]:\n\"\"\"Perform GET requests for a given number of pages on an endpoint.\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n        n_pages : int\n            Number of pages to request.\n        Returns\n        -------\n        list[httpx.Response]\n            List of response objects.\n        \"\"\"\ntasks = [\nasyncio.create_task(self.get(endpoint, p))\nfor p in params.paginated(self.per_page, n_pages)\n]\ntry:\nreturn cast(\nList[httpx.Response],\nawait tqdm.gather(*tasks, desc=f\"{endpoint} query\"),\n)\nexcept Exception as exc:\nfor task in tasks:\ntask.cancel()\nraise exc\nasync def query(self, endpoint: str, params: Query) -&gt; Iterator[JSONDict]:\n\"\"\"Perform a paginated GET request on the given endpoint.\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n        Returns\n        -------\n        Iterator[JSONDict]\n            An iterator of JSONDict objects.\n        Raises\n        ------\n        APIError\n            If any request fails.\n        DataNotFoundError\n            If response data is empty.\n        RateLimitExceededError\n            If response would exceed the rate limit.\n        \"\"\"\nresp = await self.get(endpoint, params=params)\npayload: Dict[str, JSONData] = resp.json()\ndata: JSONData = payload[\"data\"]\nif not data:\nraise DataNotFoundError(\"Your query returned no results.\")\nif isinstance(data, dict):\nreturn iter((data,))\nmeta = cast(JSONDict, payload[\"meta\"])\ntotal = cast(int, meta[\"total\"])\nif params.page or len(data) == total:\nreturn iter(data)\nn_pages = params.max_pages or math.ceil(\n(total) / (params.per_page or self.per_page)\n)\nif n_pages &gt; int(resp.headers[\"x-ratelimit-remaining\"]):\nraise RateLimitExceededError(\nf\"Number of pages ({n_pages}) for this request \"\nf\"exceeds the rate limit ({resp.headers['x-ratelimit-remaining']}, \"\nf\"total={resp.headers['x-ratelimit-limit']}).\"\n)\npages = await self.get_pages(endpoint, params, n_pages)\nreturn (i for page in pages for i in page.json()[\"data\"])\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Asynchronously close all client connections.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def aclose(self) -&gt; None:\n\"\"\"Asynchronously close all client connections.\"\"\"\nreturn await self.client.aclose()\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get","title":"<code>get(endpoint, params)</code>  <code>async</code>","text":"<p>Perform GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>httpx.Response</code> <p>Requested response object.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If request fails.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def get(self, endpoint: str, params: Query) -&gt; httpx.Response:\n\"\"\"Perform GET request on the given endpoint.\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n    Returns\n    -------\n    httpx.Response\n        Requested response object.\n    Raises\n    ------\n    APIError\n        If request fails.\n    \"\"\"\nif params.item_id is not None:\nresp = await self.client.get(f\"{endpoint}/{params.item_id}\")\nelse:\nresp = await self.client.get(\nendpoint,\nparams=params.to_params(endpoint),\n)\nif resp.status_code != 200:\ntry:\nmessage = resp.json()[\"message\"]\nexcept (KeyError, JSONDecodeError):\nmessage = \"An error occurred with the Fount.\"\nraise APIError(f\"Error {resp.status_code}:\\n{message}\\nurl={resp.url}\")\nreturn resp\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get_pages","title":"<code>get_pages(endpoint, params, n_pages)</code>  <code>async</code>","text":"<p>Perform GET requests for a given number of pages on an endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <code>n_pages</code> <code>int</code> <p>Number of pages to request.</p> required <p>Returns:</p> Type Description <code>list[httpx.Response]</code> <p>List of response objects.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def get_pages(\nself, endpoint: str, params: Query, n_pages: int\n) -&gt; List[httpx.Response]:\n\"\"\"Perform GET requests for a given number of pages on an endpoint.\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n    n_pages : int\n        Number of pages to request.\n    Returns\n    -------\n    list[httpx.Response]\n        List of response objects.\n    \"\"\"\ntasks = [\nasyncio.create_task(self.get(endpoint, p))\nfor p in params.paginated(self.per_page, n_pages)\n]\ntry:\nreturn cast(\nList[httpx.Response],\nawait tqdm.gather(*tasks, desc=f\"{endpoint} query\"),\n)\nexcept Exception as exc:\nfor task in tasks:\ntask.cancel()\nraise exc\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.query","title":"<code>query(endpoint, params)</code>  <code>async</code>","text":"<p>Perform a paginated GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>Iterator[JSONDict]</code> <p>An iterator of JSONDict objects.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If any request fails.</p> <code>DataNotFoundError</code> <p>If response data is empty.</p> <code>RateLimitExceededError</code> <p>If response would exceed the rate limit.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def query(self, endpoint: str, params: Query) -&gt; Iterator[JSONDict]:\n\"\"\"Perform a paginated GET request on the given endpoint.\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n    Returns\n    -------\n    Iterator[JSONDict]\n        An iterator of JSONDict objects.\n    Raises\n    ------\n    APIError\n        If any request fails.\n    DataNotFoundError\n        If response data is empty.\n    RateLimitExceededError\n        If response would exceed the rate limit.\n    \"\"\"\nresp = await self.get(endpoint, params=params)\npayload: Dict[str, JSONData] = resp.json()\ndata: JSONData = payload[\"data\"]\nif not data:\nraise DataNotFoundError(\"Your query returned no results.\")\nif isinstance(data, dict):\nreturn iter((data,))\nmeta = cast(JSONDict, payload[\"meta\"])\ntotal = cast(int, meta[\"total\"])\nif params.page or len(data) == total:\nreturn iter(data)\nn_pages = params.max_pages or math.ceil(\n(total) / (params.per_page or self.per_page)\n)\nif n_pages &gt; int(resp.headers[\"x-ratelimit-remaining\"]):\nraise RateLimitExceededError(\nf\"Number of pages ({n_pages}) for this request \"\nf\"exceeds the rate limit ({resp.headers['x-ratelimit-remaining']}, \"\nf\"total={resp.headers['x-ratelimit-limit']}).\"\n)\npages = await self.get_pages(endpoint, params, n_pages)\nreturn (i for page in pages for i in page.json()[\"data\"])\n</code></pre>"},{"location":"reference/http/#http.Query","title":"<code>Query</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Protocol for Query objects.</p> Source code in <code>bavapi\\http.py</code> <pre><code>class Query(Protocol):\n\"\"\"Protocol for Query objects.\"\"\"\nitem_id: Optional[int]\nmax_pages: Optional[int]\nper_page: Optional[int]\npage: Optional[int]\ndef to_params(self, endpoint: str) -&gt; BaseParamsMapping:\n\"\"\"HTTP-compatible params dictionary\"\"\"\nraise NotImplementedError\ndef paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query\"]:\n\"\"\"Yields Query objects with page parameters for paginated queries\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/http/#http.Query.paginated","title":"<code>paginated(per_page, n_pages)</code>","text":"<p>Yields Query objects with page parameters for paginated queries</p> Source code in <code>bavapi\\http.py</code> <pre><code>def paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query\"]:\n\"\"\"Yields Query objects with page parameters for paginated queries\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/http/#http.Query.to_params","title":"<code>to_params(endpoint)</code>","text":"<p>HTTP-compatible params dictionary</p> Source code in <code>bavapi\\http.py</code> <pre><code>def to_params(self, endpoint: str) -&gt; BaseParamsMapping:\n\"\"\"HTTP-compatible params dictionary\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"reference/jupyter/","title":"jupyter","text":"<p>Functions to check whether <code>bavapi</code> is being run from a <code>jupyter</code> notebook.</p> <p>These functions enable <code>bavapi</code> to be run from a <code>jupyter</code> notebook more easily, avoiding the use of <code>async with</code> and <code>await</code> statements.</p>"},{"location":"reference/jupyter/#jupyter.patch_loop","title":"<code>patch_loop(loop)</code>","text":"<p>Patch asyncio loop with <code>nest_asyncio</code>.</p> Source code in <code>bavapi\\jupyter.py</code> <pre><code>def patch_loop(loop: \"AbstractEventLoop\") -&gt; None:\n\"\"\"Patch asyncio loop with `nest_asyncio`.\"\"\"\nnest_asyncio.apply(loop)\n</code></pre>"},{"location":"reference/jupyter/#jupyter.running_in_jupyter","title":"<code>running_in_jupyter()</code>","text":"<p>Determine if running within Jupyter.</p> <p>Inspired by https://github.com/ipython/ipython/issues/11694</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if running in Jupyter, else False.</p> Source code in <code>bavapi\\jupyter.py</code> <pre><code>def running_in_jupyter() -&gt; bool:\n\"\"\"\n    Determine if running within Jupyter.\n    Inspired by &lt;https://github.com/ipython/ipython/issues/11694&gt;\n    Returns\n    -------\n    bool\n        True if running in Jupyter, else False.\n    \"\"\"\nin_ipython = False\nin_ipython_kernel = False\nipython: Optional[object] = None\n# if IPython hasn't been imported, there's nothing to check\nif \"IPython\" in sys.modules:\nipython = sys.modules[\"IPython\"].__dict__[\"get_ipython\"]()\nin_ipython = ipython is not None\nif in_ipython:\nin_ipython_kernel = getattr(ipython, \"kernel\", None) is not None\nreturn in_ipython_kernel\n</code></pre>"},{"location":"reference/query/","title":"query","text":"<p>Query objects for Fount API queries based on <code>pydantic</code>.</p>"},{"location":"reference/query/#query.Query","title":"<code>Query</code>","text":"<p>         Bases: <code>BaseModel</code>, <code>Generic[F]</code></p> <p>Base WPPBAV Fount query.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int, optional</code> <p>Get specific resource by ID, by default None</p> <code>filters</code> <code>FountFilters instance or dict of filter values, optional</code> <p>Filters to apply to the query, by default None</p> <code>fields</code> <code>str or list[str], optional</code> <p>Specific fields to retrieve from the query, by default None</p> <code>include</code> <code>str or list[str], optional</code> <p>Additional resources to retrieve from the query, by default None</p> <code>metric_keys</code> <code>str or list[str], optional</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>sort</code> <code>str, optional</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name: <code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <code>page</code> <code>int, optional</code> <p>Get specific page from paginated response, by default None</p> <p>When None, the default value in the Fount is 1</p> <code>per_page</code> <code>int, optional</code> <p>Number of items per page, by default None</p> <p>When None, the default value in the Fount is 25</p> <p>When performing paged queries, Client uses 100 as the default <code>per_page</code>.</p> <code>max_pages</code> <code>int, optional</code> <p>Maximum number of pages to retrieve, by default None</p> <p>When None, all pages will be retrieved with a <code>per_page</code> value of 100 by default.</p> Source code in <code>bavapi\\query.py</code> <pre><code>class Query(BaseModel, Generic[F]):\n\"\"\"Base WPPBAV Fount query.\n    Attributes\n    ----------\n    id: int, optional\n        Get specific resource by ID, by default None\n    filters : FountFilters instance or dict of filter values, optional\n        Filters to apply to the query, by default None\n    fields: str or list[str], optional\n        Specific fields to retrieve from the query, by default None\n    include: str or list[str], optional\n        Additional resources to retrieve from the query, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n        Currently, this parameter is only available for the `brandscape-data` endpoint.\n    sort: str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    page: int, optional\n        Get specific page from paginated response, by default None\n        When None, the default value in the Fount is 1\n    per_page: int, optional\n        Number of items per page, by default None\n        When None, the default value in the Fount is 25\n        When performing paged queries, Client uses 100 as the default `per_page`.\n    max_pages: int, optional\n        Maximum number of pages to retrieve, by default None\n        When None, all pages will be retrieved with a `per_page` value of 100 by default.\n    \"\"\"\nitem_id: Optional[int] = Field(default=None, alias=\"id\")\nfilters: Optional[_filters.FiltersOrMapping[F]] = None\nfields: OptionalListOr[str] = None\ninclude: OptionalListOr[str] = None\nmetric_keys: OptionalListOr[str] = None\nsort: Optional[str] = None\npage: Optional[int] = None\nper_page: Optional[int] = None\nmax_pages: Optional[int] = None\ndef to_params(self, endpoint: str) -&gt; BaseParamsDictValues:\n\"\"\"Return Fount-compatible dictionary of the query.\n        Returns\n        -------\n        dict[str, Any]\n            Fount-compatible dictionary of the query.\n        \"\"\"\nexclude: Final[Set[str]] = {\"filters\", \"fields\", \"max_pages\"}\nfilters: BaseParamsMapping = {}\nfields: BaseMutableParamsMapping = {}\nif isinstance(self.filters, _filters.FountFilters):\nfilters = self.filters.model_dump(by_alias=True, exclude_defaults=True)\nelif self.filters is not None:\nfilters = cast(BaseParamsDict, self.filters)\nfilters = to_fount_params(filters, \"filter\")\nfields = to_fount_params(\n{endpoint.replace(\"-\", \"_\"): self.fields} if self.fields else fields,\n\"fields\",\n)\nparams = {\n**self.model_dump(exclude=exclude, by_alias=True, exclude_defaults=True),\n**filters,\n**fields,\n}\nreturn cast(BaseParamsDictValues, list_to_str(params))\ndef with_page(self, page: int, per_page: int) -&gt; \"Query[F]\":\n\"\"\"Create new instance of `Query` with page parameters if either is set to default.\n        Returns new instance of Query.\n        Parameters\n        ----------\n        page : int\n            Current page number\n        per_page : int\n            Number of results per page\n        Returns\n        -------\n        Query\n            New `Query` instance with page parameters.\n        \"\"\"\nif self.page and self.per_page:\nreturn self\nreturn self.__class__.model_construct(\nself.model_fields_set.union(   # pylint: disable=no-member\n{\"page\", \"per_page\"}\n),\npage=self.page or page,\nper_page=self.per_page or per_page,\nfilters=self.filters,  # avoid turning filters into dictionary\n**self.model_dump(\nby_alias=True,\nexclude={\"page\", \"per_page\", \"filters\"},\nexclude_defaults=True,\n),\n)\ndef paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query[F]\"]:\n\"\"\"Yield `Query` instances with page parameters for each page in `n_pages`.\n        For performing multiple paginated requests.\n        Yields\n        ------\n        Query\n            Query instances with page parameters set.\n        \"\"\"\nyield from (self.with_page(p, per_page) for p in range(1, n_pages + 1))\n</code></pre>"},{"location":"reference/query/#query.Query.paginated","title":"<code>paginated(per_page, n_pages)</code>","text":"<p>Yield <code>Query</code> instances with page parameters for each page in <code>n_pages</code>.</p> <p>For performing multiple paginated requests.</p> <p>Yields:</p> Type Description <code>Query</code> <p>Query instances with page parameters set.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query[F]\"]:\n\"\"\"Yield `Query` instances with page parameters for each page in `n_pages`.\n    For performing multiple paginated requests.\n    Yields\n    ------\n    Query\n        Query instances with page parameters set.\n    \"\"\"\nyield from (self.with_page(p, per_page) for p in range(1, n_pages + 1))\n</code></pre>"},{"location":"reference/query/#query.Query.to_params","title":"<code>to_params(endpoint)</code>","text":"<p>Return Fount-compatible dictionary of the query.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount-compatible dictionary of the query.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def to_params(self, endpoint: str) -&gt; BaseParamsDictValues:\n\"\"\"Return Fount-compatible dictionary of the query.\n    Returns\n    -------\n    dict[str, Any]\n        Fount-compatible dictionary of the query.\n    \"\"\"\nexclude: Final[Set[str]] = {\"filters\", \"fields\", \"max_pages\"}\nfilters: BaseParamsMapping = {}\nfields: BaseMutableParamsMapping = {}\nif isinstance(self.filters, _filters.FountFilters):\nfilters = self.filters.model_dump(by_alias=True, exclude_defaults=True)\nelif self.filters is not None:\nfilters = cast(BaseParamsDict, self.filters)\nfilters = to_fount_params(filters, \"filter\")\nfields = to_fount_params(\n{endpoint.replace(\"-\", \"_\"): self.fields} if self.fields else fields,\n\"fields\",\n)\nparams = {\n**self.model_dump(exclude=exclude, by_alias=True, exclude_defaults=True),\n**filters,\n**fields,\n}\nreturn cast(BaseParamsDictValues, list_to_str(params))\n</code></pre>"},{"location":"reference/query/#query.Query.with_page","title":"<code>with_page(page, per_page)</code>","text":"<p>Create new instance of <code>Query</code> with page parameters if either is set to default.</p> <p>Returns new instance of Query.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Current page number</p> required <code>per_page</code> <code>int</code> <p>Number of results per page</p> required <p>Returns:</p> Type Description <code>Query</code> <p>New <code>Query</code> instance with page parameters.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def with_page(self, page: int, per_page: int) -&gt; \"Query[F]\":\n\"\"\"Create new instance of `Query` with page parameters if either is set to default.\n    Returns new instance of Query.\n    Parameters\n    ----------\n    page : int\n        Current page number\n    per_page : int\n        Number of results per page\n    Returns\n    -------\n    Query\n        New `Query` instance with page parameters.\n    \"\"\"\nif self.page and self.per_page:\nreturn self\nreturn self.__class__.model_construct(\nself.model_fields_set.union(   # pylint: disable=no-member\n{\"page\", \"per_page\"}\n),\npage=self.page or page,\nper_page=self.per_page or per_page,\nfilters=self.filters,  # avoid turning filters into dictionary\n**self.model_dump(\nby_alias=True,\nexclude={\"page\", \"per_page\", \"filters\"},\nexclude_defaults=True,\n),\n)\n</code></pre>"},{"location":"reference/sync/","title":"sync","text":"<p>Convenience functions to perform queries to the Fount synchronously.</p> <p>Can be used directly without <code>asyncio</code>.</p> <p>Meant for experimentation, Jupyter notebooks, one-off scripts, etc.</p> <p>Use <code>bavapi.Client</code> for more advanced usage and performance benefits.</p>"},{"location":"reference/sync/#sync.audiences","title":"<code>audiences(token, name=None, audience_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Fount API token</p> required <code>name</code> <code>str</code> <p>Search audiences by name, by default None</p> <code>None</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, by default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, by default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict of filters</code> <p>AudiencesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def audiences(\ntoken: str,\nname: Optional[str] = None,\naudience_id: Optional[int] = None,\nactive: Literal[0, 1] = 0,\ninactive: Literal[0, 1] = 0,\npublic: Literal[0, 1] = 0,\nprivate: Literal[0, 1] = 0,\ngroups: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `audiences` endpoint.\n    Parameters\n    ----------\n    token : str\n        Fount API token\n    name : str, optional\n        Search audiences by name, by default None\n    audience_id : int, optional\n        Fount audience ID, by default None\n        If an audience ID is provided, only that audience will be returned\n    active : Literal[0, 1]\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1]\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1]\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1]\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n    filters : AudiencesFilters or dict of filters, optional\n        AudiencesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results\n    \"\"\"\nasync with Client(token) as fount:\nreturn await fount.audiences(\nname,\naudience_id,\nactive,\ninactive,\npublic,\nprivate,\ngroups,\nfilters=filters,\nfields=fields,\ninclude=include,\nstack_data=stack_data,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/sync/#sync.brands","title":"<code>brands(token, name=None, country_codes=None, year_numbers=None, brand_id=None, studies=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Fount API token</p> required <code>name</code> <code>str</code> <p>Search brands by name, by default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, by default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict of filters</code> <p>BrandsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brands(\ntoken: str,\nname: Optional[str] = None,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nbrand_id: Optional[int] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brands` endpoint\n    Parameters\n    ----------\n    token : str\n        Fount API token\n    name : str, optional\n        Search brands by name, by default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    brand_id : int, optional\n        Fount brand ID, by default None\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, by default None\n    filters : BrandsFilters or dict of filters, optional\n        BrandsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results\n    \"\"\"\nasync with Client(token) as fount:\nreturn await fount.brands(\nname,\ncountry_codes,\nyear_numbers,\nbrand_id,\nstudies,\nfilters=filters,\nfields=fields,\ninclude=include,\nstack_data=stack_data,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/sync/#sync.brandscape_data","title":"<code>brandscape_data(token, country_code=None, year_number=None, audiences=None, brand_name=None, studies=None, *, filters=None, fields=None, include=None, metric_keys=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of parameters:</p> <ul> <li><code>studies</code></li> <li><code>brand_name</code> or <code>brands</code></li> <li><code>country_code</code> or <code>countries</code> and <code>brands</code> or <code>brand_name</code></li> <li><code>year_number</code> or <code>years</code> and <code>country_code</code> or <code>countries</code></li> </ul> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 30 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Fount API token</p> required <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, by default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, by default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict of filters</code> <p>BrandscapeFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brandscape_data(\ntoken: str,\ncountry_code: OptionalListOr[str] = None,\nyear_number: OptionalListOr[int] = None,\naudiences: OptionalListOr[int] = None,\nbrand_name: Optional[str] = None,\nstudies: OptionalListOr[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nmetric_keys: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `brandscape-data` endpoint.\n    This endpoint requires at least one of the following combinations of parameters:\n    - `studies`\n    - `brand_name` or `brands`\n    - `country_code` or `countries` and `brands` or `brand_name`\n    - `year_number` or `years` and `country_code` or `countries`\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 30 standard audiences).\n    The `Audiences` class is provided to make it easier to filter audiences.\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n    Any additional valid includes will be added to the default set.\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n    Parameters\n    ----------\n    token : str\n        Fount API token\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_number : int or list[int], optional\n        Study years, by default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, by default None\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, by default None\n    studies : int or list[int], optional\n        Fount studies IDs, by default None\n    filters : BrandscapeFilters or dict of filters, optional\n        BrandscapeFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\nasync with Client(token) as fount:\nreturn await fount.brandscape_data(\ncountry_code,\nyear_number,\naudiences,\nbrand_name,\nstudies,\nfilters=filters,\nfields=fields,\nmetric_keys=metric_keys,\ninclude=include,\nstack_data=stack_data,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/sync/#sync.raw_query","title":"<code>raw_query(token, endpoint, params)</code>  <code>async</code>","text":"<p>Perform a raw GET query to the Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Fount API token</p> required <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>params</code> <code>Query</code> <p>Query <code>pydantic</code> model with query parameters.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def raw_query(token: str, endpoint: str, params: Query[F]) -&gt; List[JSONDict]:\n\"\"\"Perform a raw GET query to the Fount API, returning the response JSON data\n    instead of a `pandas` DataFrame.\n    Parameters\n    ----------\n    token : str\n        Fount API token\n    endpoint : str\n        Endpoint name\n    params : Query\n        Query `pydantic` model with query parameters.\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\nasync with Client(token) as fount:\nreturn await fount.raw_query(endpoint, params)\n</code></pre>"},{"location":"reference/sync/#sync.studies","title":"<code>studies(token, country_codes=None, year_numbers=None, full_year=0, study_id=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Fount API token</p> required <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, by default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, by default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict of filters</code> <p>StudiesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>BaseListOrValues</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def studies(\ntoken: str,\ncountry_codes: OptionalListOr[str] = None,\nyear_numbers: OptionalListOr[int] = None,\nfull_year: Literal[0, 1] = 0,\nstudy_id: Optional[int] = None,\n*,\nfilters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\nfields: OptionalListOr[str] = None,\ninclude: OptionalListOr[str] = None,\nstack_data: bool = False,\n**kwargs: BaseListOrValues,\n) -&gt; \"DataFrame\":\n\"\"\"Query the Fount `studies` endpoint.\n    Parameters\n    ----------\n    token : str\n        Fount API token\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, by default 0\n        A value of 1 will filter non-full-year studies.\n    study_id : int, optional\n        Fount study ID, by default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict of filters, optional\n        StudiesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n        Sorts by item ID by default.\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results\n    \"\"\"\nasync with Client(token) as fount:\nreturn await fount.studies(\ncountry_codes,\nyear_numbers,\nfull_year,\nstudy_id,\nfilters=filters,\nfields=fields,\ninclude=include,\nstack_data=stack_data,\n**kwargs,\n)\n</code></pre>"},{"location":"reference/parsing/","title":"parsing","text":"<p>Modules for parsing parameters and responses.</p>"},{"location":"reference/parsing/params/","title":"params","text":"<p>Functions to parse parameter values.</p>"},{"location":"reference/parsing/params/#parsing.params.list_to_str","title":"<code>list_to_str(mapping)</code>","text":"<p>Convert any lists in a dictionary to a string with comma-separated elements.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>ParamsMapping</code> <p>Dictionary with lists</p> required <p>Returns:</p> Type Description <code>ParamsMappingValues</code> <p>Dictionary without strings</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def list_to_str(mapping: BaseMutableParamsMapping) -&gt; BaseMutableParamsMappingValues:\n\"\"\"Convert any lists in a dictionary to a string with comma-separated elements.\n    Parameters\n    ----------\n    mapping : ParamsMapping\n        Dictionary with lists\n    Returns\n    -------\n    ParamsMappingValues\n        Dictionary without strings\n    \"\"\"\nfor key, value in mapping.items():\nif not isinstance(value, str) and isinstance(value, Sequence):\nmapping[key] = \",\".join(str(i) for i in value)\nreturn cast(BaseMutableParamsMappingValues, mapping)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.parse_date","title":"<code>parse_date(value)</code>","text":"<p>Parse date string or datetime value into a date string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str, dt.datetime, dt.date</code> <p>Input to parse into a date string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The parsed date as a string.</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def parse_date(value: Union[str, dt.datetime, dt.date]) -&gt; str:\n\"\"\"Parse date string or datetime value into a date string.\n    Parameters\n    ----------\n    value : str, dt.datetime, dt.date\n        Input to parse into a date string.\n    Returns\n    -------\n    str\n        The parsed date as a string.\n    \"\"\"\nfmt_out = \"%Y-%m-%d %H:%M:%S\"\nif isinstance(value, dt.datetime):\nreturn value.strftime(fmt_out)\nif isinstance(value, dt.date):\nreturn dt.datetime.combine(value, dt.datetime.min.time()).strftime(fmt_out)\ntry:\nreturn dt.datetime.strptime(value, fmt_out).strftime(value)\nexcept ValueError:\nreturn dt.datetime.fromisoformat(value).strftime(fmt_out)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.to_fount_params","title":"<code>to_fount_params(data, param)</code>","text":"<p>Constructs dictionary keys for special Fount API formatting.</p> <p>The resulting dictionary keys will be formatted to include <code>param</code> as the main parameter name:</p> <p>to_fount_params({\"a\":1}, \"test\")</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary to format.</p> required <code>param</code> <code>str</code> <p>Parameter name.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount API parameter dictionary.</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def to_fount_params(data: Mapping[str, T], param: str) -&gt; Dict[str, T]:\n\"\"\"Constructs dictionary keys for special Fount API formatting.\n    The resulting dictionary keys will be formatted to include `param` as the\n    main parameter name:\n    &gt;&gt;&gt; to_fount_params({\"a\":1}, \"test\")\n    {\"test[a]\":1}\n    Parameters\n    ----------\n    data : dict[str, Any]\n        Dictionary to format.\n    param : str\n        Parameter name.\n    Returns\n    -------\n    dict[str, Any]\n        Fount API parameter dictionary.\n    \"\"\"\nreturn {f\"{param}[{k}]\": v for k, v in data.items()}\n</code></pre>"},{"location":"reference/parsing/responses/","title":"responses","text":"<p>Functions for parsing Fount API responses</p>"},{"location":"reference/parsing/responses/#parsing.responses.flatten","title":"<code>flatten(mapping, parent='', sep='_', prefix='', expand=False)</code>","text":"<p>Recursively flatten all nested mappings and lists in the given mapping.</p> <p>Returns an iterator because it expands any nested lists into new dictionaries, then yields each repeated dictionary with its corresponding value from the list.</p> <p>This is equivalent to a <code>JOIN</code> operation in a relational database, where lists represent multiple entries on the right table of the <code>JOIN</code>.</p> <p>Note: If many nested lists are present, this function will generate as many entries as the PRODUCT of the nested lists. If the mapping has one nested list with 5 elements, and another nested list with 5 elements, the function will yield 25 (5x5) dictionaries in total.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any] or mapping</code> <p>Dictionary with potential nested dictionaries and lists of dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, by default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, by default \"\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for keys that clash with keys in the top-level mapping, by default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <code>expand</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Yield flattened dictionaries.</p> <p>If expand is True and any nested lists are present, yield each resulting flattened dictionary.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def flatten(\nmapping: Mapping[str, Union[T, Mapping[str, T]]],\nparent: str = \"\",\nsep: str = \"_\",\nprefix: str = \"\",\nexpand: bool = False,\n) -&gt; Iterator[Dict[str, T]]:\n\"\"\"Recursively flatten all nested mappings and lists in the given mapping.\n    Returns an iterator because it expands any nested lists into new dictionaries,\n    then yields each repeated dictionary with its corresponding value from the list.\n    This is equivalent to a `JOIN` operation in a relational database, where lists\n    represent multiple entries on the right table of the `JOIN`.\n    Note: If many nested lists are present, this function will generate as many entries\n    as the PRODUCT of the nested lists. If the mapping has one nested list with 5\n    elements, and another nested list with 5 elements,\n    the function will yield 25 (5x5) dictionaries in total.\n    Parameters\n    ----------\n    mapping : dict[str, Any] or mapping\n        Dictionary with potential nested dictionaries and lists of dictionaries\n    parent : str\n        Parent key for generating children keys, by default \"\"\n    sep : str\n        Separator to use between keys and parent keys, by default \"\"\n    prefix: str\n        Prefix for keys that clash with keys in the top-level mapping, by default \"\"\n        An empty prefix will ignore key conflicts.\n    expand : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    Yields\n    ------\n    Iterator[dict[str, Any]]\n        Yield flattened dictionaries.\n        If expand is True and any nested lists are present, yield each resulting\n        flattened dictionary.\n    \"\"\"\nnew: Dict[str, T] = flatten_mapping(mapping, parent, sep, prefix)\nexpand_keys: List[str] = (\n[k for k, v in new.items() if isinstance(v, list)] if expand else []\n)\nif not expand_keys:\nyield new\nelse:\nfor key in expand_keys:\nvalues = cast(List[Mapping[str, T]], new[key])\nprint(key)\nfor val in values:\nfor i in flatten(val, key, sep, prefix, expand):\nyield {**{k: v for k, v in new.items() if k != key}, **i}\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.flatten_mapping","title":"<code>flatten_mapping(mapping, parent='', sep='_', prefix='')</code>","text":"<p>Recursively flattens all nested dictionaries into top level key-value pairs.</p> <p>Include prefixes or suffixes if nested keys clash with top-level keys.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any] or mapping</code> <p>Dictionary with potential nested dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, by default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, by default \"\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for nested keys that clash with keys in the top-level mapping, by default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Flattened dictionary.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def flatten_mapping(\nmapping: Mapping[str, Union[T, Mapping[str, T]]],\nparent: str = \"\",\nsep: str = \"_\",\nprefix: str = \"\",\n) -&gt; Dict[str, T]:\n\"\"\"Recursively flattens all nested dictionaries into top level key-value pairs.\n    Include prefixes or suffixes if nested keys clash with top-level keys.\n    Parameters\n    ----------\n    mapping : dict[str, Any] or mapping\n        Dictionary with potential nested dictionaries\n    parent : str\n        Parent key for generating children keys, by default \"\"\n    sep : str\n        Separator to use between keys and parent keys, by default \"\"\n    prefix: str\n        Prefix for nested keys that clash with keys in the top-level mapping, by default \"\"\n        An empty prefix will ignore key conflicts.\n    Returns\n    -------\n    dict[str, Any]\n        Flattened dictionary.\n    \"\"\"\nnew: Dict[str, T] = {}\nfor key, value in mapping.items():\nif parent:\nkey = f\"{parent}{sep}{key}\"\nif isinstance(value, Mapping):\nif prefix and any(\nk.startswith(key)\nfor k, v in mapping.items()\nif not isinstance(v, Mapping)\n):\nkey = f\"{prefix}{sep}{key}\"\nnew = {**new, **flatten_mapping(value, key, sep, prefix)}\nelse:\nnew[key] = value\nreturn new\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.parse_response","title":"<code>parse_response(page, prefix='', index=None, expand=False)</code>","text":"<p>Parse Fount API JSON into a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>iterable of dicts with keys of type str</code> <p>Page from API response.</p> required <code>prefix</code> <code>str</code> <p>Prefix to prepend to columns with clashing names, by default <code>\"\"</code></p> <code>''</code> <code>index</code> <code>str</code> <p>Column name to use as index, by default None.</p> <code>None</code> <code>expand</code> <code>bool</code> <p>Whether to expand lists of dictionaries into new entries (rows) in the resulting DataFrame, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame of the response data.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def parse_response(\npage: Iterable[Mapping[str, object]],\nprefix: str = \"\",\nindex: Optional[str] = None,\nexpand: bool = False,\n) -&gt; pd.DataFrame:\n\"\"\"Parse Fount API JSON into a pandas DataFrame.\n    Parameters\n    ----------\n    page : iterable of dicts with keys of type str\n        Page from API response.\n    prefix : str, optional\n        Prefix to prepend to columns with clashing names, by default `\"\"`\n    index : str, optional\n        Column name to use as index, by default None.\n    expand : bool, optional\n        Whether to expand lists of dictionaries into new entries (rows)\n        in the resulting DataFrame, by default False.\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame of the response data.\n    \"\"\"\nreturn (\npd.DataFrame.from_records(\n(i for item in page for i in flatten(item, prefix=prefix, expand=expand)),\nindex=index,\n)\n.dropna(axis=1, how=\"all\")\n.transform(pd.to_numeric, errors=\"ignore\")\n)\n</code></pre>"},{"location":"reference/reference/","title":"reference","text":"<p>Scripts to generate <code>bavapi</code> Reference classes.</p> <p>These reference classes make it easier to filter results by mapping commonly used IDs to human-readable options.</p> <p>To generate reference classes you will need a Fount API token. Please see the authentication section of the documentation for more info: https://developer.wppbav.com/docs/2.x/intro</p>"},{"location":"reference/reference/generate_reference/","title":"generate_reference","text":"<p>Script to update reference classes with latest active definitions from the Fount.</p>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.Args","title":"<code>Args</code>","text":"<p>Basic namespace for arguments with typing.</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>class Args:\n\"\"\"Basic namespace for arguments with typing.\"\"\"\n__slots__ = (\"all\", \"name\", \"folder\")\ndef __init__(self, namespace: argparse.Namespace) -&gt; None:\nself.all: bool = namespace.all\nself.name: str = namespace.name\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.RefConfig","title":"<code>RefConfig</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Config information for updating Fount references</p> <p>Attributes:</p> Name Type Description <code>endpoint</code> <code>str</code> <p>Fount API resource endpoint to use for updating references.</p> <code>filepath</code> <code>str</code> <p>Path to write the updated references to.</p> <code>parser</code> <code>Callable[[pd.Series], dict[str, str]]</code> <p>Function to parse the reference in pandas form to a dict of strings.</p> <code>resource_col</code> <code>str, optional</code> <p>Column to get the names for each item in the reference, by default \"name\"</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>class RefConfig(NamedTuple):\n\"\"\"Config information for updating Fount references\n    Attributes\n    ----------\n    endpoint : str\n        Fount API resource endpoint to use for updating references.\n    filepath : str\n        Path to write the updated references to.\n    parser : Callable[[pd.Series], dict[str, str]]\n        Function to parse the reference in pandas form to a dict of strings.\n    resource_col : str, optional\n        Column to get the names for each item in the reference, by default \"name\"\n    \"\"\"\nendpoint: str\nfilename: str\nparser: ReferenceParser\nresource_col: str = \"name\"\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.generate_source","title":"<code>generate_source(ref_name, ref_items, updated, import_items=('bavapi.reference._int_enum', 'IntEnum'))</code>","text":"<p>Generate updated module source from reference items.</p> <p>Parameters:</p> Name Type Description Default <code>ref_name</code> <code>str</code> <p>Name of the reference to generate. This name will also be the name of the reference class (\"countries\" -&gt; \"Countries\").</p> required <code>ref_items</code> <code>dict[str, str]</code> <p>Dictionary of reference information to generate from.</p> required <code>updated</code> <code>datetime.datetime</code> <p>Reference update timestamp.</p> required <code>import_items</code> <code>tuple[str, str]</code> <p>Elements for import statement, by default (\"bavapi.reference.base\", \"IntEnum\")</p> <code>('bavapi.reference._int_enum', 'IntEnum')</code> <p>Returns:</p> Type Description <code>str</code> <p>Updated source as a string.</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def generate_source(\nref_name: str,\nref_items: Dict[str, str],\nupdated: datetime.datetime,\nimport_items: Tuple[str, str] = (\"bavapi.reference._int_enum\", \"IntEnum\"),\n) -&gt; str:\n\"\"\"Generate updated module source from reference items.\n    Parameters\n    ----------\n    ref_name : str\n        Name of the reference to generate. This name will also be the name of the\n        reference class (\"countries\" -&gt; \"Countries\").\n    ref_items : dict[str, str]\n        Dictionary of reference information to generate from.\n    updated : datetime.datetime\n        Reference update timestamp.\n    import_items : tuple[str, str], optional\n        Elements for import statement, by default (\"bavapi.reference.base\", \"IntEnum\")\n    Returns\n    -------\n    str\n        Updated source as a string.\n    \"\"\"\nupdated_comment = (\nf\"# This file was generated from active {ref_name.lower()} in the Fount.\\n\"\nf\"# {ref_name.capitalize()} retrieved on {updated.strftime('%Y-%m-%d %H:%M:%S')}\"\n)\nclass_docstring = f'\"\"\"{ref_name.capitalize()} IDs for Fount API queries.\"\"\"'\nsource_items = [\nf'\"\"\"{ref_name.capitalize()} class for holding {ref_name} IDs.\"\"\"',\nupdated_comment,\nf\"from {import_items[0]} import {import_items[1]}\\n\",\nf\"class {ref_name.capitalize()}({import_items[1]}):\\n\" f\"    {class_docstring}\",\n\"\\n\".join(f\"    {k} = {v}\" for k, v in ref_items.items()),\n]\nreturn \"\\n\\n\".join(source_items) + \"\\n\"\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.get_references","title":"<code>get_references(fount, configs)</code>  <code>async</code>","text":"<p>Download items for the reference from the Fount.</p> <p>Parameters:</p> Name Type Description Default <code>fount</code> <code>Client</code> <p>Client instance to perform requests with.</p> required <code>configs</code> <code>list[RefConfig]</code> <p>Reference config object, with information about the filepath, endpoint resource parser function and the resource column.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of reference information for generating reference files.</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>async def get_references(\nfount: Client, configs: List[RefConfig]\n) -&gt; List[List[JSONDict]]:\n\"\"\"Download items for the reference from the Fount.\n    Parameters\n    ----------\n    fount : Client\n        Client instance to perform requests with.\n    configs : list[RefConfig]\n        Reference config object, with information about the filepath, endpoint\n        resource parser function and the resource column.\n    Returns\n    -------\n    dict[str, str]\n        Dictionary of reference information for generating reference files.\n    \"\"\"\nasync with fount:\ntasks = [\nasyncio.create_task(fount.raw_query(config.endpoint, Query()))\nfor config in configs\n]\nreturn await asyncio.gather(*tasks)\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.main","title":"<code>main(argv=None)</code>","text":"<p>Main function to generate reference classes.</p> <p>Returns:</p> Type Description <code>int</code> <p>CLI exit code</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def main(argv: Optional[List[str]] = None) -&gt; int:\n\"\"\"Main function to generate reference classes.\n    Returns\n    -------\n    int\n        CLI exit code\n    \"\"\"\nload_dotenv()\nargs = parse_args(argv)\nfount = Client(os.getenv(\"FOUNT_API_KEY\", \"no_key\"))\nbase_path = Path.cwd() / \"bavapi_refs\"\nprint(base_path)\nref_configs: Dict[str, RefConfig] = {\n\"audiences\": RefConfig(\"audiences\", \"audiences\", parse_audiences),\n\"countries\": RefConfig(\n\"studies\",\n\"countries\",\nparse_countries,\n\"country_name\",\n),\n}\nif args.all:\nnames, configs = list(ref_configs.keys()), list(ref_configs.values())\nelif not args.name:\nprint(\"bavapi-refs: Run `bavapi-refs -h` for usage instructions.\")\nreturn 1\nelse:\nnames, configs = [args.name], [ref_configs[args.name]]\nresults = asyncio.run(get_references(fount, configs))\nfor name, data, config in zip(names, results, configs):\nitems = process_items(data, config)\nsource = generate_source(name, items, datetime.datetime.utcnow())\npath = base_path / f\"{name}.py\"\nprint(f\"Writing {name} file with {len(items)} items to {path}\")\nwrite_to_file(source, path)\nprint(\"Success!\")\nreturn 0\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.parse_args","title":"<code>parse_args(argv=None)</code>","text":"<p>Parse arguments given to the script.</p> <p>Returns:</p> Type Description <code>argparse.Namespace</code> <p>Object containing arguments and values for the script</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def parse_args(argv: Optional[List[str]] = None) -&gt; Args:\n\"\"\"Parse arguments given to the script.\n    Returns\n    -------\n    argparse.Namespace\n        Object containing arguments and values for the script\n    \"\"\"\nparser = argparse.ArgumentParser(\ndescription=\"Generate reference files for commonly used BAV filters.\\n\\n\"\n\"The script will generate a set of reference files that contain \"\n\"helpful classes for filtering BAV data in readable form.\\n\\n\"\n\"The currently available reference classes are Audiences and Countries.\\n\"\n\"These classess will be stored in a `bavapi_refs` folder in your \"\n\"current working directory. \"\n\"You can import them using `from bavapi_refs.audiences import Audiences`.\\n\"\n\"Existing reference files will be overwritten.\",\nepilog=\"DON'T PUSH REFERENCES TO GIT! Add `bavapi_refs/` to `.gitignore`.\",\n)\nparser.add_argument(\n\"-a\", \"--all\", action=\"store_true\", help=\"Generate all reference files.\"\n)\nparser.add_argument(\n\"-n\",\n\"--name\",\ndefault=\"\",\nchoices={\"audiences\", \"countries\"},\nhelp=\"Name of reference to generate.\",\n)\nreturn Args(parser.parse_args(argv))\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.parse_reference","title":"<code>parse_reference(fetched, symbols, norm)</code>","text":"<p>Parse reference information from the Fount.</p> <p>Parameters:</p> Name Type Description Default <code>fetched</code> <code>pd.Series</code> <p>Pandas Series with reference information</p> required <code>symbols</code> <code>dict[str, str]</code> <p>Symbols to replace</p> required <code>norm</code> <code>dict[str, str]</code> <p>Elements in reference to normalize</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of reference information for generating reference files.</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def parse_reference(\nfetched: pd.Series, symbols: Dict[str, str], norm: Dict[str, str]\n) -&gt; Dict[str, str]:\n\"\"\"Parse reference information from the Fount.\n    Parameters\n    ----------\n    fetched : pd.Series\n        Pandas Series with reference information\n    symbols : dict[str, str]\n        Symbols to replace\n    norm : dict[str, str]\n        Elements in reference to normalize\n    Returns\n    -------\n    dict[str, str]\n        Dictionary of reference information for generating reference files.\n    \"\"\"\nfetched = fetched.str.upper().replace(symbols, regex=True).replace(norm, regex=True)\nreturn {str(v): str(k) for k, v in fetched.to_dict().items()}\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.process_items","title":"<code>process_items(data, config)</code>","text":"<p>Process raw Fount response into a dictionary of name to filter code pairs.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[JSONDict]</code> <p>List of JSON dictionaries representing each of the Fount reference items.</p> required <code>config</code> <code>RefConfig</code> <p>Reference configuration to use for processing items.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Pairs of reference item names and their corresponding code.</p> Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def process_items(data: List[JSONDict], config: RefConfig) -&gt; Dict[str, str]:\n\"\"\"Process raw Fount response into a dictionary of name to filter code pairs.\n    Parameters\n    ----------\n    data : list[JSONDict]\n        List of JSON dictionaries representing each of the Fount reference items.\n    config : RefConfig\n        Reference configuration to use for processing items.\n    Returns\n    -------\n    dict[str, str]\n        Pairs of reference item names and their corresponding code.\n    \"\"\"\nres_df = parse_response(data, index=\"id\")\nif \"is_active\" in res_df.columns:\nres_df = res_df[res_df[\"is_active\"].astype(bool)]\nitems = res_df[config.resource_col].drop_duplicates().pipe(config.parser).items()\nreturn dict(sorted(items))\n</code></pre>"},{"location":"reference/reference/generate_reference/#reference.generate_reference.write_to_file","title":"<code>write_to_file(source, filepath)</code>","text":"<p>Write updated module source to file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Updated module source as a string.</p> required <code>filepath</code> <code>pathlib.Path</code> <p>Path to write the source to.</p> required Source code in <code>bavapi\\reference\\generate_reference.py</code> <pre><code>def write_to_file(source: str, filepath: Path) -&gt; None:\n\"\"\"Write updated module source to file.\n    Parameters\n    ----------\n    source : str\n        Updated module source as a string.\n    filepath : pathlib.Path\n        Path to write the source to.\n    \"\"\"\nif not filepath.parent.exists():\nfilepath.parent.mkdir(parents=True, exist_ok=True)\nwith open(filepath, \"w\", encoding=\"utf-8\") as file:\nfile.write(source)\n</code></pre>"},{"location":"usage/advanced/","title":"Advanced Usage","text":"<p>This section is intended for developers who are interested in embedding <code>bavapi</code> functionality into their APIs and applications.</p> <p>Async support</p> <p><code>bavapi</code> natively supports asynchronous execution, so it is ready to work with popular <code>async</code> libraries such as <code>fastapi</code>.</p>"},{"location":"usage/advanced/#the-client-interface","title":"The <code>Client</code> interface","text":"<p>The <code>Client</code> class is the backbone of <code>bavapi</code>, and it is the recommended way to interact with the Fount for more advanced users.</p> <p>Tip</p> <p>If you're familiar with the <code>requests</code> or <code>httpx</code> python packages, this is similar to using <code>requests.Session()</code> or <code>httpx.Client()</code>.</p> <p>Using the <code>Client</code> class instead of the top-level endpoint functions (<code>bavapi.brands</code>, for example), can bring significant performance improvements, especially when performing multiple requests at the same time.</p> <p>The <code>Client</code> interface is based on <code>httpx.Client</code>, so it benefits from all the performance features from <code>httpx</code>:</p> <p>Quote from the <code>httpx</code> docs</p> <ul> <li>Reduced latency across requests (no handshaking).</li> <li>Reduced CPU usage and round-trips.</li> <li>Reduced network congestion.</li> </ul> <p>By using <code>Client</code>, you will also get all these benefits, including in Jupyter Notebooks.</p>"},{"location":"usage/advanced/#using-the-client-interface","title":"Using the <code>Client</code> interface","text":"<p>It is recommended to use <code>Client</code> in an <code>async with</code> block:</p> <pre><code>async with bavapi.Client(\"TOKEN\") as bav:\nresult = await bav.brands(\"Swatch\")\n</code></pre> <p>Otherwise, it is possible to use <code>Client</code> methods outside of an <code>async with</code> block, but it might be slightly less performant.</p> <pre><code>client = bavapi.Client(\"TOKEN\")\nresult = await client.brands(\"Swatch\")\nawait client.aclose()  # (1)\n</code></pre> <ol> <li> Close the connection by awaiting <code>aclose</code> after you're done with your requests.</li> </ol>"},{"location":"usage/advanced/#other-endpoints","title":"Other endpoints","text":"<p>Because of the large number of available endpoints in the Fount and the highly customizable queries, some endpoints won't have extended support from the start.</p> <p>Open for feedback</p> <p>If you would like to see new endpoints with full type annotation support, please open an issue on GitHub with the Feature Request template.</p> <p><code>bavapi</code> provides <code>raw_query</code> functions/methods to access all the available endpoints without existing endpoint functions/methods:</p> <ul> <li><code>bavapi.raw_query</code> for synchronous requests.</li> <li><code>bavapi.Client.raw_query</code> for asynchronous requests.</li> </ul> <p>These <code>raw_query</code> methods require the use of <code>bavapi.Query</code> instances to make the request:</p> <pre><code>async with bavapi.Client(\"TOKEN\") as fount:\nres = fount.raw_query(\"companies\", Query(filters=FountFilters(name=\"Facebook\")))\n</code></pre> <p>These functions will return a list of JSON dictionaries, one for each entry retrieved from the Fount:</p> <pre><code>[\n{\"name\": \"Apple\", \"id\": 1},\n{\"name\": \"Applebee's\", \"id\": 2},\n// ...\n]\n</code></pre> <p>Tip</p> <p>These methods are meant to be used for custom processing of data (not resulting in a <code>pandas</code> DataFrame), but it is also possible to use some of the parsing functions available in bavapi.parsing.responses.</p>"},{"location":"usage/advanced/#the-query-class","title":"The <code>Query</code> class","text":"<p><code>bavapi.Query</code> is a <code>pydantic</code>-powered class that holds and validates all the common (aside from endpoint-specific filters) query parameters to pass to the Fount API.</p> <p>The default values for the class are the same as the default values in the Fount API itself, so an empty <code>Query</code> object can be used to get all entries for a specific endpoint:</p> <pre><code>query = bavapi.Query()\nasync with bavapi.Client(\"TOKEN\") as fount:\nres = fount.raw_query(\"brand-metrics\", query) # (1)\n</code></pre> <ol> <li> Returns all entries for <code>brand-metrics</code>. Similar to making a <code>GET</code> request with no parameters.</li> </ol> <p><code>Query</code> can be used to set limits on the number of pages retrieved, or to request a specific page from a query:</p> <pre><code>bavapi.Query(\nper_page = 200,  # (1)\nmax_pages = 50,\n...  # Other params\n)\n</code></pre> <ol> <li> <p>Stick with defaults</p> <p>The default <code>per_page</code> value (<code>100</code>) has been set after testing various options for the best download speed. </p> </li> </ol>"},{"location":"usage/advanced/#query-parameters","title":"<code>Query</code> parameters","text":"<p>All Fount queries performed with <code>bavapi.Query</code> support the following parameters:</p> <ul> <li><code>id</code>: Return only results for a specific id.</li> <li><code>page</code>: The page number of results to return.</li> <li><code>per_page</code>: The number of results to return per page. Default is 25 and maximum is 100.</li> <li><code>max_pages</code>: The maximum number of pages to request. Defaults to requesting all pages in a query.</li> <li><code>fields</code>: The keys for the fields to include in the response. Usually they are the field name in lower case.</li> <li><code>sort</code>: The key(s) for the field(s) to order the response results by.</li> <li><code>include</code>: Additional linked resources to include in the response.</li> <li><code>updated_since</code>: Only return items that have been updated since this timestamp.</li> </ul> <p>For more information on the behavior of each of these parameters, see the Fount API docs.</p>"},{"location":"usage/advanced/#raw-parameter-dictionary","title":"Raw parameter dictionary","text":"<p>The <code>to_params</code> method can be used to parse the parameters into a dictionary of what will be sent to the Fount API:</p> <pre><code>&gt;&gt;&gt; bavapi.Query(\n...     filters=BrandscapeFilters(\n...         brand_name=\"Facebook\",\n...         year_numbers=[2012, 2013, 2014, 2015]\n...     ),\n...     include=[\"company\"]\n... ).to_params(endpoint=\"brandscape-data\")\n{\n\"include[brandscape-data]\": \"company\",  # (1)\n\"filter[brand_name]\": \"Facebook\",\n\"year_numbers\": \"2012,2013,2014,2015\",\n}\n</code></pre> <ol> <li> Parses <code>filters</code> and <code>include</code> into the correct format for the Fount API, and parses all elements in lists of parameters to their string representation.</li> </ol>"},{"location":"usage/basic/","title":"Basic usage","text":"<p>Once you have installed <code>bavapi</code> and acquired a token from the Fount, you can start using <code>bavapi</code> directly in Python or in a Jupyter Notebook.</p> <pre><code>import bavapi\n</code></pre>"},{"location":"usage/basic/#using-bavapi","title":"Using bavapi","text":"<p>SSL Issues</p> <p>It's possible that you get <code>SSL: CERTIFICATE_VERIFY_FAILED</code> errors when performing requests with <code>bavapi</code>. At the moment, it is not clear to what might be the source of the issue; as it only happens sometimes, and the error doesn't appear to happen with other tested URLs.</p> <p>Usually, making the request again solves the issue, but you might have to do so a couple of times if the issue persists.</p> <p> If you have any thoughts on how to solve this, please open an issue on GitHub.</p> <p>You can query the available endpoints with their corresponding methods:</p> <pre><code>swatch = bavapi.brands(\"TOKEN\", name=\"Swatch\")  # (1)\n</code></pre> <ol> <li> Replace <code>TOKEN</code> with your API key</li> </ol> <p>These endpoints methods will return a pandas DataFrame containing the data retrieved for your query:</p> id name ... 0 2342 Swatch ... 1 127896 Swatch ... ... ... ... ... <p>You can make requests to other endpoints in the same way:</p> <pre><code>uk_studies = bavapi.studies(\"TOKEN\", country_code=\"GB\")\nuk22 = bavapi.brandscape_data(\"TOKEN\", year_numbers=2022, country_code=\"GB\", audiences=1)\nall_adults = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre> <p>Want to use other endpoints?</p> <p>The BAV API is very extensive, so not all endpoints are fully implemented yet.</p> <p>See the Other endpoints section in Advanced Usage.</p>"},{"location":"usage/basic/#filtering-responses","title":"Filtering responses","text":"<p>In order to validate the request parameters before sending a bad request, <code>bavapi</code> will automatically check that the parameters from your query and filters are of the type expected by the Fount API. If any parameter doesn't conform to the API requirements, <code>bavapi</code> will raise a <code>ValidationError</code>.</p> <p>What it's doing</p> <p><code>bavapi</code> performs an initial request to make sure the query parameters are valid, and to retrieve information about the number of pages it will need to fetch.</p> <p>If the initial request fails, <code>bavapi</code> will not perform more requests.</p> <p>Similarly, if the initial request returns the entirety of the query (e.g., there are only 10 results and <code>per_page</code> is above 10, which it is by default), no further requests will be performed, and instead the data from the initial response will be returned.</p> <p>Each endpoint has a filter class associated with it, as each endpoint has its own filter requirements:</p> Endpoint Filters class <code>\"audiences\"</code> <code>AudiencesFilters</code> <code>\"brands\"</code> <code>BrandsFilters</code> <code>\"brandscape-data\"</code> <code>BrandscapeFilters</code> <code>\"studies\"</code> <code>StudiesFilters</code> <p>Warning</p> <p>Using a filters class not meant for a specific endpoint will raise a <code>ValueError</code>.</p> <p>However, using a dictionary instead (as seen in the instructions below) won't raise errors if the dictionary doesn't match the expected filter types. Use the dictionary method with caution.</p> <p>These classes are available in the <code>bavapi.filters</code> module.</p> <p>Some of the more common filters for each endpoint have been added directly to the <code>bavapi</code> functions.</p> <p>Example</p> <p><code>bavapi.brands</code> has parameters such as <code>name</code>, <code>country_codes</code>, <code>year_numbers</code>, <code>brand_id</code> or <code>studies</code>, which you can use directly from the function without creating a filters instance.</p> <p>However, less commonly used filters, as well as value filters must be specified by using the <code>filters</code> parameters in each function.</p> <p>Filters can be specified using a Python dictionary (if you know the name of the filters you need), or directly creating a Filters instance:</p> Filters instances (recommended)Dictionary <pre><code>result = bavapi.brands(\nfilters=BrandsFilters(name=\"Swatch\", country_codes=[\"US\", \"UK\"])\n)\n</code></pre> <pre><code>result = bavapi.brands(\nfilters={\"name\":\"Swatch\", \"country_codes\":[\"US\", \"UK\"]}\n)\n</code></pre> <p>Warning</p> <p>If both regular function parameters and filters are specified, the values in the filters parameter will take precedence for the actual request:</p> <pre><code>result = bavapi.brands(name=\"Swatch\", filters={\"name\": \"Facebook\"})\n</code></pre> <p>The request will use <code>name=\"Facebook\"</code>, because values specified in the <code>filters</code> parameter take precedence.</p>"},{"location":"usage/basic/#value-filters","title":"Value filters","text":"<p>\"Value\" filters refer to filtering on the values of the data returned by the endpoint, as opposed to filtering via query parameters specified in the Fount API documentation. For example, filtering by category name or by sector in the <code>brandscape-data</code> endpoint.</p> <p>These value filters must be specified in the <code>filters</code> parameter. If they are added to the function call as regular keyword arguments, a <code>ValidationError</code> will be raised.</p> <pre><code>bavapi.brands(name=\"Swatch\", filters={\"sector_name\": \"Watches\"})  # ok\nbavapi.brands(name=\"Swatch\", sector_name=\"Watches\")  # raises ValidationError\n</code></pre> <p>When using additional value filters, which might not be available in the arguments to the function call, it is recommended to use the <code>filters</code> parameter instead of mixing function parameters and Filters parameters:</p> <pre><code>bavapi.brands(filters=BrandsFilters(name=\"Swatch\", sector_name=\"Watches\"))\n</code></pre>"},{"location":"usage/basic/#using-reference-classes","title":"Using Reference classes","text":"<p><code>bavapi</code> provides reference classes to make API queries easier to construct.</p> <p>These reference classes must be generated on your machine after installation. Please follow the instructions in the Installation section.</p> <p>The following reference classes are available:</p> <ul> <li><code>Audiences</code>: Audience IDs for all available Fount audiences.</li> <li><code>Countries</code>: Country IDs for all available Fount countries.</li> </ul> <p>They make it easier to use these filters, which require Fount IDs to work:</p> <pre><code>uk22 = bavapi.brandscape_data(\n\"TOKEN\",\ncountries=Countries.UNITED_KINGDOM,\naudiences=Audiences.ALL_ADULTS,\n)\n</code></pre>"},{"location":"usage/basic/#other-query-parameters","title":"Other query parameters","text":""},{"location":"usage/basic/#fields","title":"Fields","text":"<p>Read more in the API documentation</p> <p>It is possible to specify which fields a response should contain. If so, the API will only return those fields.</p> <pre><code>result = bavapi.brands(name=\"Swatch\", fields=[\"id\", \"name\"])\nresult.columns  # will only have [\"id\", \"name\"] as columns\n</code></pre>"},{"location":"usage/basic/#sorting","title":"Sorting","text":"<p>Read more in the API documentation</p> <p>It is possible to sort the data by a column from the response.</p> <pre><code># sorted by name\nresult = bavapi.brands(name=\"Swatch\", sort=\"name\")\n# descending sorted by name (note the '-')\nresult = bavapi.brands(name=\"Swatch\", sort=\"-name\")\n</code></pre> <p>Responses are sorted by item id, in ascending order, by default.</p>"},{"location":"usage/basic/#related-data-includes","title":"Related data (includes)","text":"<p>Read more in the API documentation</p> <p>Aside from the data directly available for each of the resources in the Fount, these resources can also be connected across endpoints.</p> <p>Example</p> <p>From the <code>brands</code> endpoint, you can request info about a brand's <code>company</code>, <code>sector</code> or <code>studies</code>, among others.</p> <p>Each endpoint supports different <code>includes</code> fields. Please read the Fount API documentation for more info on the specific set of includes supported by each endpoint.</p> <pre><code># will include info about the brand's company\nresult = bavapi.brands(name=\"Swatch\", includes=\"company\")\n</code></pre> <p>Default <code>includes</code></p> <p>The <code>brandscape_data</code> function includes <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code> by default, to align functionality with other sources of data like the Fount website and the Cultural Rank Tool.</p>"},{"location":"usage/basic/#pagination","title":"Pagination","text":"<p>All requests to the Fount are \"paginated\", meaning that one must request and receive from the server one page at a time. <code>bavapi</code> then combines all responses into one data table.</p> <p>While the default value for <code>bavapi</code> is 100, it is possible to set a custom number of <code>per_page</code> elements for each request:</p> <pre><code># will send requests for the specified number of elements.\nresult = bavapi.brands(name=\"Swatch\", per_page=1000)\n</code></pre> <p>Info</p> <p>The maximum number of elements per page allowed by the Fount API is <code>1000</code>.</p> <p>You can also set a custom number of <code>max_pages</code> for the request, or directly specify the <code>page</code> parameter to get a single page of results.</p>"},{"location":"usage/basic/#metric-keys","title":"Metric keys","text":"<p><code>metric_keys</code> is a special filter to specify the data columns that the response should contain.</p> <p>The API response will include all score types for that metric.</p> <p>Note</p> <p>Currently, only the <code>brandscape-data</code> endpoint supports the use of metric keys. All other endpoints will ignore this parameter.</p> <p>More info in the <code>brandscape-data</code> endpoint section.</p>"},{"location":"usage/basic/#formatting-output","title":"Formatting output","text":"<p>It is possible that some of the data retrieved from the Fount includes multiple items.</p> <p>Example</p> <p>For example, requesting the <code>studies</code> include in <code>bavapi.brands</code> will return a column containing lists of dictionaries with study info for all studies that a brand appears in.</p> id name studies 0 24353 Facebook [{'id': 254, 'name': 'Argentin...}] ... ... ... ... <p><code>bavapi</code> has a <code>stack_data</code> parameter in its functions and methods that will take those lists of dictionaries and recursively generate a new entry (row) in the resulting DataFrame for each element in the list.</p> <pre><code>bavapi.brands(\"Facebook\", include=\"studies\", stack_data=True)\n</code></pre> id name studies_id studies_name ... 0 24353 Facebook 254 Argentina - Adults 2011 ... 1 24353 Facebook 787 Argentina - Adults 2012 ... ... ... ... ... ... ..."},{"location":"usage/basic/#datetime-in-fount-responses","title":"Datetime in Fount responses","text":"<p>Parsing of datetime values in Fount responses is not currently supported, though it is a planned feature.</p> <p>For now, parse datetime values manually using <code>pandas</code> instead.</p> <p>Tip</p> <p>The functions shown in the \"Basic usage\" section are meant for easy use in Jupyter notebooks, experimentation, one-off scripts, etc.</p> <p>For more advanced uses and significant performance benefits, see Advanced Usage next.</p>"}]}