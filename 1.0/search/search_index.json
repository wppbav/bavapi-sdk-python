{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BAV API Python SDK - <code>bavapi</code> documentation","text":"<p>WPPBAV provides a python consumer for the WPPBAV Fount API.</p> <p>It is published as <code>wpp-bavapi</code> in PyPI and hosted on GitHub.</p> <p>With <code>bavapi</code> you can access the full BAV data catalog, the largest and most comprehensive database of brand data in the world.</p> <p>Queries are validated automatically thanks to <code>pydantic</code> and retrieved asynchronously via the <code>httpx</code> package.</p> <p>For more information about the Fount API, see the API documentation website.</p>"},{"location":"#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p><code>bavapi</code> should work with any Python installation above version 3.8.</p> <p>Install <code>bavapi</code> using pip:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>See Installation for more detailed instructions.</p>"},{"location":"#example-usage","title":"Example usage","text":"<p>Protected access</p> <p> To use <code>bavapi</code>, you will need a Fount API token. Read more in the Authentication section.</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; result = bavapi.brands(\"TOKEN\", name=\"Swatch\") # (1)\n&gt;&gt;&gt; result\n</code></pre> <ol> <li> Replace <code>\"TOKEN\"</code> with your Fount API token.</li> </ol> sector_id sector_name id name ... 0 233 Apparel &amp; Accessories 8635 Swatch ... ... ... ... ... ... ..."},{"location":"#features","title":"Features","text":"<ul> <li>Support for all endpoints in the Fount API.<ul> <li>Extended support for the following endpoints:<ul> <li><code>audiences</code></li> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>brands</code></li> <li><code>brandscape-data</code></li> <li><code>categories</code></li> <li><code>cities</code></li> <li><code>collections</code></li> <li><code>companies</code></li> <li><code>countries</code></li> <li><code>sectors</code></li> <li><code>studies</code></li> <li><code>years</code></li> </ul> </li> <li>Other endpoints are available via the <code>raw_query</code> functions and methods.</li> </ul> </li> <li>Validates query parameters are of the correct types and provides type hints for better IDE support.</li> <li>Retrieve multiple pages of data simultaneously, monitoring and preventing exceeding API rate limit.</li> <li>Both synchronous and asynchronous APIs for accessing BAV data.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>To start using <code>bavapi</code>, go to the Getting Started section.</p> <p>After going through the \"Getting Started\" section, please see Basic Usage.</p> <p>For more advanced topics, see the Advanced Usage section.</p> <p>Each Fount API endpoint may behave slightly differently. You can find detailed explanations in the Endpoints section.</p> <p>You can also find a detailed SDK reference in the Code Reference section.</p>"},{"location":"#issues","title":"Issues","text":"<p>For bug reports and feature requests, please open an issue on GitHub.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute to <code>bavapi</code>, please read the Contributing section of the documentation.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-bavapi","title":"Contributing to <code>bavapi</code>","text":"<p><code>bavapi</code> is an open source library provided by WPPBAV, and we're happy to accept contributions from the community.</p> <p>In order to keep a high level of quality and accessibility for our users, there are certain code style and testing requirements that we ask to accept your contributions.</p> <p><code>bavapi</code> uses <code>nox</code> to run development scripts.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>The easiest way to contribute when you see something wrong is to open an issue on GitHub. You can do so here.</p> <p>Please read the instructions in the issue template and fill out as much information as possible.</p> <p>This should be your first stop to start contributing to <code>bavapi</code>. We kindly ask that you let us know if you would like to contribute any changes to the code base by opening an issue on GitHub.</p> <p>Please return to this page once you have opened an issue on GitHub and are ready to start contributing.</p>"},{"location":"contributing/#cloning-bavapi-repository","title":"Cloning <code>bavapi</code> repository","text":"<p>In order to make sure you work on the latest version of <code>bavapi</code>, please fork the GitHub repository into your account and clone your fork of <code>bavapi</code> into your machine:</p> <pre><code>git clone https://github.com/{your-username}/bavapi-sdk-python\n</code></pre> <p>Once cloned, enter the newly created directory, create a virtual environment and install all optional dependencies in edit mode:</p> <pre><code>pip install -e .[dev, doc, test, lint]\n</code></pre> <p>This will install all optional dependencies which are necessary for contributing to the code base.</p>"},{"location":"contributing/#bav-api-key","title":"BAV API Key","text":"<p>You will need a BAV API key to perform requests to the API through <code>bavapi</code>.</p> <p>To get and use an API key, see the Authentication section of the Getting Started guide.</p> <p>In order to run integration tests and the <code>bavapi-gen-refs</code> command, you will need to use an <code>.env</code> file to store your BAV API key as <code>BAV_API_KEY</code> (you can also set the environment variable directly). See the instructions for more details.</p>"},{"location":"contributing/#tools-and-frameworks","title":"Tools and frameworks","text":"<p><code>bavapi</code> uses the following frameworks for development:</p> <ul> <li>Fully type-hinted and tested with <code>mypy</code>.</li> <li>Unit and integration tests using <code>pytest</code>.</li> <li>Full test coverage using <code>coverage</code>.</li> <li>Run development scripts in multiple Python versions with <code>nox</code>.</li> <li>Documentation using <code>mkdocs-material</code>.</li> <li>Code auto-formatting with <code>black</code>.</li> <li>Linting with <code>pylint</code>.</li> </ul> <p>Please familiarize yourself with using these libraries in order to get started with contributing to <code>bavapi</code>.</p>"},{"location":"contributing/#developing-in-windows","title":"Developing in Windows","text":"<p>It is highly recommended that you use <code>mamba</code> to manage Python environments in Windows. It is a faster implementation of <code>conda</code> and testing of <code>bavapi</code> on multiple versions of Python is set up to use <code>mamba</code> on Windows.</p> <p>Once you have <code>mamba</code> installed in your system, and you have set up an environment with <code>nox</code>, you should be able to run the <code>nox</code> commands for <code>bavapi</code>.</p>"},{"location":"contributing/#nox-commands","title":"Nox commands","text":"<p>To run <code>nox</code> commands, run the following command in your terminal:</p> <pre><code>nox -s {command_name}\n</code></pre>"},{"location":"contributing/#available-nox-commands","title":"Available <code>nox</code> commands","text":"<p>To see a list of all available <code>nox</code> commands, run <code>nox -l</code> in your terminal. Here is a quick summary:</p> <ul> <li><code>tests</code> and <code>tests_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information. Suitable for CI/CD pipeline and for Linux (would require <code>pyenv</code> to manage Python versions).</li> <li><code>tests_mamba</code> and <code>tests_mamba_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information, using <code>mamba</code> to run multiple versions of Python. Suitable for local testing on Windows.</li> <li>The commands above, ending with <code>_nocov</code>: run <code>pytest</code> unit (or end-to-end) tests without collecting <code>coverage</code> information.</li> <li><code>coverage</code>: combine and report coverage results.</li> <li><code>build</code>: build distributable files for <code>bavapi</code>. Suitable for CI/CD pipeline.</li> <li><code>docs_deploy</code>: publish <code>bavapi</code> documentation to GitHub Pages. Suitable for local development and CI/CD pipelines.</li> <li><code>docs_serve</code>: serve <code>bavapi</code> documentation with <code>mike</code>. Suitable for local development.</li> <li><code>docs_build_and_serve</code>: run both <code>docs_deploy</code> and <code>docs_serve</code>. Suitable for local development.</li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":"<p><code>bavapi</code> supports Python 3.8 and above, so your code should be able to run in all the latest versions of python.</p> <ol> <li>Run <code>black bavapi</code> after writing or modifying code. This way the code style of the whole project will remain consistent.</li> <li>Run <code>mypy bavapi</code> after writing or modifying code to make sure type hints are correctly defined.</li> <li>Fully test your code using <code>pytest</code> and make sure you covered all your changes in the repository by running all <code>tests_mamba</code>, <code>tests_mamba_e2e</code> and <code>coverage</code> sessions from <code>nox</code>.</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>If your contribution changes the functionality of the library, you will need to update the documentation.</p> <p><code>mkdocs-material</code> will automatically generate documentation for your code by parsing docstrings with <code>mkdocstrings</code>. Please make sure that the docstrings in your code follow the <code>numpydoc</code> standard.</p> <p>If your contribution changes the basic or advanced functionality of the library, or changes how the library is installed, please update those sections of the documentation.</p> <p>Each fully implemented endpoint should have a corresponding documentation page in the <code>endpoints</code> folder. Please follow the same structure as other endpoint pages for consistency.</p>"},{"location":"contributing/#cicd","title":"CI/CD","text":"<p><code>bavapi</code> has a CI/CD pipeline set up that checks for testing and coverage. All code must be tested and will fail integration if test coverage is not 100%.</p> <p>One way to ensure success is to run the three testing commands mentioned above. You can copy/paste the following command for convenience:</p> <pre><code>nox -s tests_mamba &amp;&amp; nox -s tests_mamba_e2e &amp;&amp; nox -s coverage\n</code></pre>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>In order to integrate changes into <code>bavapi</code>, you must create a pull request on GitHub.</p> <p>Please follow the instructions in the pull request template and fill out as much information as possible.</p> <p>GitHub actions will automatically run tests on the pull request content.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#10","title":"<code>1.0</code>","text":""},{"location":"release-notes/#103-2024-02-09","title":"<code>1.0.3</code> (2024-02-09)","text":""},{"location":"release-notes/#fix","title":"Fix","text":"<ul> <li> Fix bug in custom dtype conversion within the response parsing logic.</li> </ul>"},{"location":"release-notes/#102-2024-02-08","title":"<code>1.0.2</code> (2024-02-08)","text":""},{"location":"release-notes/#fix_1","title":"Fix","text":"<ul> <li> Fix deprecation warning when parsing responses into dataframes with <code>pandas&gt;=2.2</code>.</li> </ul>"},{"location":"release-notes/#docs","title":"Docs","text":"<ul> <li> Add ability to copy code blocks from the documentation.</li> </ul>"},{"location":"release-notes/#test","title":"Test","text":"<ul> <li> Added tests for correct dtype conversions.</li> </ul>"},{"location":"release-notes/#internal","title":"Internal","text":"<ul> <li> Cleaned up unused and ignored logging for development scripts.</li> </ul>"},{"location":"release-notes/#101-2024-01-19","title":"<code>1.0.1</code> (2024-01-19)","text":""},{"location":"release-notes/#fix_2","title":"Fix","text":"<ul> <li> Fixed typo in <code>sectors</code> (previously spelled <code>sector</code>) parameter for <code>categories</code> endpoint queries.</li> </ul>"},{"location":"release-notes/#docs_1","title":"Docs","text":"<ul> <li> Fixed docs update script to execute only when the <code>CONTRIBUTING.md</code> file changes.</li> <li> Fixed version numbers to only have <code>major.minor</code> format in docs.</li> <li> Fix external library/package links.</li> <li> Fix missing <code>name</code> parameter from various endpoint documentation pages.</li> </ul>"},{"location":"release-notes/#internal_1","title":"Internal","text":"<ul> <li> Cleaned up docs sessions in <code>nox</code> file, now will only use <code>mkdocs serve</code> for local development.</li> </ul>"},{"location":"release-notes/#100-2024-01-04","title":"<code>1.0.0</code> (2024-01-04)","text":""},{"location":"release-notes/#feature","title":"Feature","text":"<ul> <li> Added five new endpoints to <code>bavapi</code> with accompanying <code>FountFilters</code> classes:<ul> <li><code>cities</code></li> <li><code>companies</code></li> <li><code>countries</code></li> <li><code>regions</code></li> <li><code>years</code></li> </ul> </li> </ul>"},{"location":"release-notes/#changes","title":"Changes","text":"<ul> <li> Initial handshake API request will now be retried on SSL errors.</li> </ul>"},{"location":"release-notes/#docs_2","title":"Docs","text":"<ul> <li> Reordered some sections in the Basic usage and Advanced usage sections of the documentation.</li> <li> Updated and standardized Jupyter notebook demo.</li> <li> Clarified when a query is considered to be a single-page query in the <code>bavapi.Query.is_single_page</code> docstring.</li> <li> Fixed some minor errors in <code>bavapi.Client</code> method docstrings.</li> <li> Added examples of the batch logic in the Jupyter demo notebook.</li> <li> Repurposed the getting started section on reference classes as the primary documentation page for the references functionality, rather than keeping a section in Basic usage.</li> <li> Changed Release notes dates to ISO-8601 format.</li> </ul>"},{"location":"release-notes/#internal_2","title":"Internal","text":"<ul> <li> Cleaned up and added comments to documentation scripts.</li> <li> Removed <code>tqdm</code> as a dependency from the batching logic.</li> <li> Added comments to <code>nox</code> session for deploying the docs.</li> <li> Simplified some logic in <code>Query.ensure</code>.</li> <li> Added support for specifying exceptions to retry on for <code>aretry</code> internal function.</li> </ul>"},{"location":"release-notes/#ci","title":"CI","text":"<ul> <li> CI won't run unless a package or test file is changed, or the CI action file is changed.</li> <li> Added manual trigger to documentation so deploying fixes to the docs doesn't require a version change.</li> </ul>"},{"location":"release-notes/#013","title":"<code>0.13</code>","text":""},{"location":"release-notes/#0130-2023-12-11","title":"<code>0.13.0</code> (2023-12-11)","text":"<p>This version of <code>bavapi</code> is expected to be the last beta version before a release candidate.</p>"},{"location":"release-notes/#feature_1","title":"Feature","text":"<ul> <li> <code>bavapi</code> will now retry page requests upon failure. You can control the number of retry attempts with the <code>retries</code> parameter in top-level functions and the <code>Client</code> interface.</li> <li> It is now possible to control the behavior of errors in the request process. If <code>on_errors</code> is set to <code>\"warn\"</code> (default), successful requests will be returned and a warning will be issued detailing which pages resulted in errors and each exception associated with it. If <code>on_errors</code> is set to <code>\"raise\"</code> (old behavior) instead, an exception will be raised as soon as any request fails.</li> <li> Added <code>bav_study</code> and <code>released</code> filters to <code>studies</code> endpoint function and method.</li> </ul>"},{"location":"release-notes/#changes_1","title":"Changes","text":"<ul> <li> Reduced the size of the initial request to 1 item if a paginated request is detected for improved performance.</li> <li> Paginated requests are now performed in batches instead of starting every request from the start. This should mitigate several issues (like SSL errors) with large queries and improve overall run times. You can control this behavior through the <code>batch_size</code> and <code>n_workers</code> parameters in top-level functions and the <code>Client</code> interface.</li> <li> Instead of having failed requests immediately raise exceptions, <code>bavapi</code> will continue downloading pages, collect successful responses, and warn the user about the pages that failed to be collected. This can be controlled by the <code>on_errors</code> parameter in top-level functions and the <code>Client</code> interface.</li> <li> Using <code>bavapi.Query</code> instances in request functions and methods will now combine method parameters with parameters in the query object. Parameters specified in the query object will take precedence over parameters specified in the function or method. Filter values in the method parameters will be ignored if the query object contains filters.</li> </ul>"},{"location":"release-notes/#fix_3","title":"Fix","text":"<ul> <li> Refactored the expanding step of the result parsing pipeline to fix undefined behavior when multiple expandable columns are found in the result.</li> </ul>"},{"location":"release-notes/#internal_3","title":"Internal","text":"<ul> <li> Removed trailing whitespaces</li> <li> New data fetching algorithm based on asynchronous workers.</li> <li> Fixed unmatched checkout action versions in <code>ci</code>.</li> <li> Refactored filter consolidation logic to avoid unnecessary copies of parameters.</li> </ul>"},{"location":"release-notes/#docs_3","title":"Docs","text":"<ul> <li> Added clarification about prefixed column names in <code>brandscape-data</code> endpoint results.</li> <li> Various improvements to documentation, focused on warnings/tips and code snippets.</li> </ul>"},{"location":"release-notes/#test_1","title":"Test","text":"<ul> <li> Added tests for new <code>_batched</code> and <code>_fetcher</code> modules.</li> <li> Added new test case for <code>parsing.responses</code> to test correct behavior with multiple expandable columns in the response.</li> <li> Added new tests for query consolidation logic.</li> <li> Fixed <code>HTTPClient</code> tests to work with new architecture.</li> <li> Simplified integration tests thanks to the new retry functionality</li> </ul>"},{"location":"release-notes/#012","title":"<code>0.12</code>","text":""},{"location":"release-notes/#0121-2023-11-21","title":"<code>0.12.1</code> (2023-11-21)","text":""},{"location":"release-notes/#fix_4","title":"Fix","text":"<ul> <li> Incorrect <code>datetime</code> format used when formatting string values.</li> <li> Removed unused testing helper code that could lead to recursion errors.</li> </ul>"},{"location":"release-notes/#internal_4","title":"Internal","text":"<ul> <li> Removed unnecessary development flags for coverage and typing.</li> </ul>"},{"location":"release-notes/#tests","title":"Tests","text":"<ul> <li> Add tests for all arguments in <code>bavapi-gen-refs</code> argument parser.</li> </ul>"},{"location":"release-notes/#typing","title":"Typing","text":"<ul> <li> Improved typing of <code>generate_references</code> and <code>sync</code> modules.</li> </ul>"},{"location":"release-notes/#docs_4","title":"Docs","text":"<ul> <li> Fixed incorrect warning about mixing filters and endpoints.</li> <li> Normalized docstring default definitions to follow <code>numpydoc</code> spec.</li> </ul>"},{"location":"release-notes/#0120-2023-11-15","title":"<code>0.12.0</code> (2023-11-15)","text":""},{"location":"release-notes/#feature_2","title":"Feature","text":"<ul> <li> Added support for <code>metric_group_keys</code>, for use with the <code>brandscape-data</code> endpoint.</li> <li> It is now possible to use <code>page</code> as the start page of a paginated request. Use <code>per_page</code> and/or <code>max_pages</code> to change the behavior of the pagination. More info in the Basic Usage section.</li> <li> As a result of the new paginated behavior, it is now possible to chunk requests by setting the start and end of the request with <code>page</code> and <code>per_page</code>, respectively. See more info in the Project tips section of the documentation.</li> </ul>"},{"location":"release-notes/#changes_2","title":"Changes","text":"<ul> <li> Exceptions <code>DataNotFoundError</code> and <code>RateLimitExceededError</code> are now subclasses of <code>APIError</code>.</li> <li> Refactored pagination logic to allow for control over the start and end of the paginated request to the Fount. Shouldn't break existing uses of <code>page</code> unless <code>per_page</code> and/or <code>max_pages</code> were also in use. More info in the Basic Usage section.</li> <li> <code>Query.with_page</code> parameters are now optional and default to <code>None</code>.</li> <li> <code>Query</code> attributes <code>page</code>, <code>per_page</code>, and <code>max_pages</code> must be greater than <code>0</code>.</li> <li> (BREAKING) <code>Query.paginated</code> parameter order has changed to make <code>per_page</code> optional.</li> </ul>"},{"location":"release-notes/#fix_5","title":"Fix","text":"<ul> <li> Various issues and inconsistencies with pagination logic.</li> <li> Fixed <code>per_page</code> not applying to single page results.</li> </ul>"},{"location":"release-notes/#docs_5","title":"Docs","text":"<ul> <li> Added instructions for performing batched requests in the Project Tips section.</li> </ul>"},{"location":"release-notes/#011","title":"<code>0.11</code>","text":""},{"location":"release-notes/#0110-2023-09-27","title":"<code>0.11.0</code> (2023-09-27)","text":"<p>In preparation for a stable release of <code>bavapi</code>, some aspects of the endpoint function/method interface have been normalized across the library.</p> <p>This means that all endpoints now support a <code>query</code> parameter directly, to allow for better reproducibility and parametrization of queries. <code>raw_query</code> now also uses <code>query</code> instead of <code>params</code>, with <code>query</code> being required unlike with other endpoints.</p> <p>Another change is that the order of parameters has been altered. The main reason for this is that parameters like <code>brand_id</code> were positional parameters before, when they are exclusive with almost all othe r parameters. This was also the case for parameters like <code>studies</code>, which are exclusive with <code>country_codes</code> and <code>year_numbers</code>. Now <code>{endpoint}_id</code> parameters and other exclusive or niche filters have been turned to keyword-only parameters. Filters like <code>inactive</code> and <code>not_in_most_influential</code> have been removed from endpoint functions. Use the <code>filters</code> parameter instead. See each endpoint documentation page for more information.</p>"},{"location":"release-notes/#feature_3","title":"Feature","text":"<ul> <li> It is now possible to pass a <code>bavapi.Query</code> object to all endpoint functions and methods with the <code>query</code> parameter. If <code>query</code> is used, all the parameters that would be used in the query (listed before <code>query</code> in each endpoint documentation) will be ignored.</li> <li> It is now possible to specify a destination folder for the <code>bavapi-gen-refs</code> command with the <code>-d</code>/<code>--dest-folder</code> argument.</li> <li> Reference classes generated via <code>bavapi-gen-refs</code> can now be imported with <code>from bavapi_refs import Countries</code> for example.</li> </ul>"},{"location":"release-notes/#changes_3","title":"Changes","text":"<ul> <li> (BREAKING) Changed <code>raw_query</code> <code>params</code> parameter name to <code>query</code> to match all other endpoints.</li> <li> (BREAKING) Changed the order of several endpoint parameters for more effective queries. Now, each endpoint function has a set of parameters that can be set as positional arguments for exploratory filtering, while niche filters and IDs have become keyword only parameters.<ul> <li><code>audiences</code>:<ul> <li>Positional filters: <code>name</code>, <code>active</code>, <code>public</code></li> <li>Keyword filters: <code>audience_id</code>, <code>private</code>, <code>groups</code></li> </ul> </li> <li><code>brand_metrics</code>:<ul> <li>Positional filters: <code>name</code>, <code>active</code>, <code>public</code></li> <li>Keyword filters: <code>metric_id</code>, <code>private</code>, <code>groups</code></li> </ul> </li> <li><code>brand_metric_groups</code>:<ul> <li>Positional filters: <code>name</code>, <code>active</code></li> <li>Keyword filters: <code>group_id</code></li> </ul> </li> <li><code>brands</code>:<ul> <li>Positional filters: <code>name</code>, <code>country_codes</code>, <code>year_numbers</code></li> <li>Keyword filters: <code>brand_id</code>, <code>studies</code></li> </ul> </li> <li><code>brandscape_data</code>:<ul> <li>Positional filters: <code>country_code</code>, <code>year_number</code>, <code>audiences</code>, <code>brand_name</code></li> <li>Keyword filters: <code>studies</code></li> </ul> </li> <li><code>categories</code>:<ul> <li>Positional filters: <code>name</code>, <code>sector</code></li> <li>Keyword filters: <code>category_id</code></li> </ul> </li> <li><code>collections</code>:<ul> <li>Positional filters: <code>name</code>, <code>public</code></li> <li>Keyword filters: <code>collection_id</code>, <code>shared_with_me</code>, <code>mine</code></li> </ul> </li> <li><code>sectors</code>:<ul> <li>Positional filters: <code>name</code>, <code>in_most_influential</code></li> <li>Keyword filters: <code>sector_id</code></li> </ul> </li> <li><code>studies</code>:<ul> <li>Positional filters: <code>country_codes</code>, <code>year_numbers</code>, <code>full_year</code></li> <li>Keyword filters: <code>study_id</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"release-notes/#error-messages","title":"Error Messages","text":"<ul> <li> Improved error message for <code>bavapi-gen-refs</code> command when neither <code>-a</code>/<code>--all</code> nor <code>-n</code>/<code>--name</code> arguments aren't used.</li> </ul>"},{"location":"release-notes/#fix_6","title":"Fix","text":"<ul> <li> Fixed that requests with <code>item_id</code> would ignore other query parameters.</li> <li> Addressed undefined behavior when <code>max_pages</code> is larger than the total number of pages as reported by the API. Now the max number of pages is always capped by the reported total.</li> </ul>"},{"location":"release-notes/#internal_5","title":"Internal","text":"<ul> <li> Fixed typing of <code>tuple</code> internal <code>docs_deploy</code> function annotations not being compatible with Python <code>&lt;3.9</code>.</li> <li> Removed slow and unnecessary test for the <code>verbose</code> parameter in <code>HTTPClient</code>.</li> <li> Refactored tests that instantiate <code>httpx.AsyncClient</code> instances for a 20x reduction in test run time.</li> </ul>"},{"location":"release-notes/#docs_6","title":"Docs","text":"<ul> <li> Filter classes table in Basic usage page now points to each endpoint function docs.</li> <li> Automatically add comment to <code>docs/contributing.md</code> to edit <code>./CONTRIBUTING.md</code> instead.</li> <li> Updated Jupyter notebook demo with latest features and conventions.</li> <li> Documented the use of <code>bavapi.Query</code> object in functions and methods.</li> <li> Improved code example for the Using reference classes section of the Basic usage page.</li> <li> Clarified which endpoint filters are positional and keyword-only in respective endpoint documentation pages</li> <li> Fixed incorrect rendering of tabs in the Suppressing progess bar section of the Basic usage page.</li> <li> Removed <code>datetime</code> formatting section from the Basic usage page.</li> </ul>"},{"location":"release-notes/#010","title":"<code>0.10</code>","text":""},{"location":"release-notes/#0101-2023-10-17","title":"<code>0.10.1</code> (2023-10-17)","text":""},{"location":"release-notes/#fix_7","title":"Fix","text":"<ul> <li> (Breaking) Fix <code>metric_id</code> param to correct <code>group_id</code> name in <code>bavapi.brand_metric_groups</code> top level function.</li> </ul>"},{"location":"release-notes/#internal_6","title":"Internal","text":"<ul> <li> Renamed <code>reference</code> module as private. This will remove it from the code reference docs.</li> <li> Set new dependency minimum versions for compatibility.</li> </ul>"},{"location":"release-notes/#docs_7","title":"Docs","text":"<ul> <li> Code reference section now directs to the <code>sync</code> documentation by default.</li> <li> Added all available filters to the summary table in the Basic Usage section.</li> <li> More documentation for the <code>sync</code> and <code>client</code> modules.</li> <li> Added more clarity around expected environment variables when storing API keys. <code>bavapi</code> will always look for an API key in the <code>BAV_API_KEY</code> environment variable.</li> <li> Refactored code reference generation to support renaming of <code>reference</code> module.</li> </ul>"},{"location":"release-notes/#0100-2023-10-16","title":"<code>0.10.0</code> (2023-10-16)","text":""},{"location":"release-notes/#feature_4","title":"Feature","text":"<ul> <li> The following endpoints have been fully implmented with type hints and validation:<ul> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>categories</code></li> <li><code>collections</code></li> <li><code>sectors</code></li> </ul> </li> </ul>"},{"location":"release-notes/#docs_8","title":"Docs","text":"<ul> <li> Documentation for newly supported endpoints.</li> <li> Documented the use of <code>\"no_default\"</code> as the <code>include</code> value for <code>brandscape_data</code> and <code>categories</code> functions/methods.</li> </ul>"},{"location":"release-notes/#internal_7","title":"Internal","text":"<ul> <li> Generalized internal <code>_default_includes</code> function to be able to reuse it with the <code>categories</code> endpoint.</li> <li> <code>nox</code> session <code>docs_build_and_serve</code> will now rebase local branch if local version data is not synced with GitHub.</li> </ul>"},{"location":"release-notes/#09","title":"<code>0.9</code>","text":""},{"location":"release-notes/#090-2023-10-11","title":"<code>0.9.0</code> (2023-10-11)","text":""},{"location":"release-notes/#feature_5","title":"Feature","text":"<ul> <li> Official support for Python 3.12.</li> <li> Added ability to show/hide progress bar when making requests with the <code>verbose</code> parameter. This is available for all top-level endpoint functions and when creating an instance of <code>bavapi.Client</code>. To hide the progress bar, set <code>verbose</code> to <code>False</code> (by default <code>True</code>).</li> </ul>"},{"location":"release-notes/#docs_9","title":"Docs","text":"<ul> <li> Added a section to the Usage Tips page explaining how to retry failed requests when an SSL exception is raised.</li> <li> Fix absolute/relative documentation links in the GitHub <code>CONTRIBUTING.md</code> file and the synced docs version.</li> <li> Added documentation for changing the User Agent for HTTP requests.</li> <li> Fix incorrect code example in the <code>brandscape-data</code> endpoint page.</li> <li> Added explicit documentation about which filters are available in top-level functions and methods to all endpoint pages.</li> </ul>"},{"location":"release-notes/#internal_8","title":"Internal","text":"<ul> <li> Fix deprecation warning due to timezone-aware <code>datetime</code> usage when generating reference classes in Python 3.12.</li> </ul>"},{"location":"release-notes/#ci_1","title":"CI","text":"<ul> <li> Upgraded <code>nox</code> GitHub Action versions.</li> <li> Added Python 3.12 to GitHub Actions CI/testing.</li> </ul>"},{"location":"release-notes/#typing_1","title":"Typing","text":"<ul> <li> Enabled support for PEP 692 <code>TypedDict</code> kwargs via <code>Unpack</code> on all endpoint functions and methods.</li> </ul>"},{"location":"release-notes/#dependencies","title":"Dependencies","text":"<ul> <li> Updated minimum required version of <code>typing-extensions</code> for Python versions below 3.12.</li> </ul>"},{"location":"release-notes/#08","title":"<code>0.8</code>","text":""},{"location":"release-notes/#081-2023-09-29","title":"<code>0.8.1</code> (2023-09-29)","text":""},{"location":"release-notes/#performance","title":"Performance","text":"<ul> <li> Improved response parsing performance by ~4x (about 0.6 seconds faster per Fount query).</li> </ul>"},{"location":"release-notes/#fix_8","title":"Fix","text":"<ul> <li> Fix required filters in <code>brandscape_data</code> functions and methods.</li> <li> Remove buried print statement in response flattening logic.</li> </ul>"},{"location":"release-notes/#docs_10","title":"Docs","text":"<ul> <li> Fixed and clarified required filters in <code>brandscape_data</code> functions and methods.</li> </ul>"},{"location":"release-notes/#internal_9","title":"Internal","text":"<ul> <li> Renamed <code>jupyter</code> compatibility module as private. This will remove it from the code reference docs.</li> </ul>"},{"location":"release-notes/#080-2023-09-15","title":"<code>0.8.0</code> (2023-09-15)","text":""},{"location":"release-notes/#feature_6","title":"Feature","text":"<ul> <li> It is now possible to set a <code>timeout</code> parameter from top-level sync endpoint functions.</li> <li> It is now possible to set a <code>user_agent</code> parameter when creating a <code>bavapi.Client</code> instance.</li> </ul>"},{"location":"release-notes/#fix_9","title":"Fix","text":"<ul> <li> Fixed <code>bavapi-gen-refs</code> command tests overwriting reference files.</li> </ul>"},{"location":"release-notes/#internal_10","title":"Internal","text":"<ul> <li> <code>'BAVAPI SDK Python'</code> is now the default <code>User-Agent</code> for <code>bavapi</code>.</li> </ul>"},{"location":"release-notes/#docs_11","title":"Docs","text":"<ul> <li> Documentation for <code>timeout</code> usage.</li> <li> Automatically sync top level <code>CONTRIBUTING.md</code> file with the docs version.</li> <li> Fixed instructions to generate reference classes while specifying a token in the CLI command.</li> <li> Added missing parameter documentation for <code>Query</code> methods.</li> </ul>"},{"location":"release-notes/#ci_2","title":"CI","text":"<ul> <li> Removed end-to-end tests from CI pipeline due to various issues. They will have to be run manually in the near future.</li> </ul>"},{"location":"release-notes/#07","title":"<code>0.7</code>","text":""},{"location":"release-notes/#070-2023-08-22","title":"<code>0.7.0</code> (2023-08-22)","text":""},{"location":"release-notes/#feature_7","title":"Feature","text":"<ul> <li> It is now possible to specify a token with <code>-t</code>/<code>--token</code> when generating reference files via the <code>bavapi-gen-refs</code> command.</li> </ul>"},{"location":"release-notes/#fix_10","title":"Fix","text":"<ul> <li> <code>bavapi-gen-refs</code> would not run if <code>python-dotenv</code> was not installed. Now it will require an explicit token with <code>-t</code>/<code>--token</code> or, if <code>dotenv</code> is not installed, will prompt the user to install it and set the right environment variables.</li> </ul>"},{"location":"release-notes/#docs_12","title":"Docs","text":"<ul> <li> Fixed some links not pointing to the correct documentation pages.</li> <li> Added a \"Usage Tips\" section describing how to save queries for later use.</li> </ul>"},{"location":"release-notes/#ci_3","title":"CI","text":"<ul> <li> Set up automatic building of docs using <code>mike</code> and Github Actions.</li> <li> Fix <code>deploy_docs</code> nox session to install dependencies and actually run the deploy command.</li> </ul>"},{"location":"release-notes/#06","title":"<code>0.6</code>","text":""},{"location":"release-notes/#061-2023-07-19","title":"<code>0.6.1</code> (2023-07-19)","text":""},{"location":"release-notes/#fix_11","title":"Fix","text":"<ul> <li> Fix <code>metric_keys</code> incorrectly categorized as a filter instead of a top-level parameter within the <code>Query</code> class.</li> </ul>"},{"location":"release-notes/#internal_11","title":"Internal","text":"<ul> <li> Changed the custom <code>IntEnum</code> implementation to not override the standard lib's <code>IntEnum.__str__</code>.</li> <li> Added <code>nox</code> session for deploying docs.</li> </ul>"},{"location":"release-notes/#tests_1","title":"Tests","text":"<ul> <li> Added tests for checking that filters and parameters are assigned correctly in <code>Client</code> methods.</li> </ul>"},{"location":"release-notes/#docs_13","title":"Docs","text":"<ul> <li> Added warning about potential SSL errors outside of <code>bavapi</code> when using the Fount API.</li> </ul>"},{"location":"release-notes/#060-2023-07-13","title":"<code>0.6.0</code> (2023-07-13)","text":""},{"location":"release-notes/#internal_12","title":"Internal","text":"<ul> <li> Upgraded <code>pydantic</code> to <code>v2</code>. Use <code>bavapi</code> <code>v0.5</code> for compatibility with <code>pydantic</code> <code>v1</code>.</li> </ul>"},{"location":"release-notes/#typing_2","title":"Typing","text":"<ul> <li> Fixed use of <code>type</code> in type hints not compatible with Python 3.8.</li> <li> Cleaned up type hints in tests.</li> </ul>"},{"location":"roadmap/","title":"<code>bavapi</code> Roadmap","text":"<p><code>bavapi</code> has now reached stable status</p>"},{"location":"roadmap/#release-roadmap","title":"Release Roadmap","text":"<p>This is a non-exhaustive list of potential features &amp; changes to <code>bavapi</code> before it is ready for full release:</p>"},{"location":"roadmap/#core-tooling","title":"Core tooling","text":"<ul> <li> <code>v0.6.0</code> <code>pydantic</code> V2 support</li> <li> <code>v0.9.0</code> Strict <code>mypy</code> support with PEP 692 <code>Unpack</code> and <code>TypedDict</code></li> <li> <code>v0.11.0</code> Ability to use custom <code>bavapi.Query</code> objects in endpoint methods and functions</li> <li> <code>v0.11.0</code> Improved importing experiece when using reference classes created via the <code>bavapi-gen-refs</code> command</li> <li> <code>v0.12.0</code> Ability to control pagination for performing a lot of requests.</li> </ul>"},{"location":"roadmap/#known-issues","title":"Known issues","text":"<ul> <li> <code>v0.13.0</code> Sporadic <code>SSL: CERTIFICATE_VERIFY_FAILED</code> errors when making requests to the Fount API.</li> </ul>"},{"location":"roadmap/#fully-supported-endpoints","title":"Fully-supported endpoints","text":"<p>Eventually, the plan is to support almost all endpoints. This is the current priority list:</p> <ul> <li> <code>v0.1.0</code> Brands</li> <li> <code>v0.1.0</code> Brandscape Data</li> <li> <code>v0.1.0</code> Studies</li> <li> <code>v0.4.0</code> Audiences</li> <li> <code>v0.10.0</code> Categories</li> <li> <code>v0.10.0</code> Collections</li> <li> <code>v0.10.0</code> Brand Metrics</li> <li> <code>v0.10.0</code> Sectors</li> <li> <code>v0.10.0</code> Brand Metric Groups</li> <li> <code>v1.0.0</code> Cities</li> <li> <code>v1.0.0</code> Companies</li> <li> <code>v1.0.0</code> Countries</li> <li> <code>v1.0.0</code> Regions</li> <li> <code>v1.0.0</code> Years</li> </ul>"},{"location":"roadmap/#stretch-goals","title":"Stretch goals","text":"<ul> <li> <code>v0.8.1</code> Smarter flattening of JSON responses, possibly through <code>pandas.json_normalize</code>.</li> </ul>"},{"location":"endpoints/","title":"Endpoints","text":"<p>As of <code>v1.0</code>, these are the endpoints that have been fully implemented in <code>bavapi</code>:</p> <ul> <li><code>audiences</code></li> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>brands</code></li> <li><code>brandscape-data</code></li> <li><code>categories</code></li> <li><code>cities</code></li> <li><code>collections</code></li> <li><code>companies</code></li> <li><code>countries</code></li> <li><code>sectors</code></li> <li><code>studies</code></li> <li><code>years</code></li> </ul> <p>\"Implemented\" in this case means that the endpoint has a corresponding function, <code>Client</code> method, and filters class associated with them. More info in each endpoint's respective section linked above.</p> <p>If an existing endpoint does not appear in the list above, you can still perform queries to it using the <code>raw_query</code> function/method (see below), but <code>bavapi</code> won't validate filter parameters.</p> <p>Examples for each endpoint are available in each of their individual sections, both for the top-level, synchronous functions, and the asynchronous methods in <code>bavapi.Client</code>.</p> <p>For a summary of all existing Fount endpoints, as well as their parameters and supported filters, please see the Resources section of the Fount API documentation.</p>"},{"location":"endpoints/#other-endpoints","title":"Other endpoints","text":"<p>While there are some commonly used endpoints with more extensive validation support, there are a lot of additional endpoints available for querying.</p> <p>With the <code>raw_query</code> functions and methods, you can perform requests to any endpoint in the Fount, even if it's not supported with dedicated code.</p> Endpoint Function <code>Client</code> method Filters class <code>{any}</code> <code>raw_query</code> <code>Client.raw_query</code> <code>FountFilters</code> <p>Queries from <code>raw_query</code> functions and methods return a list of JSON dictionaries, instead of a <code>pandas</code> DataFrame.</p> <p>Note</p> <p>You need to use a <code>Query</code> instance to perform queries with <code>raw_query</code> methods. More info</p>"},{"location":"endpoints/#usage","title":"Usage","text":"AsyncSync <pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.raw_query(\"companies\", bavapi.Query())\n</code></pre> <pre><code>import bavapi\n\nresult = bavapi.raw_query(\"TOKEN\", \"companies\", bavapi.Query())\n</code></pre> <p>Since the result of these queries will be a list of JSON dictionaries, you can use the <code>parse_response</code> function in the <code>bavapi.parsing.responses</code> module to parse the JSON response into a DataFrame:</p> <pre><code>import bavapi\nfrom bavapi.parsing.responses import parse_response\n\nresult = bavapi.raw_query(\"companies\", bavapi.Query())\n\nparsed = parse_response(result)  # will return a DataFrame\n</code></pre>"},{"location":"endpoints/audiences/","title":"Audiences","text":"<p>The <code>audiences</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"audiences\"</code> <code>audiences</code> <code>Client.audiences</code> <code>AudiencesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>audiences</code> endpoint.</p>"},{"location":"endpoints/audiences/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.audiences(name=\"All Adults\")\n</code></pre>"},{"location":"endpoints/audiences/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>active</code>, <code>public</code></li> <li>Keyword filters: <code>audience_id</code>, <code>private</code>, <code>groups</code></li> </ul> <p>For other filters, passing an <code>AudienceFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brand-metric-groups/","title":"Brand Metric Groups","text":"<p>New in <code>v0.10</code></p> <p>The <code>brand-metric-groups</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brand-metric-groups\"</code> <code>brand_metric_groups</code> <code>Client.brand_metric_groups</code> <code>BrandMetricsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brand-metric-groups</code> endpoint.</p>"},{"location":"endpoints/brand-metric-groups/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brand_metric_groups(\"TOKEN\", name=\"Pillars\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brand_metric_groups(name=\"Pillars\")\n</code></pre>"},{"location":"endpoints/brand-metric-groups/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>active</code></li> <li>Keyword filters: <code>group_id</code></li> </ul> <p>For other filters, passing a <code>BrandMetricGroupsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brand-metrics/","title":"Brand Metrics","text":"<p>New in <code>v0.10</code></p> <p>The <code>brand-metrics</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brand-metrics\"</code> <code>brand_metrics</code> <code>Client.brand_metrics</code> <code>BrandMetricsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brand-metrics</code> endpoint.</p>"},{"location":"endpoints/brand-metrics/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brand_metrics(\"TOKEN\", name=\"Differentiation\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brand_metrics(name=\"Differentiation\")\n</code></pre>"},{"location":"endpoints/brand-metrics/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>active</code>, <code>public</code></li> <li>Keyword filters: <code>metric_id</code>, <code>private</code>, <code>groups</code></li> </ul> <p>For other filters, passing a <code>BrandMetricsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brands/","title":"Brands","text":"<p>The <code>brands</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brands\"</code> <code>brands</code> <code>Client.brands</code> <code>BrandsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brands</code> endpoint.</p>"},{"location":"endpoints/brands/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brands(\"TOKEN\", name=\"Facebook\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brands(name=\"Facebook\")\n</code></pre>"},{"location":"endpoints/brands/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>country_codes</code>, <code>year_numbers</code></li> <li>Keyword filters: <code>brand_id</code>, <code>studies</code></li> </ul> <p>For other filters, passing a <code>BrandsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brandscape-data/","title":"Brandscape Data","text":"<p>The <code>brandscape-data</code> endpoint has full support, including query validation.</p> <p>This is the main entry point to WPPBAV's extensive brand data catalog.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brandscape-data\"</code> <code>brandscape_data</code> <code>Client.brandscape_data</code> <code>BrandscapeFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brandscape-data</code> endpoint.</p>"},{"location":"endpoints/brandscape-data/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brandscape_data(\"TOKEN\", name=\"Facebook\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brandscape_data(name=\"Facebook\")\n</code></pre> <p>Warning</p> <p><code>brandscape-data</code> has filters which have a slightly different name than for other endpoints:</p> <ul> <li><code>year_number</code> instead of <code>year_numbers</code>.</li> <li><code>country_code</code> instead of <code>country_codes</code>.</li> </ul> <p>This is to maintain parity with the way the API is structured. Using the wrong spelling of these parameters will likely result in an error.</p>"},{"location":"endpoints/brandscape-data/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>country_code</code>, <code>year_number</code>, <code>audiences</code>, <code>brand_name</code> (search by name)</li> <li>Keyword filters: <code>studies</code></li> </ul> <p>For other filters, passing a <code>BrandscapeFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brandscape-data/#required-filters","title":"Required filters","text":"<p><code>brandscape-data</code> can retrieve brand datasets from an arbitrary combination of studies, audiences and years, so it is possible that the request becomes too large for the server to deliver effectively for all users.</p> <p>Thus, the <code>brandscape-data</code> endpoint has been restricted to require at least one of these specific set of filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" works just as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>If a query does not have any of these combinations of filters, it will raise a <code>ValidationError</code>:</p> <pre><code>bavapi.brandscape_data(\"TOKEN\")  # Error, no filters specified\n\nbavapi.brandscape_data(\"TOKEN\", year_number=2022) # Error, not enough filters\n\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\") # OK\n\nbavapi.brandscape_data(\n    \"TOKEN\", filters=bavapi.filters.BrandscapeFilters(audience=22, brands=123)\n)  # OK\n</code></pre>"},{"location":"endpoints/brandscape-data/#default-includes","title":"Default includes","text":"<p>In order to provide critical information about the data retrieved from <code>brandscape-data</code>, and to move its structure in line with data downloads from the Fount or BAV's Cultural Rank Tool (CRT), some <code>include</code> values are requested by default: <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code>.</p> <p>If you add any of these values in the <code>include</code> field by themselves, the default won't be used, and <code>bavapi</code> will make a request with the specified <code>include</code> instead.</p> <p>If, on the other hand, you request an <code>include</code> that is not part of the default values, <code>bavapi</code> will append that new value to the default <code>include</code> values.</p> <pre><code># All default (study, brand, category and audience) includes will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\")\n\n# Only the \"brand\" include will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"brand\")\n\n# The \"company\" include will be appended to the default `include` values\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"company\")\n</code></pre> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p>"},{"location":"endpoints/brandscape-data/#clashing-column-names","title":"Clashing column names","text":"<p>Some includes can have clashing column names with the original data. This happens, for example, with the <code>\"brand\"</code> include, which when expanded will have column names such as <code>\"brand_name\"</code>, which is already present in the <code>brandscape-data</code> table.</p> <p>To circumvent this issue, the response parsing function will append the <code>\"global_\"</code> prefix to includes with potentially clashing names.</p> <p>As a result, you will see a set of columns, extracted from the <code>\"brand\"</code> include, which will have a <code>\"global_\"</code> prefix in their names.</p> <p>Warning</p> <p>This may change in future versions of <code>bavapi</code> as the parsing logic is upgraded.</p>"},{"location":"endpoints/brandscape-data/#metric-and-metric-group-keys","title":"Metric and metric group keys","text":"<p>New in <code>v0.12</code></p> <p><code>brandscape-data</code> functions and methods provide two parameters to specify the data columns that the response should contain: <code>metric_keys</code> and <code>metric_group_keys</code>.</p> <p>You can specify the metrics (or metric groups) that your response should contain, and the API will include all score types for that metric.</p> <p>Example</p> <p>Setting <code>metric_keys</code> to <code>[\"differentiation\", \"relevance\"]</code> will instruct the request to only return the following columns:</p> <ul> <li><code>differentiation_c</code></li> <li><code>differentiation_rank</code></li> <li><code>relevance_c</code></li> <li><code>relevance_rank</code></li> <li>Brand information such as <code>id</code>, <code>brand_name</code>, and <code>category_name</code></li> <li>Any additional columns from the <code>include</code> parameter (see default behavior above)</li> </ul> <pre><code>bavapi.brandscape_data(studies=111, metric_keys=\"differentiation\") # (1)\n</code></pre> <ol> <li>Will only return <code>differentiation_c</code> and <code>differentiation_rank</code> data.</li> </ol>"},{"location":"endpoints/categories/","title":"Categories","text":"<p>New in <code>v0.10</code></p> <p>The <code>categories</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"categories\"</code> <code>categories</code> <code>Client.categories</code> <code>CategoriesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>categories</code> endpoint.</p>"},{"location":"endpoints/categories/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.categories(\"TOKEN\", name=\"Soap\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.categories(name=\"Soap\")\n</code></pre>"},{"location":"endpoints/categories/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>sectors</code></li> <li>Keyword filters: <code>category_id</code></li> </ul> <p>For other filters, passing a <code>CategoriesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/categories/#default-includes","title":"Default includes","text":"<p>In order to provide critical information about the data retrieved from <code>categories</code>, and to move its structure in line with data downloads from the Fount or BAV's Cultural Rank Tool (CRT), some <code>include</code> values are requested by default: <code>sector</code>.</p> <pre><code># All default (sector) includes will be requested\nbavapi.categories(\"TOKEN\", name=\"All Adults\")\n</code></pre> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p>"},{"location":"endpoints/cities/","title":"Cities","text":"<p>New in <code>v1.0</code></p> <p>The <code>cities</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"cities\"</code> <code>cities</code> <code>Client.cities</code> <code>CitiesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>cities</code> endpoint.</p>"},{"location":"endpoints/cities/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.cities(\"TOKEN\", name=\"London\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.cities(name=\"London\")\n</code></pre>"},{"location":"endpoints/cities/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>capitals</code>, <code>countries</code>, <code>in_best_countries</code></li> <li>Keyword filters: <code>city_id</code></li> </ul> <p>For other filters, passing a <code>CitiesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/collections/","title":"Collections","text":"<p>New in <code>v0.10</code></p> <p>The <code>collections</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"collections\"</code> <code>collections</code> <code>Client.collections</code> <code>CollectionsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>collections</code> endpoint.</p>"},{"location":"endpoints/collections/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.collections(\"TOKEN\", name=\"Unilever\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.collections(name=\"Unilever\")\n</code></pre>"},{"location":"endpoints/collections/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>public</code></li> <li>Keyword filters: <code>collection_id</code>, <code>shared_with_me</code>, <code>mine</code></li> </ul> <p>For other filters, passing a <code>CollectionsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/companies/","title":"Companies","text":"<p>New in <code>v1.0</code></p> <p>The <code>companies</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"companies\"</code> <code>companies</code> <code>Client.companies</code> <code>CompaniesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>companies</code> endpoint.</p>"},{"location":"endpoints/companies/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.companies(\"TOKEN\", name=\"Alphabet\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.companies(name=\"Alphabet\")\n</code></pre>"},{"location":"endpoints/companies/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>public</code>, <code>private</code>, <code>brands</code></li> <li>Keyword filters: <code>company_id</code></li> </ul> <p>For other filters, passing a <code>CompaniesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/countries/","title":"Countries","text":"<p>New in <code>v1.0</code></p> <p>The <code>countries</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"countries\"</code> <code>countries</code> <code>Client.countries</code> <code>CountriesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>countries</code> endpoint.</p>"},{"location":"endpoints/countries/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.countries(\"TOKEN\", name=\"Mexico\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.countries(name=\"Mexico\")\n</code></pre>"},{"location":"endpoints/countries/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>active</code>, <code>regions</code>, <code>with_studies</code></li> <li>Keyword filters: <code>country_id</code>, <code>with_recent_studies</code></li> </ul> <p>For other filters, passing a <code>CountriesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/regions/","title":"Regions","text":"<p>New in <code>v1.0</code></p> <p>The <code>regions</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"regions\"</code> <code>regions</code> <code>Client.regions</code> <code>RegionsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>regions</code> endpoint.</p>"},{"location":"endpoints/regions/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.regions(\"TOKEN\", name=\"Europe\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.regions(name=\"Europe\")\n</code></pre>"},{"location":"endpoints/regions/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code></li> <li>Keyword filters: <code>region_id</code></li> </ul> <p>For other filters, passing a <code>RegionsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/sectors/","title":"Sectors","text":"<p>New in <code>v0.10</code></p> <p>The <code>sectors</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"sectors\"</code> <code>sectors</code> <code>Client.sectors</code> <code>SectorsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>sectors</code> endpoint.</p>"},{"location":"endpoints/sectors/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.sectors(\"TOKEN\", name=\"Distribution\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.sectors(name=\"Distribution\")\n</code></pre>"},{"location":"endpoints/sectors/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>name</code>, <code>in_most_influential</code></li> <li>Keyword filters: <code>sector_id</code></li> </ul> <p>For other filters, passing a <code>SectorsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/studies/","title":"Studies","text":"<p>The <code>studies</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"studies\"</code> <code>studies</code> <code>Client.studies</code> <code>StudiesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>studies</code> endpoint.</p>"},{"location":"endpoints/studies/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.studies(\"TOKEN\", country_codes=\"US\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.studies(country_codes=\"US\")\n</code></pre>"},{"location":"endpoints/studies/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>country_codes</code>, <code>year_numbers</code>, <code>full_year</code>, <code>released</code>, <code>bav_study</code></li> <li>Keyword filters: <code>study_id</code></li> </ul> <p>For other filters, passing a <code>StudiesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/years/","title":"Years","text":"<p>New in <code>v1.0</code></p> <p>The <code>years</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"years\"</code> <code>years</code> <code>Client.years</code> <code>YearsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>years</code> endpoint.</p>"},{"location":"endpoints/years/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.years(\"TOKEN\", year=2023)\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.years(year=2023)\n</code></pre>"},{"location":"endpoints/years/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li>Positional filters: <code>year</code></li> <li>Keyword filters: <code>year_id</code></li> </ul> <p>For other filters, passing a <code>YearsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"getting-started/authentication/","title":"Authentication","text":"<p>The first thing you will need to use <code>bavapi</code> is a Fount API authentication token (a.k.a. key).</p> <p>This token is a specific code that is assigned to you and is needed to confirm that you have access to the Fount data.</p>"},{"location":"getting-started/authentication/#getting-a-fount-api-token","title":"Getting a Fount API token","text":"<p>Please follow the instructions in the Authentication section of the Fount API documentation.</p> <p>Warning</p> <p>Do NOT share your API token publicly or with anyone else. That token is tied to your account exclusively. If somebody else needs a token, they should create their own from their account settings.</p>"},{"location":"getting-started/authentication/#recommended-way-to-manage-api-keys","title":"Recommended way to manage API keys","text":"<p>In order to keep your API token secure, you should avoid using your token directly in your code and applications. Instead, place the code in a <code>.env</code> file at the top of your project directory, and use <code>python-dotenv</code> to load the token into your environment:</p> <pre><code>my-project-folder\n\u251c\u2500\u2500\u2500 .env\n\u2514\u2500\u2500\u2500 ... (other stuff)\n</code></pre> <p>Create a <code>.env</code> file (note the leading dot) in the top level of your working directory, and write down your token:</p> <pre><code>BAV_API_KEY = \"your_token_here\"\n</code></pre> <p>Tip</p> <p>The <code>bavapi-gen-refs</code> command also uses the <code>BAV_API_KEY</code> variable name.</p> <p>To now use this file, you will need to install the <code>python-dotenv</code> package:</p> <pre><code>pip install python-dotenv\n</code></pre> <p>Now, paste this code at the top of your Python files or Jupyter Notebooks:</p> <pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()  # (1)\nTOKEN = os.environ[\"BAV_API_KEY\"]  # (2)\n</code></pre> <ol> <li>Load variables from <code>.env</code> into the system's environment</li> <li>Assign the <code>\"BAV_API_KEY\"</code> environment variable to our <code>TOKEN</code> local variable</li> </ol> <p>Now you can use <code>TOKEN</code> in your API requests:</p> <pre><code>bavapi.brands(TOKEN, name=\"Swatch\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<p><code>bavapi</code> requires python 3.8 or higher to run.</p> <p>If you don't have python installed, you can download it from the official Python website or Anaconda.</p> <p>You will also need a Fount API bearer token to peform requests to the Fount. For instructions on how to get your own API token, see the Authentication section.</p> <p>Once you have installed Python and have acquired your Fount API token, return to this page to continue.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p><code>bavapi</code> depends on the following excellent libraries:</p> <ul> <li><code>httpx</code> for communication with the Fount API.</li> <li><code>pandas</code> for processing retrieved data into tables.</li> <li><code>pydantic</code> to validate query and filter parameters.</li> <li><code>nest-asyncio</code> to support Jupyter notebooks.</li> <li><code>tqdm</code> to show helpful progress bars.</li> <li><code>typing-extensions</code> for type-checking compatibility in Python &lt; 3.12.</li> </ul> <p>These libraries will be installed automatically when you install <code>bavapi</code>.</p>"},{"location":"getting-started/installation/#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p>Once you have your virtual (or conda) environment activated, you can install <code>bavapi</code> with the following command:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>Installing with <code>conda</code></p> <p><code>bavapi</code> is not currently available from <code>conda</code> directly, though it should be possible to install and use it within a <code>conda</code> environment.</p> <p>You can use the following commands to maximize compatibility between <code>conda</code> and <code>pip</code>:</p> <pre><code>conda install httpx, pandas, pydantic, nest-asyncio, tqdm, typing_extensions\n\npip install wpp-bavapi --no-deps\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from source","text":"<p>To install from source, clone the GitHub repository into your local machine:</p> <pre><code>git clone https://github.com/wppbav/bavapi-sdk-python.git\n</code></pre> <p>Go into the cloned directory and install <code>bavapi</code>:</p> <pre><code>cd bavapi-sdk-python\npip install .\n</code></pre>"},{"location":"getting-started/reference-classes/","title":"Reference classes","text":"<p><code>bavapi</code> can generate some convenience reference classes which map Fount resource IDs with a more readable name, both for ease of use and for autocompletion in IDEs.</p> <p>These classes are automatically generated by a console command that becomes available once <code>bavapi</code> is installed.</p> <p>Protected Access</p> <p>A Fount API token is required to generate reference files. See the Authentication section for more information and instructions for using <code>.env</code> files.</p> <p>As of <code>v1.0</code> the following reference classes will be generated in a folder named <code>bavapi_refs</code> (by default, see below):</p> <ul> <li><code>Audiences</code>: encodes audience IDs</li> <li><code>Countries</code>: encodes country IDs</li> </ul> <p>A sample reference class would look like this:</p> <pre><code>class Audiences(Enum):\n    ALL_ADULTS = 123\n    ...\n</code></pre> <p>And could be used to have better visibility and readability when filtering API responses:</p> Using Reference classNot using Reference class Explicit audience filter<pre><code>from bavapi_refs import Audiences\n\nbavapi.brandscape_data(country_code=\"US\", year=2022, audiences=Audiences.ALL_ADULTS)\n</code></pre> Audience filter not human-readable<pre><code>bavapi.brandscape_data(country_code=\"US\", year=2022, audiences=123)\n</code></pre> <p>Warning</p> <p>Don't commit reference classes to public repositories. Add <code>bavapi_refs/</code> to your <code>.gitignore</code> file.</p>"},{"location":"getting-started/reference-classes/#generate-reference-classes","title":"Generate Reference classes","text":"<p>New in <code>v0.7</code></p> <p>To generate these reference classes, there are two options for authenticating your requests:</p> <ul> <li>Specify the Fount API token via the <code>-t</code>/<code>--token</code> argument</li> <li>Use a <code>.env</code> file to store your Fount API token as the <code>BAV_API_KEY</code> environment variable, and install <code>python-dotenv</code> to read the file into your environment. See the Authentication section for more info.</li> </ul> <p>To generate the reference files, run the following command:</p> With a <code>.env</code> fileUsing the <code>-t</code>/<code>--token</code> argument <pre><code>bavapi-gen-refs --all\n</code></pre> <pre><code>bavapi-gen-refs -t \"TOKEN\" --all\n</code></pre> <p>You can also specify the name of the reference class to generate:</p> <pre><code>bavapi-gen-refs -t \"TOKEN\" --name audiences\n</code></pre> <p>To update existing reference classes with the latest data, re-run <code>bavapi-gen-refs</code> with the appropriate parameters on your terminal.</p>"},{"location":"getting-started/reference-classes/#specify-destination-folder","title":"Specify destination folder","text":"<p>New in <code>v0.11</code></p> <p>Finally, you can specify the destination folder with <code>-d</code>/<code>--dest-folder</code> where you want to store the reference classes. This will determine the name required for import (<code>from {dest_folder} import {Reference}</code>).</p> <p>It is recommended to leave this as the default <code>./bavapi_refs/</code>, though if you do want to change it, it is also recommended to store them as a top level folder in your project directory.</p> <pre><code>bavapi-gen-refs -d \"custom_folder/\" --name audiences\n</code></pre> <p>Warning</p> <p>If you change the destination folder, remember not to commit it to public repositories. Add <code>{custom_folder}/</code> to your <code>.gitignore</code> file.</p>"},{"location":"getting-started/reference-classes/#bavapi-gen-refs-options","title":"<code>bavapi-gen-refs</code> options","text":"Option Description <code>-h</code>, <code>--help</code> Show help message and exit <code>-t</code>, <code>--token</code> <code>TOKEN</code> WPPBAV Fount API token <code>-a</code>, <code>--all</code> Generate all reference files <code>-n</code>, <code>--name</code> {<code>audiences</code>,<code>countries</code>} Name of reference to generate <code>-d</code>, <code>--dest-folder</code> <code>DEST_FOLDER</code> Path to destination folder, default <code>'./bavapi_refs/'</code>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>sync</li> <li>client</li> <li>exceptions</li> <li>filters</li> <li>http</li> <li>parsing<ul> <li>params</li> <li>responses</li> </ul> </li> <li>query</li> </ul>"},{"location":"reference/client/","title":"client","text":"<p>Asynchronous BAV API client interface.</p> <p>Similar to <code>requests.Session</code> or <code>httpx.AsyncClient</code> (uses the latter as dependency).</p> <p>Examples:</p> <p>Create a client instance and make a request to the <code>brands</code> endpoint.</p> <pre><code>&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result = await bav.brands(\"Facebook\")\n</code></pre> <p>A more complex query:</p> <pre><code>&gt;&gt;&gt; from bavapi_refs import Audiences\n&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     bss = await bav.brandscape_data(\n...         country_code=\"UK\",\n...         year_number=2022,\n...         audiences=Audiences.ALL_ADULTS,\n...     )\n</code></pre> <p>Multiple queries will share the client connection for better performance:</p> <pre><code>&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result1 = await bav.brands(\"Facebook\")\n...     result2 = await bav.brands(\"Instagram\")\n</code></pre> <p>Use <code>Client.raw_query</code> (with <code>bavapi.Query</code>) for endpoints that aren't fully supported:</p> <pre><code>&gt;&gt;&gt; query = bavapi.Query(filters=bavapi.filters.FountFilters(name=\"Meta\"))\n&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result = await bav.raw_query(\"companies\", query=query)\n</code></pre>"},{"location":"reference/client/#client.Client","title":"<code>Client(auth_token='', per_page=100, timeout=30.0, verify=True, user_agent='', *, client=None, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn')</code>","text":"<p>Asynchronous API to interact with the WPPBAV Fount API.</p> <p>This class uses <code>asyncio</code> to perform asynchronous requests to the Fount API.</p> <p>Asynchronous requests allow you to make multiple requests at the same time, extremely helpful for working with a paginated API like the Fount. (returns data in multiple pages or requests instead of one single download)</p> <p>To use the Client class, you will need to precede calls with <code>await</code>:</p> <pre><code>bav = Client(\"TOKEN\")  # creating client instance does not use `await`\ndata = await bav.brands(\"Swatch\")  # must use `await`\n</code></pre> <p>For more information, see the <code>asyncio</code> documentation for Python.</p> <p>Either <code>auth_token</code> or <code>client</code> are required to instantiate a Client.</p> <p>Parameters:</p> Name Type Description Default <code>auth_token</code> <code>str</code> <p>WPPBAV Fount API authorization token, default <code>''</code></p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>user_agent</code> <code>str</code> <p>The name of the User-Agent to send to the Fount API, default <code>''</code>.</p> <p>If no user_agent is set, <code>bavapi</code> will use <code>\"BAVAPI SDK Python\"</code> by default.</p> <code>''</code> <code>client</code> <code>HTTPClient</code> <p>Authenticated async client from <code>bavapi.http</code>, default None</p> <p>If <code>client</code> is passed, all other parameters will be ignored.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>auth_token</code> nor <code>client</code> are provided</p> <p>Examples:</p> <p>Use <code>async with</code> to get data and close the connection.</p> <p>This way you get the benefits from <code>httpx</code> speed improvements and closes the connection when exiting the async with block.</p> <pre><code>&gt;&gt;&gt; async with Client(\"TOKEN\") as bav:\n...     data = await bav.brands(\"Swatch\")\n</code></pre> <p>When not using <code>async with</code>, close the connection manually by awaiting <code>aclose</code>.</p> <pre><code>&gt;&gt;&gt; bav = Client(\"TOKEN\")\n&gt;&gt;&gt; data = await bav.brands(\"Swatch\")\n&gt;&gt;&gt; await bav.aclose()\n</code></pre> <p>If you want to perform multiple endpoint requests with the same <code>Client</code>, it is recommended to use <code>verbose=False</code> to avoid jumping progress bars.</p> <pre><code>&gt;&gt;&gt; async with Client(\"TOKEN\", verbose=False) as bav:\n...     resp1 = await bav.brands(\"Facebook\")\n...     resp2 = await bav.brands(\"Microsoft\")\n</code></pre> Source code in <code>bavapi/client.py</code> <pre><code>def __init__(\n    self,\n    auth_token: str = \"\",\n    per_page: int = 100,\n    timeout: float = 30.0,\n    verify: Union[bool, str] = True,\n    user_agent: str = \"\",\n    *,\n    client: Optional[HTTPClient] = None,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n) -&gt; None:\n    if client is not None:\n        self._client = client\n    else:\n        if not auth_token:\n            raise ValueError(\"You must provide `auth_token` or `client`.\")\n        self._client = HTTPClient(\n            base_url=BASE_URL,\n            per_page=per_page,\n            timeout=timeout,\n            verify=verify,\n            headers={\n                \"Authorization\": f\"Bearer {auth_token}\",\n                \"Accept\": \"application/json\",\n                \"User-Agent\": user_agent or USER_AGENT,\n            },\n            verbose=verbose,\n            batch_size=batch_size,\n            n_workers=n_workers,\n            retries=retries,\n            on_errors=on_errors,\n        )\n</code></pre>"},{"location":"reference/client/#client.Client.batch_size","title":"<code>batch_size: int</code>  <code>property</code> <code>writable</code>","text":"<p>Size of batches to make requests with.</p>"},{"location":"reference/client/#client.Client.n_workers","title":"<code>n_workers: int</code>  <code>property</code> <code>writable</code>","text":"<p>Number of workers to make requests.</p>"},{"location":"reference/client/#client.Client.on_errors","title":"<code>on_errors: Literal['warn', 'raise']</code>  <code>property</code> <code>writable</code>","text":"<p>Raise immediately on errors or warn at the end of the request.</p>"},{"location":"reference/client/#client.Client.per_page","title":"<code>per_page: int</code>  <code>property</code> <code>writable</code>","text":"<p>Default number of items to retrieve per page.</p>"},{"location":"reference/client/#client.Client.retries","title":"<code>retries: int</code>  <code>property</code> <code>writable</code>","text":"<p>Number of times to retry a request.</p>"},{"location":"reference/client/#client.Client.verbose","title":"<code>verbose: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Show progress bar when making requests.</p>"},{"location":"reference/client/#client.Client.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Close existing HTTP connections.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close existing HTTP connections.\"\"\"\n    return await self._client.aclose()\n</code></pre>"},{"location":"reference/client/#client.Client.audiences","title":"<code>audiences(name=None, active=0, public=0, *, audience_id=None, private=0, groups=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search audiences by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict[str, Any]</code> <p>AudiencesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[AudiencesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>audiences</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def audiences(\n    self,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    *,\n    audience_id: Optional[int] = None,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.AudiencesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `audiences` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search audiences by name, default None\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, default 0\n    audience_id : int, optional\n        Fount audience ID, default None\n\n        If an audience ID is provided, only that audience will be returned\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, default None\n    filters : AudiencesFilters or dict[str, Any], optional\n        AudiencesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[AudiencesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `audiences` endpoint results.\n    \"\"\"\n    filters = _filters.AudiencesFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        public=public,\n        private=private,\n        groups=groups,\n    )\n\n    query = Query.ensure(\n        query,\n        id=audience_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"audiences\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brand_metric_groups","title":"<code>brand_metric_groups(name=None, active=0, *, group_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metric-groups</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brand metric groups by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metric groups only if set to <code>1</code>, default 0</p> <code>0</code> <code>group_id</code> <code>int</code> <p>Fount metric group ID, default None</p> <p>If a metric group ID is provided, only that metric group will be returned</p> <code>None</code> <code>filters</code> <code>BrandMetricGroupsFilters or dict[str, Any]</code> <p>BrandMetricGroupsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandMetricGroupsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metric-groups</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def brand_metric_groups(\n    self,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    *,\n    group_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricGroupsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandMetricGroupsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metric-groups` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brand metric groups by name, default None\n    active : Literal[0, 1], optional\n        Return active brand metric groups only if set to `1`, default 0\n    group_id : int, optional\n        Fount metric group ID, default None\n\n        If a metric group ID is provided, only that metric group will be returned\n    filters : BrandMetricGroupsFilters or dict[str, Any], optional\n        BrandMetricGroupsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandMetricGroupsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metric-groups` endpoint results.\n    \"\"\"\n    filters = _filters.BrandMetricGroupsFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n    )\n\n    query = Query.ensure(\n        query,\n        id=group_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brand-metric-groups\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brand_metrics","title":"<code>brand_metrics(name=None, active=0, public=0, *, metric_id=None, private=0, groups=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metrics</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brand metrics by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>metric_id</code> <code>int</code> <p>Fount metric ID, default None</p> <p>If a metric ID is provided, only that metric will be returned</p> <code>None</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Brand metrics group ID or list of brand metrics group IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandMetricsFilters or dict[str, Any]</code> <p>BrandMetricsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandMetricsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metrics</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def brand_metrics(\n    self,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    *,\n    metric_id: Optional[int] = None,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandMetricsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metrics` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brand metrics by name, default None\n    active : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, default 0\n    public : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, default 0\n    metric_id : int, optional\n        Fount metric ID, default None\n\n        If a metric ID is provided, only that metric will be returned\n    private : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, default 0\n    groups : int or list[int], optional\n        Brand metrics group ID or list of brand metrics group IDs, default None\n    filters : BrandMetricsFilters or dict[str, Any], optional\n        BrandMetricsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandMetricsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metrics` endpoint results.\n    \"\"\"\n    filters = _filters.BrandMetricsFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        public=public,\n        private=private,\n        groups=groups,\n    )\n\n    query = Query.ensure(\n        query,\n        id=metric_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brand-metrics\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brands","title":"<code>brands(name=None, country_codes=None, year_numbers=None, *, brand_id=None, studies=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brands by name, default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict[str, Any]</code> <p>BrandsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def brands(\n    self,\n    name: Optional[str] = None,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    *,\n    brand_id: Optional[int] = None,\n    studies: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brands` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brands by name, default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_numbers : int or list[int], optional\n        Study years, default None\n    brand_id : int, optional\n        Fount brand ID, default None\n\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, default None\n    filters : BrandsFilters or dict[str, Any], optional\n        BrandsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results.\n    \"\"\"\n    filters = _filters.BrandsFilters.ensure(\n        filters,\n        name=name,\n        country_codes=country_codes,\n        year_numbers=year_numbers,\n        studies=studies,\n    )\n\n    query = Query.ensure(\n        query,\n        id=brand_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brands\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brandscape_data","title":"<code>brandscape_data(country_code=None, year_number=None, audiences=None, brand_name=None, *, studies=None, filters=None, fields=None, include=None, metric_keys=None, metric_group_keys=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 100 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code> - <code>audience</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>Also note that due to a name clash in the \"brand\" <code>include</code>, brand columns will be prefixed with <code>\"global_\"</code>. Thus, these columns will refer to the global brand, while the <code>brand_name</code> column will refer to the local brand/spelling.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict[str, Any]</code> <p>BrandscapeFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, default None</p> <code>None</code> <code>metric_group_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metric groups included in the response, default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>None</code> <code>query</code> <code>Query[BrandscapeFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi/client.py</code> <pre><code>async def brandscape_data(\n    self,\n    country_code: OptionalListOr[str] = None,\n    year_number: OptionalListOr[int] = None,\n    audiences: OptionalListOr[int] = None,\n    brand_name: Optional[str] = None,\n    *,\n    studies: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    metric_keys: OptionalListOr[str] = None,\n    metric_group_keys: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandscapeFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brandscape-data` endpoint.\n\n    This endpoint requires at least one of the following combinations of filters:\n\n    - Study + Audience + Brand + Category\n    - Country + Year + Audience\n    - Brand + Audience + Country + Year\n\n    You should read these from left to right. A combination of \"Study + Audience\"\n    worksjust as well as \"Study + Audience + Brand\".\n    However, \"Category + Audience\" will not.\n\n    If you use Country or Year filters, you must use both filters together.\n\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 100 standard audiences).\n\n    The `Audiences` class is provided to make it easier to filter audiences.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n    - `audience`\n\n    Any additional valid includes will be added to the default set.\n\n    Also note that due to a name clash in the \"brand\" `include`, brand columns\n    will be prefixed with `\"global_\"`. Thus, these columns will refer to the global\n    brand, while the `brand_name` column will refer to the local brand/spelling.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_number : int or list[int], optional\n        Study years, default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, default None\n\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, default None\n    studies : int or list[int], optional\n        Fount studies IDs, default None\n    filters : BrandscapeFilters or dict[str, Any], optional\n        BrandscapeFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, default None\n    metric_group_keys: str or list[str], optional\n        Key or list of keys for the metric groups included in the response, default None\n\n        Currently, this parameter is only available for the `brandscape-data` endpoint.\n    query : Query[BrandscapeFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results.\n\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\n    filters = _filters.BrandscapeFilters.ensure(\n        filters,\n        country_code=country_code,\n        year_number=year_number,\n        audiences=audiences,\n        brand_name=brand_name,\n        studies=studies,\n    )\n\n    query = Query.ensure(\n        query,\n        filters=filters,\n        fields=fields,\n        include=_default_include(include, BRANDSCAPE_DEFAULTS),\n        metric_keys=metric_keys,\n        metric_group_keys=metric_group_keys,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brandscape-data\", query)\n\n    # Prefix 'global' to avoid clashing with 'brand_name' on 'brand' includes\n    return parse_response(items, \"global\", expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.categories","title":"<code>categories(name=None, sectors=None, *, category_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>categories</code> endpoint.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>sector</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search categories by name, default None</p> <code>None</code> <code>sectors</code> <code>int or list[int]</code> <p>Filter categories by sector ID, default None</p> <code>None</code> <code>category_id</code> <code>int</code> <p>Fount category ID, default None</p> <p>If a category ID is provided, only that category will be returned</p> <code>None</code> <code>filters</code> <code>CategoriesFilters or dict[str, Any]</code> <p>CategoriesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CategoriesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>categories</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def categories(\n    self,\n    name: Optional[str] = None,\n    sectors: OptionalListOr[int] = None,\n    *,\n    category_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CategoriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CategoriesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `categories` endpoint.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `sector`\n\n    Any additional valid includes will be added to the default set.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search categories by name, default None\n    sectors : int or list[int], optional\n        Filter categories by sector ID, default None\n    category_id : int, optional\n        Fount category ID, default None\n\n        If a category ID is provided, only that category will be returned\n    filters : CategoriesFilters or dict[str, Any], optional\n        CategoriesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CategoriesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `categories` endpoint results.\n    \"\"\"\n    filters = _filters.CategoriesFilters.ensure(\n        filters,\n        name=name,\n        sectors=sectors,\n    )\n\n    query = Query.ensure(\n        query,\n        id=category_id,\n        filters=filters,\n        fields=fields,\n        include=_default_include(include, CATEGORIES_DEFAULTS),\n        **kwargs,\n    )\n\n    items = await self._client.query(\"categories\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.cities","title":"<code>cities(name=None, capitals=0, countries=None, in_best_countries=None, *, city_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>cities</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search cities by name, default None</p> <code>None</code> <code>capitals</code> <code>Literal[0, 1]</code> <p>Return capitals only, default 0</p> <code>0</code> <code>countries</code> <code>OptionalListOr[int]</code> <p>Fount country ID or list of country IDs, default None</p> <code>None</code> <code>in_best_countries</code> <code>OptionalListOr[int]</code> <p>Year number(s) of the Best Countries reports, default None</p> <p>Only return cities that appear in the Best Countries reports for those years</p> <code>None</code> <code>city_id</code> <code>int</code> <p>Fount city ID, default None</p> <p>If a city ID is provided, only that city will be returned</p> <code>None</code> <code>filters</code> <code>CitiesFilters or dict[str, Any]</code> <p>CitiesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CitiesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>cities</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def cities(\n    self,\n    name: Optional[str] = None,\n    capitals: Literal[0, 1] = 0,\n    countries: OptionalListOr[int] = None,\n    in_best_countries: OptionalListOr[int] = None,\n    *,\n    city_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CitiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CitiesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `cities` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search cities by name, default None\n    capitals: Literal[0, 1], optional\n        Return capitals only, default 0\n    countries: int or list[int], optional\n        Fount country ID or list of country IDs, default None\n    in_best_countries: int or list[int], optional\n        Year number(s) of the Best Countries reports, default None\n\n        Only return cities that appear in the Best Countries reports for those years\n    city_id : int, optional\n        Fount city ID, default None\n\n        If a city ID is provided, only that city will be returned\n    filters : CitiesFilters or dict[str, Any], optional\n        CitiesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CitiesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `cities` endpoint results.\n    \"\"\"\n    filters = _filters.CitiesFilters.ensure(\n        filters,\n        name=name,\n        capitals=capitals,\n        countries=countries,\n        in_best_countries=in_best_countries,\n    )\n\n    query = Query.ensure(\n        query,\n        id=city_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"cities\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.collections","title":"<code>collections(name=None, public=0, *, collection_id=None, shared_with_me=0, mine=0, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>collections</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search collections by name, default None</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public collections only, default 0</p> <code>0</code> <code>collection_id</code> <code>int</code> <p>Fount collection ID, default None</p> <p>If a collection ID is provided, only that collection will be returned</p> <code>None</code> <code>shared_with_me</code> <code>Literal[0, 1]</code> <p>Only return collections that have been shared with the user, default 0</p> <code>0</code> <code>mine</code> <code>Literal[0, 1]</code> <p>Only return collections created by the user, default 0</p> <code>0</code> <code>filters</code> <code>CollectionsFilters or dict[str, Any]</code> <p>CollectionsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CollectionsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>collections</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def collections(\n    self,\n    name: Optional[str] = None,\n    public: Literal[0, 1] = 0,\n    *,\n    collection_id: Optional[int] = None,\n    shared_with_me: Literal[0, 1] = 0,\n    mine: Literal[0, 1] = 0,\n    filters: OptionalFiltersOrMapping[_filters.CollectionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CollectionsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `collections` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search collections by name, default None\n    public : Literal[0, 1], optional\n        Return public collections only, default 0\n    collection_id : int, optional\n        Fount collection ID, default None\n\n        If a collection ID is provided, only that collection will be returned\n    shared_with_me : Literal[0, 1], optional\n        Only return collections that have been shared with the user, default 0\n    mine : Literal[0, 1], optional\n        Only return collections created by the user, default 0\n    filters : CollectionsFilters or dict[str, Any], optional\n        CollectionsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CollectionsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `collections` endpoint results.\n    \"\"\"\n    filters = _filters.CollectionsFilters.ensure(\n        filters,\n        name=name,\n        public=public,\n        shared_with_me=shared_with_me,\n        mine=mine,\n    )\n\n    query = Query.ensure(\n        query,\n        id=collection_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"collections\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.companies","title":"<code>companies(name=None, public=0, private=0, brands=None, *, company_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>companies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search companies by name, default None</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public (listed) companies only, default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return private (not listed) companies only, default 0</p> <code>0</code> <code>brands</code> <code>OptionalListOr[int]</code> <p>Fount brand ID or list of brand IDs, default None</p> <p>Only return companies that own the specified brands</p> <code>None</code> <code>company_id</code> <code>int</code> <p>Fount company ID, default None</p> <p>If a company ID is provided, only that company will be returned</p> <code>None</code> <code>filters</code> <code>CompaniesFilters or dict[str, Any]</code> <p>CompaniesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CompaniesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>companies</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def companies(\n    self,\n    name: Optional[str] = None,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    brands: OptionalListOr[int] = None,\n    *,\n    company_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CompaniesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CompaniesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `companies` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search companies by name, default None\n    public: Literal[0, 1], optional\n        Return public (listed) companies only, default 0\n    private: Literal[0, 1], optional\n        Return private (not listed) companies only, default 0\n    brands: int or list[int], optional\n        Fount brand ID or list of brand IDs, default None\n\n        Only return companies that own the specified brands\n    company_id : int, optional\n        Fount company ID, default None\n\n        If a company ID is provided, only that company will be returned\n    filters : CompaniesFilters or dict[str, Any], optional\n        CompaniesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CompaniesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `companies` endpoint results.\n    \"\"\"\n    filters = _filters.CompaniesFilters.ensure(\n        filters,\n        name=name,\n        public=public,\n        private=private,\n        brands=brands,\n    )\n\n    query = Query.ensure(\n        query,\n        id=company_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"companies\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.countries","title":"<code>countries(name=None, active=0, regions=None, with_studies=0, *, country_id=None, with_recent_studies=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>countries</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search countries by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active countries only, default 0</p> <code>0</code> <code>regions</code> <code>OptionalListOr[int]</code> <p>Fount region ID or list of region IDs, default None</p> <code>None</code> <code>with_studies</code> <code>Literal[0, 1]</code> <p>Only return countries which have had a BAV study, default 0</p> <code>0</code> <code>with_recent_studies</code> <code>Optional[int]</code> <p>Years of recency of studies in a specific country, default None</p> <p>Only return countries which have had a BAV study in the past X years</p> <code>None</code> <code>country_id</code> <code>int</code> <p>Fount country ID, default None</p> <p>If a country ID is provided, only that country will be returned</p> <code>None</code> <code>filters</code> <code>CountriesFilters or dict[str, Any]</code> <p>CountriesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CountriesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>countries</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def countries(\n    self,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    regions: OptionalListOr[int] = None,\n    with_studies: Literal[0, 1] = 0,\n    *,\n    country_id: Optional[int] = None,\n    with_recent_studies: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CountriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CountriesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `countries` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search countries by name, default None\n    active : Literal[0, 1], optional\n        Return active countries only, default 0\n    regions: int or list[int], optional\n        Fount region ID or list of region IDs, default None\n    with_studies: Literal[0, 1], optional\n        Only return countries which have had a BAV study, default 0\n    with_recent_studies: int, optional\n        Years of recency of studies in a specific country, default None\n\n        Only return countries which have had a BAV study in the past X years\n    country_id : int, optional\n        Fount country ID, default None\n\n        If a country ID is provided, only that country will be returned\n    filters : CountriesFilters or dict[str, Any], optional\n        CountriesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CountriesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `countries` endpoint results.\n    \"\"\"\n    filters = _filters.CountriesFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        regions=regions,\n        with_studies=with_studies,\n        with_recent_studies=with_recent_studies,\n    )\n\n    query = Query.ensure(\n        query,\n        id=country_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"countries\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.raw_query","title":"<code>raw_query(endpoint, query)</code>  <code>async</code>","text":"<p>Perform a raw GET query to the WPPBAV Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>query</code> <code>Query</code> <p>bavapi.Query object with query parameters.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi/client.py</code> <pre><code>async def raw_query(self, endpoint: str, query: Query[F]) -&gt; List[JSONDict]:\n    \"\"\"Perform a raw GET query to the WPPBAV Fount API, returning\n    the response JSON data instead of a `pandas` DataFrame.\n\n    Parameters\n    ----------\n    endpoint : str\n        Endpoint name\n    query : Query\n        bavapi.Query object with query parameters.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\n    return list(await self._client.query(endpoint, query))\n</code></pre>"},{"location":"reference/client/#client.Client.regions","title":"<code>regions(name=None, *, region_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>regions</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search regions by name, default None</p> <code>None</code> <code>region_id</code> <code>int</code> <p>Fount region ID, default None</p> <p>If a region ID is provided, only that region will be returned</p> <code>None</code> <code>filters</code> <code>RegionsFilters or dict[str, Any]</code> <p>RegionsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[RegionsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>regions</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def regions(\n    self,\n    name: Optional[str] = None,\n    *,\n    region_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.RegionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.RegionsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `regions` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search regions by name, default None\n    region_id : int, optional\n        Fount region ID, default None\n\n        If a region ID is provided, only that region will be returned\n    filters : RegionsFilters or dict[str, Any], optional\n        RegionsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[RegionsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `regions` endpoint results.\n    \"\"\"\n    filters = _filters.RegionsFilters.ensure(\n        filters,\n        name=name,\n    )\n\n    query = Query.ensure(\n        query,\n        id=region_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"regions\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.sectors","title":"<code>sectors(name=None, in_most_influential=0, *, sector_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>sectors</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search sectors by name, default None</p> <code>None</code> <code>in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are part of the Most Influential lists, default 0</p> <code>0</code> <code>sector_id</code> <code>int</code> <p>Fount sectors ID, default None</p> <p>If a sector ID is provided, only that sector will be returned</p> <code>None</code> <code>filters</code> <code>SectorsFilters or dict[str, Any]</code> <p>SectorsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[SectorsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>sectors</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def sectors(\n    self,\n    name: Optional[str] = None,\n    in_most_influential: Literal[0, 1] = 0,\n    *,\n    sector_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.SectorsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.SectorsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `sectors` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search sectors by name, default None\n    in_most_influential : Literal[0, 1], optional\n        Sectors that are part of the Most Influential lists, default 0\n    sector_id : int, optional\n        Fount sectors ID, default None\n\n        If a sector ID is provided, only that sector will be returned\n    filters : SectorsFilters or dict[str, Any], optional\n        SectorsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[SectorsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `sectors` endpoint results.\n    \"\"\"\n    filters = _filters.SectorsFilters.ensure(\n        filters,\n        name=name,\n        in_most_influential=in_most_influential,\n    )\n\n    query = Query.ensure(\n        query,\n        id=sector_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"sectors\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.studies","title":"<code>studies(country_codes=None, year_numbers=None, full_year=0, released=0, bav_study=0, *, study_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>released</code> <code>Literal[0, 1]</code> <p>Return released studies when set to <code>1</code>, default 0</p> <code>0</code> <code>bav_study</code> <code>Literal[0, 1]</code> <p>Return full BAV studies when set to <code>1</code>, default 0</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict[str, Any]</code> <p>StudiesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[StudiesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def studies(\n    self,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    full_year: Literal[0, 1] = 0,\n    released: Literal[0, 1] = 0,\n    bav_study: Literal[0, 1] = 0,\n    *,\n    study_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.StudiesFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `studies` endpoint.\n\n    Parameters\n    ----------\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_numbers : int or list[int], optional\n        Study years, default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, default 0\n\n        A value of 1 will filter non-full-year studies.\n    released : Literal[0, 1], optional\n        Return released studies when set to `1`, default 0\n    bav_study : Literal[0, 1], optional\n        Return full BAV studies when set to `1`, default 0\n    study_id : int, optional\n        Fount study ID, default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict[str, Any], optional\n        StudiesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[StudiesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results.\n    \"\"\"\n    filters = _filters.StudiesFilters.ensure(\n        filters,\n        country_codes=country_codes,\n        year_numbers=year_numbers,\n        full_year=full_year,\n        released=released,\n        bav_study=bav_study,\n    )\n\n    query = Query.ensure(\n        query,\n        id=study_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"studies\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.years","title":"<code>years(year=None, *, year_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>years</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Search years by year number, default None</p> <code>None</code> <code>year_id</code> <code>int</code> <p>Fount year ID, default None</p> <p>If a year ID is provided, only that year will be returned</p> <code>None</code> <code>filters</code> <code>YearsFilters or dict[str, Any]</code> <p>YearsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[YearsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>years</code> endpoint results.</p> Source code in <code>bavapi/client.py</code> <pre><code>async def years(\n    self,\n    year: Optional[int] = None,\n    *,\n    year_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.YearsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.YearsFilters]] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `years` endpoint.\n\n    Parameters\n    ----------\n    year : int, optional\n        Search years by year number, default None\n    year_id : int, optional\n        Fount year ID, default None\n\n        If a year ID is provided, only that year will be returned\n    filters : YearsFilters or dict[str, Any], optional\n        YearsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[YearsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `years` endpoint results.\n    \"\"\"\n    filters = _filters.YearsFilters.ensure(\n        filters,\n        year=year,\n    )\n\n    query = Query.ensure(\n        query,\n        id=year_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"years\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>Exceptions for handling errors with the WPPBAV Fount API.</p>"},{"location":"reference/exceptions/#exceptions.APIError","title":"<code>APIError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception for errors interacting with APIs.</p>"},{"location":"reference/exceptions/#exceptions.DataNotFoundError","title":"<code>DataNotFoundError</code>","text":"<p>             Bases: <code>APIError</code></p> <p>Exception for when the request returns no data.</p>"},{"location":"reference/exceptions/#exceptions.RateLimitExceededError","title":"<code>RateLimitExceededError</code>","text":"<p>             Bases: <code>APIError</code></p> <p>Exception for when the request exceeds the rate limit.</p>"},{"location":"reference/filters/","title":"filters","text":"<p>Filter objects for WPPBAV Fount API queries based on <code>pydantic</code>.</p> <p>All endpoint filters are subclasses of <code>FountFilters</code>.</p> <p>You can use any endpoint filter class with <code>raw_query</code> functions and methods, but you must use endpoint-specific filters for each endpoint function or method.</p> <p>Examples:</p> <p>Use <code>BrandsFilters</code> with the <code>brands</code> endpoint:</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.BrandsFilters(name=\"Facebook\"))\n</code></pre> <p><code>FountFilters</code> is compatible with all endpoints (including <code>raw_query</code>):</p> <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.FountFilters(name=\"Facebook\"))\n</code></pre> <p>Using the wrong filter can lead to unexpected results:</p> <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.CategoriesFilters(country_codes=\"UK\"))\n</code></pre> <p>The above example may work, but it is highly discouraged.</p>"},{"location":"reference/filters/#filters.AudiencesFilters","title":"<code>AudiencesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/audiences for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences only if set to <code>1</code>, default 0</p> <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>private</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences only if set to <code>1</code>, default 0</p> <code>groups</code> <code>(int or list[int], optional)</code> <p>Audience group ID or list of audience group IDs, default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.BrandMetricGroupsFilters","title":"<code>BrandMetricGroupsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brand-metric-groups</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brand-metric-groups for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active brand metrics when set to <code>1</code>, default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive brand metrics when set to <code>1</code>, default 0</p>"},{"location":"reference/filters/#filters.BrandMetricsFilters","title":"<code>BrandMetricsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brand-metrics</code> endpoint.</p> <p><code>groups</code> filters by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brand-metrics for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active brand metrics when set to <code>1</code>, default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive brand metrics when set to <code>1</code>, default 0</p> <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return public brand metrics when set to <code>1</code>, default 0</p> <code>private</code> <code>(Literal[0, 1], optional)</code> <p>Return private brand metrics when set to <code>1</code>, default 0</p> <code>groups</code> <code>(int or list[int], optional)</code> <p>Fount brand metric group ID or list of group IDs, default None</p> <code>current</code> <code>(Literal[0, 1], optional)</code> <p>Return current brand metrics when set to <code>1</code>, default 0</p> <code>legacy</code> <code>(Literal[0, 1], optional)</code> <p>Return legacy brand metrics when set to <code>1</code>, default 0</p> <code>core</code> <code>(Literal[0, 1], optional)</code> <p>Return core brand metrics when set to <code>1</code>, default 0</p> <code>custom</code> <code>(Literal[0, 1], optional)</code> <p>Return custom brand metrics when set to <code>1</code>, default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.BrandsFilters","title":"<code>BrandsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>Filters other than <code>country_codes</code> and <code>year_numbers</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brands for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, default None</p> <code>year_numbers</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), default None</p> <code>categories</code> <code>(int or list[int], optional)</code> <p>Fount category ID or list of category IDs, default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, default None</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, default None</p> <code>sectors</code> <code>(int or list[int], optional)</code> <p>Fount sector ID or list of sector IDs, default None</p> <code>studies</code> <code>(int or list[int], optional)</code> <p>Fount study ID or list of study IDs, default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.BrandscapeFilters","title":"<code>BrandscapeFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>audiences</code>, <code>countries</code>, <code>studies</code>, <code>years</code>, <code>brands</code> and <code>categories</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brandscape-data for more info.</p> <p>The <code>brandscape-data</code> endpoint requires the use of, at minimum, these filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 30 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Attributes:</p> Name Type Description <code>country_code</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, default None</p> <code>year_number</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), default None</p> <code>audiences</code> <code>(int or list[int], optional)</code> <p>Fount ID of the desired audience, default None</p> <p>The <code>Audiences</code> class can help with using audience IDs.</p> <code>brand_name</code> <code>(str, optional)</code> <p>Perform a search on the brand name, default None</p> <code>brands</code> <code>(int or list[int], optional)</code> <p>Fount brand ID or list of brand IDs, default None</p> <code>categories</code> <code>(int or list[int], optional)</code> <p>Fount category ID or list of category IDs, default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, default None</p> <p>The <code>Countries</code> class can help with using country IDs.</p> <code>studies</code> <code>(int or list[int], optional)</code> <p>Fount study ID or list of study IDs, default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.CategoriesFilters","title":"<code>CategoriesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>categories</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/categories for more info.</p> <p>Attributes:</p> Name Type Description <code>sectors</code> <code>(int or list[int], optional)</code> <p>Fount sector ID or list of sector IDs, default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.CitiesFilters","title":"<code>CitiesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>cities</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/cities for more info.</p> <p>Attributes:</p> Name Type Description <code>capitals</code> <code>(Literal[0, 1], optional)</code> <p>Return capitals only, default 0</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, default None</p> <code>in_best_countries</code> <code>(int or list[int], optional)</code> <p>Year number(s) of the Best Countries reports, default None</p> <p>Only return cities that appear in the Best Countries reports for those years</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.CollectionsFilters","title":"<code>CollectionsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>collections</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/collections for more info.</p> <p>Attributes:</p> Name Type Description <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return public collections only, default 0</p> <code>shared_with_me</code> <code>(Literal[0, 1], optional)</code> <p>Only return collections that have been shared with the user, default 0</p> <code>mine</code> <code>(Literal[0, 1], optional)</code> <p>Only return collections created by the user, default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.CompaniesFilters","title":"<code>CompaniesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>companies</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/companies for more info.</p> <p>Attributes:</p> Name Type Description <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return public (listed) companies only, default 0</p> <code>private</code> <code>(Literal[0, 1], optional)</code> <p>Return private (not listed) companies only, default 0</p> <code>brands</code> <code>(int or list[int], optional)</code> <p>Fount brand ID or list of brand IDs, default None</p> <p>Only return companies that own the specified brands</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.CountriesFilters","title":"<code>CountriesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>countries</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/countries for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active countries only, default 0</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, default None</p> <code>with_studies</code> <code>(Literal[0, 1], optional)</code> <p>Only return countries which have had a BAV study, default 0</p> <code>with_recent_studies</code> <code>(int, optional)</code> <p>Years of recency of studies in a specific country, default None</p> <p>Only return countries which have had a BAV study in the past X years</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.FountFilters","title":"<code>FountFilters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base class for Fount API Filters.</p> <p>Can be used with <code>raw_query</code> endpoints.</p> <p>Attributes:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime, optional)</code> <p>Request items that have been updated since the specified date, default None</p> <code>**kwargs</code> <code>str, int or float, or list of str, int or floats, optional</code> <p>Any additional filters to apply to the request, including for columns within the response data.</p>"},{"location":"reference/filters/#filters.FountFilters.ensure","title":"<code>ensure(filters, **addl_filters)</code>  <code>classmethod</code>","text":"<p>Ensure <code>FountFilters</code> class from dictionary or other <code>FountFilters</code> class.</p> <p>Defaults to values passed to <code>filters</code> when any additional filters overlap.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FountFilters or dict of filter values</code> <p>Dictionary of filters or <code>FountFilters</code> class.</p> required <code>**addl_filters</code> <code>SequenceOrValues</code> <p>Additional filters to add to the new <code>FountFilters</code> instance.</p> <code>{}</code> <p>Returns:</p> Type Description <code>(FountFilters, optional)</code> <p><code>FountFilters</code> class or <code>None</code> if <code>filters</code> is <code>None</code> and no additional filters are passed.</p> Source code in <code>bavapi/filters.py</code> <pre><code>@classmethod\ndef ensure(\n    cls: Type[F],\n    filters: Optional[FiltersOrMapping[\"FountFilters\"]],\n    **addl_filters: InputSequenceOrValues,\n) -&gt; Optional[F]:\n    \"\"\"Ensure `FountFilters` class from dictionary or other `FountFilters` class.\n\n    Defaults to values passed to `filters` when any additional filters overlap.\n\n    Parameters\n    ----------\n    filters : FountFilters or dict of filter values, optional\n        Dictionary of filters or `FountFilters` class.\n    **addl_filters : SequenceOrValues, optional\n        Additional filters to add to the new `FountFilters` instance.\n\n    Returns\n    -------\n    FountFilters, optional\n        `FountFilters` class or `None` if `filters` is `None`\n        and no additional filters are passed.\n    \"\"\"\n    new_filters: Dict[str, InputSequenceOrValues] = {\n        k: v for k, v in addl_filters.items() if v\n    }\n\n    if filters is None:\n        if not new_filters:\n            return None\n        return cls(**new_filters)  # type: ignore[arg-type]\n\n    if isinstance(filters, FountFilters):\n        if not new_filters:\n            return cls(**filters.model_dump(exclude_defaults=True))\n        new_filters.update(filters.model_dump(exclude_defaults=True))\n    else:\n        new_filters.update(filters)\n\n    return cls(**new_filters)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/filters/#filters.RegionsFilters","title":"<code>RegionsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>regions</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/regions for more info.</p> <p>There are currently no specific filters for the <code>regions</code> endpoint</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.SectorsFilters","title":"<code>SectorsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>sectors</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/sectors for more info.</p> <p>Attributes:</p> Name Type Description <code>in_most_influential</code> <code>(Literal[0, 1], optional)</code> <p>Sectors that are part of the Most Influential lists, default 0</p> <code>not_in_most_influential</code> <code>(Literal[0, 1], optional)</code> <p>Sectors that are not part of the Most Influential lists, default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.StudiesFilters","title":"<code>StudiesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>years</code>, <code>countries</code> and <code>regions</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/studies for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, default None</p> <code>year_numbers</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), default None</p> <code>full_year</code> <code>(Literal[0, 1], optional)</code> <p>Return full year studies when set to <code>1</code> (excludes US quarterly), default 0</p> <code>released</code> <code>(Literal[0, 1], optional)</code> <p>Return released studies when set to <code>1</code>, default 0</p> <code>unreleased</code> <code>(Literal[0, 1], optional)</code> <p>Return unreleased studies when set to <code>1</code>, default 0</p> <code>open_survey</code> <code>(Literal[0, 1], optional)</code> <p>Return studies with open brand requests when set to <code>1</code>, default 0</p> <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences when set to <code>1</code>, default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences when set to <code>1</code>, default 0</p> <code>bav_study</code> <code>(Literal[0, 1], optional)</code> <p>Return full BAV studies when set to <code>1</code>, default 0</p> <code>data_updated_since</code> <code>(DTValues, optional)</code> <p>Return studies updated since datetime value, default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, default None</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/filters/#filters.YearsFilters","title":"<code>YearsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>years</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/years for more info.</p> <p>There are currently no specific filters for the <code>years</code> endpoint</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, default None</p>"},{"location":"reference/http/","title":"http","text":"<p>Class for interacting with paginated APIs over HTTP.</p>"},{"location":"reference/http/#http.HTTPClient","title":"<code>HTTPClient(base_url='', per_page=100, timeout=5.0, verify=True, *, headers=None, client=None, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn')</code>","text":"<p>HTTP client for interacting with paginated API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the API.</p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 5.0</p> <code>5.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>headers</code> <code>dict[str, str]</code> <p>Collection of headers to send with each request, default None</p> <code>None</code> <code>client</code> <code>AsyncClient</code> <p>Authenticated <code>httpx.AsyncClient</code>, default None</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> Source code in <code>bavapi/http.py</code> <pre><code>def __init__(\n    self,\n    base_url: str = \"\",\n    per_page: int = 100,\n    timeout: float = 5.0,\n    verify: Union[bool, str] = True,\n    *,\n    headers: Optional[Dict[str, str]] = None,\n    client: Optional[httpx.AsyncClient] = None,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n) -&gt; None:\n    self.per_page = per_page\n    self.verbose = verbose\n    self.batch_size = batch_size\n    self.n_workers = n_workers\n    self.retries = retries\n    self.on_errors: Literal[\"warn\", \"raise\"] = on_errors\n\n    self.client = client or httpx.AsyncClient(\n        headers=headers,\n        timeout=timeout,\n        verify=verify,\n        base_url=base_url,\n    )\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Asynchronously close all client connections.</p> Source code in <code>bavapi/http.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Asynchronously close all client connections.\"\"\"\n    return await self.client.aclose()\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get","title":"<code>get(endpoint, query)</code>  <code>async</code>","text":"<p>Perform GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>query</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Requested response object.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If request fails.</p> Source code in <code>bavapi/http.py</code> <pre><code>async def get(self, endpoint: str, query: _Query) -&gt; httpx.Response:\n    \"\"\"Perform GET request on the given endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    query : Query\n        Request parameters.\n\n    Returns\n    -------\n    httpx.Response\n        Requested response object.\n\n    Raises\n    ------\n    APIError\n        If request fails.\n    \"\"\"\n    url = f\"{endpoint}/{query.item_id}\" if query.item_id is not None else endpoint\n\n    resp = await self.client.get(url, params=query.to_params(endpoint))\n\n    if resp.status_code != 200:\n        try:\n            message = resp.json()[\"message\"]\n        except (KeyError, JSONDecodeError):\n            message = \"An error occurred with the Fount.\"\n\n        raise APIError(f\"Error {resp.status_code}:\\n{message}\\nurl={resp.url}\")\n\n    return resp\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get_pages","title":"<code>get_pages(endpoint, query, n_pages)</code>  <code>async</code>","text":"<p>Perform GET requests for a given number of pages on an endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>query</code> <code>Query</code> <p>Request parameters.</p> required <code>n_pages</code> <code>int</code> <p>Number of pages to request.</p> required <p>Returns:</p> Type Description <code>list[Response]</code> <p>List of response objects.</p> Source code in <code>bavapi/http.py</code> <pre><code>async def get_pages(\n    self,\n    endpoint: str,\n    query: _Query,\n    n_pages: int,\n) -&gt; List[httpx.Response]:\n    \"\"\"Perform GET requests for a given number of pages on an endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    query : Query\n        Request parameters.\n    n_pages : int\n        Number of pages to request.\n\n    Returns\n    -------\n    list[httpx.Response]\n        List of response objects.\n    \"\"\"\n    get_func = aretry(self.get, self.retries, delay=0.25)\n    queue: asyncio.Queue[Iterable[_Query]] = asyncio.Queue()\n\n    for batch in batched(query.paginated(n_pages), self.batch_size):\n        queue.put_nowait(batch)\n\n    pbar = tqdm(desc=f\"{endpoint} query\", total=n_pages) if self.verbose else None\n    try:\n        fetcher: PageFetcher[httpx.Response] = PageFetcher(pbar, self.on_errors)\n\n        workers = [\n            asyncio.create_task(fetcher.worker(get_func, endpoint, queue))\n            for _ in range(self.n_workers)\n        ]\n\n        await asyncio.gather(*workers)\n    finally:\n        if pbar:\n            pbar.close()\n\n    fetcher.warn_if_errors()\n\n    return fetcher.results\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.query","title":"<code>query(endpoint, query)</code>  <code>async</code>","text":"<p>Perform a paginated GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>query</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>Iterator[JSONDict]</code> <p>An iterator of JSONDict objects.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If any request fails.</p> <code>DataNotFoundError</code> <p>If response data is empty.</p> <code>RateLimitExceededError</code> <p>If response would exceed the rate limit.</p> Source code in <code>bavapi/http.py</code> <pre><code>async def query(\n    self,\n    endpoint: str,\n    query: _Query,\n) -&gt; Iterator[JSONDict]:\n    \"\"\"Perform a paginated GET request on the given endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    query : Query\n        Request parameters.\n\n    Returns\n    -------\n    Iterator[JSONDict]\n        An iterator of JSONDict objects.\n\n    Raises\n    ------\n    APIError\n        If any request fails.\n    DataNotFoundError\n        If response data is empty.\n    RateLimitExceededError\n        If response would exceed the rate limit.\n    \"\"\"\n    per_page = query.per_page or self.per_page\n    init_per_page = per_page if query.is_single_page() else 1\n    handshake_func = aretry(self.get, self.retries, 0.25, (ssl.SSLError,))\n    resp = await handshake_func(endpoint, query.with_page(per_page=init_per_page))\n\n    payload: Dict[str, JSONData] = resp.json()\n    data: JSONData = payload[\"data\"]\n\n    if not data:\n        raise DataNotFoundError(\"Your query returned no results.\")\n\n    if isinstance(data, dict):\n        return iter((data,))\n\n    meta = cast(JSONDict, payload[\"meta\"])\n    total = cast(int, meta[\"total\"])\n\n    if query.is_single_page() or len(data) == total:\n        return iter(data)\n\n    n_pages = _calculate_pages(query.page, per_page, query.max_pages, total)\n\n    if n_pages &gt; (limit_remaining := int(resp.headers[\"x-ratelimit-remaining\"])):\n        raise RateLimitExceededError(\n            f\"Number of pages ({n_pages}) for this request \"\n            f\"exceeds the rate limit ({limit_remaining}, \"\n            f\"total={resp.headers['x-ratelimit-limit']}).\"\n        )\n\n    pages = await self.get_pages(\n        endpoint, query.with_page(per_page=per_page), n_pages\n    )\n\n    return (i for page in pages for i in page.json()[\"data\"])\n</code></pre>"},{"location":"reference/query/","title":"query","text":"<p>Query objects for Fount API queries based on <code>pydantic</code>.</p>"},{"location":"reference/query/#query.Query","title":"<code>Query</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[F]</code></p> <p>Base WPPBAV Fount query.</p> <p>Attributes:</p> Name Type Description <code>item_id</code> <code>(int, optional)</code> <p>Get specific resource by ID, default None</p> <p>Can also be set with <code>id</code>.</p> <code>filters</code> <code>FountFilters instance or dict of filter values, optional</code> <p>Filters to apply to the query, default None</p> <code>fields</code> <code>(str or list[str], optional)</code> <p>Specific fields to retrieve from the query, default None</p> <code>include</code> <code>(str or list[str], optional)</code> <p>Additional resources to retrieve from the query, default None</p> <code>metric_keys</code> <code>(str or list[str], optional)</code> <p>Key or list of keys for the metrics included in the response, default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>metric_group_keys</code> <code>(str or list[str], optional)</code> <p>Key or list of keys for the metric groups included in the response, default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>sort</code> <code>(str, optional)</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name: <code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID default.</p> <code>page</code> <code>(int, optional)</code> <p>Get specific page from paginated response, default None</p> <p>When None, the default value in the Fount is 1</p> <p>Must be greater than 0</p> <code>per_page</code> <code>(int, optional)</code> <p>Number of items per page, default None</p> <p>When None, the default value in the Fount is 25</p> <p>When performing paged queries, Client uses 100 as the default <code>per_page</code>.</p> <p>Must be greater than 0</p> <code>max_pages</code> <code>(int, optional)</code> <p>Maximum number of pages to retrieve, default None</p> <p>When None, all pages will be retrieved with a <code>per_page</code> value of 100 default.</p> <p>Must be greater than 0</p>"},{"location":"reference/query/#query.Query.ensure","title":"<code>ensure(query=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Ensure <code>Query</code> instance with possible additional parameters.</p> <p>Defaults to parameters passed in <code>query</code> instance when any additional parameters overlap.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>Query object to combine with additional parameters, default None</p> <code>None</code> <code>**kwargs</code> <code>SequenceOrValues</code> <p>Additional parameters to add to the new <code>Query</code> instance.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Query</code> <p><code>Query</code> class with additional parameters added if any</p> Source code in <code>bavapi/query.py</code> <pre><code>@classmethod\ndef ensure(\n    cls, query: \"Optional[Query[F]]\" = None, **kwargs: QueryParamValues[F]\n) -&gt; \"Query[F]\":\n    \"\"\"Ensure `Query` instance with possible additional parameters.\n\n    Defaults to parameters passed in `query` instance when any additional\n    parameters overlap.\n\n    Parameters\n    ----------\n    query : Query, optional\n        Query object to combine with additional parameters, default None\n    **kwargs : SequenceOrValues, optional\n        Additional parameters to add to the new `Query` instance.\n\n    Returns\n    -------\n    Query\n        `Query` class with additional parameters added if any\n    \"\"\"\n    params: MutableMapping[str, QueryParamValues[F]] = {\n        k: v for k, v in kwargs.items() if v\n    }\n\n    if query is None:\n        return cls(**params)  # type: ignore[arg-type]\n\n    params.update(query.model_dump(exclude={\"filters\"}, exclude_defaults=True))\n    params.update({\"filters\": query.filters})\n\n    return cls(**params)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/query/#query.Query.is_single_page","title":"<code>is_single_page()</code>","text":"<p>Returns True if the query only would request a single page</p> <p>Otherwise the query will perform multiple paginated requests</p> <p>Conditions for being a single page:</p> <ul> <li>self.max_pages is <code>1</code> OR</li> <li>self.per_page is not <code>None</code> or <code>0</code>   AND (self.max_pages OR self.per_page) are not <code>None</code> or <code>0</code></li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the query would perform a single page request</p> Source code in <code>bavapi/query.py</code> <pre><code>def is_single_page(self) -&gt; bool:\n    \"\"\"Returns True if the query only would request a single page\n\n    Otherwise the query will perform multiple paginated requests\n\n    Conditions for being a single page:\n\n    - self.max_pages is `1` OR\n    - self.per_page is not `None` or `0`\n      AND (self.max_pages OR self.per_page) are not `None` or `0`\n\n    Returns\n    -------\n    bool\n        Whether the query would perform a single page request\n    \"\"\"\n    return self.max_pages == 1 or (\n        bool(self.page) and not (self.per_page or self.max_pages)\n    )\n</code></pre>"},{"location":"reference/query/#query.Query.paginated","title":"<code>paginated(n_pages, per_page=None)</code>","text":"<p>Yield <code>Query</code> instances with page parameters for each page in <code>n_pages</code>.</p> <p>For performing multiple paginated requests.</p> <p>Parameters:</p> Name Type Description Default <code>n_pages</code> <code>int</code> <p>Number of pages for which to generate paginated <code>Query</code> instances</p> required <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Query</code> <p>Query instances with page parameters set.</p> Source code in <code>bavapi/query.py</code> <pre><code>def paginated(\n    self, n_pages: int, per_page: Optional[int] = None\n) -&gt; Iterator[\"Query[F]\"]:\n    \"\"\"Yield `Query` instances with page parameters for each page in `n_pages`.\n\n    For performing multiple paginated requests.\n\n    Parameters\n    ----------\n    n_pages : int\n        Number of pages for which to generate paginated `Query` instances\n    per_page : int, optional\n        Number of results per page, default None\n    Yields\n    ------\n    Query\n        Query instances with page parameters set.\n    \"\"\"\n    start_page = self.page or 1\n    yield from (\n        self.with_page(p, per_page or self.per_page)\n        for p in range(start_page, n_pages + start_page)\n    )\n</code></pre>"},{"location":"reference/query/#query.Query.to_params","title":"<code>to_params(endpoint)</code>","text":"<p>Return Fount-compatible dictionary of the query.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint for which to format the query</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount-compatible dictionary of the query.</p> Source code in <code>bavapi/query.py</code> <pre><code>def to_params(self, endpoint: str) -&gt; BaseParamsDictValues:\n    \"\"\"Return Fount-compatible dictionary of the query.\n\n    Parameters\n    ----------\n    endpoint : str\n        The endpoint for which to format the query\n\n    Returns\n    -------\n    dict[str, Any]\n        Fount-compatible dictionary of the query.\n    \"\"\"\n    exclude: Final[Set[str]] = {\"item_id\", \"filters\", \"fields\", \"max_pages\"}\n\n    filters: BaseParamsMapping = {}\n    fields: BaseMutableParamsMapping = {}\n\n    if isinstance(self.filters, _filters.FountFilters):\n        filters = self.filters.model_dump(by_alias=True, exclude_defaults=True)\n    elif self.filters is not None:\n        filters = cast(BaseParamsDict, self.filters)\n    filters = to_fount_params(filters, \"filter\")\n    fields = to_fount_params(\n        {endpoint.replace(\"-\", \"_\"): self.fields} if self.fields else fields,\n        \"fields\",\n    )\n\n    params = {\n        **self.model_dump(exclude=exclude, by_alias=True, exclude_defaults=True),\n        **filters,\n        **fields,\n    }\n\n    return cast(BaseParamsDictValues, list_to_str(params))\n</code></pre>"},{"location":"reference/query/#query.Query.with_page","title":"<code>with_page(page=None, per_page=None, max_pages=None)</code>","text":"<p>Create new instance of <code>Query</code> with overridden page parameters.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Current page number, default None</p> <code>None</code> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>None</code> <code>max_pages</code> <code>int</code> <p>Max number of pages requested, default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Query</code> <p>New <code>Query</code> instance with page parameters.</p> Source code in <code>bavapi/query.py</code> <pre><code>def with_page(\n    self,\n    page: Optional[int] = None,\n    per_page: Optional[int] = None,\n    max_pages: Optional[int] = None,\n) -&gt; \"Query[F]\":\n    \"\"\"Create new instance of `Query` with overridden page parameters.\n\n    Parameters\n    ----------\n    page : int, optional\n        Current page number, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of pages requested, default None\n\n    Returns\n    -------\n    Query\n        New `Query` instance with page parameters.\n    \"\"\"\n    fields_set = {\n        name\n        for name, val in (\n            (\"page\", page),\n            (\"per_page\", per_page),\n            (\"max_pages\", max_pages),\n        )\n        if val\n    }\n    return self.__class__.model_construct(\n        self.model_fields_set.union(fields_set),  # pylint: disable=no-member\n        page=page or self.page,\n        per_page=per_page or self.per_page,\n        max_pages=max_pages or self.max_pages,\n        filters=self.filters,  # avoid turning filters into dictionary\n        **self.model_dump(\n            by_alias=True,\n            exclude={\"page\", \"per_page\", \"max_pages\", \"filters\"},\n            exclude_defaults=True,\n        ),\n    )\n</code></pre>"},{"location":"reference/sync/","title":"sync","text":"<p>Top level functions to perform queries to the Fount.</p> <p>You will need your BAV API token to use these functions.</p> <p>Examples:</p> <p>Use top level functions for one-off downloads:</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; result = bavapi.brands(\"TOKEN\", \"Facebook\")  # Replace TOKEN with your API key\n</code></pre> <p>A more complex query:</p> <pre><code>&gt;&gt;&gt; from bavapi_refs import Audiences\n&gt;&gt;&gt; bss = bavapi.brandscape_data(\n...     \"TOKEN\",  # Replace TOKEN with your API key\n...     country_code=\"UK\",\n...     year_number=2022,\n...     audiences=Audiences.ALL_ADULTS,\n... )\n</code></pre> <p>Use <code>bavapi.raw_query</code> (with <code>bavapi.Query</code>) for endpoints that aren't fully supported:</p> <pre><code>&gt;&gt;&gt; query = bavapi.Query(filters=bavapi.filters.FountFilters(name=\"Meta\"))\n&gt;&gt;&gt; result = bavapi.raw_query(\"companies\", query=query)\n</code></pre> <p>If you want to make multiple requests or embed <code>bavapi</code> into applications, consider using the <code>bavapi.Client</code> interface.</p>"},{"location":"reference/sync/#sync.audiences","title":"<code>audiences(token, name=None, active=0, public=0, *, audience_id=None, private=0, groups=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search audiences by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict[str, Any]</code> <p>AudiencesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[AudiencesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>audiences</code> endpoint results</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def audiences(\n    token: str,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    *,\n    audience_id: Optional[int] = None,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.AudiencesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `audiences` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search audiences by name, default None\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, default 0\n    audience_id : int, optional\n        Fount audience ID, default None\n\n        If an audience ID is provided, only that audience will be returned\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, default None\n    filters : AudiencesFilters or dict[str, Any], optional\n        AudiencesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[AudiencesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `audiences` endpoint results\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.audiences(\n            name,\n            active,\n            public,\n            audience_id=audience_id,\n            private=private,\n            groups=groups,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brand_metric_groups","title":"<code>brand_metric_groups(token, name=None, active=0, *, group_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metric-groups</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brand metric groups by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metric groups only if set to <code>1</code>, default 0</p> <code>0</code> <code>group_id</code> <code>int</code> <p>Fount brand metric group ID, default None</p> <p>If a metric group ID is provided, only that metric group will be returned</p> <code>None</code> <code>filters</code> <code>BrandMetricGroupsFilters or dict[str, Any]</code> <p>BrandMetricGroupsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandMetricGroupsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metric-groups</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def brand_metric_groups(\n    token: str,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    *,\n    group_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricGroupsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandMetricGroupsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metric-groups` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brand metric groups by name, default None\n    active : Literal[0, 1], optional\n        Return active brand metric groups only if set to `1`, default 0\n    group_id : int, optional\n        Fount brand metric group ID, default None\n\n        If a metric group ID is provided, only that metric group will be returned\n    filters : BrandMetricGroupsFilters or dict[str, Any], optional\n        BrandMetricGroupsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandMetricGroupsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metric-groups` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.brand_metric_groups(\n            name,\n            active,\n            group_id=group_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brand_metrics","title":"<code>brand_metrics(token, name=None, active=0, public=0, *, metric_id=None, private=0, groups=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metrics</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brand metrics by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>metric_id</code> <code>int</code> <p>Fount metric ID, default None</p> <p>If a metric ID is provided, only that metric will be returned</p> <code>None</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Brand metrics group ID or list of brand metrics group IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandMetricsFilters or dict[str, Any]</code> <p>BrandMetricsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandMetricsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metrics</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def brand_metrics(\n    token: str,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    *,\n    metric_id: Optional[int] = None,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandMetricsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metrics` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brand metrics by name, default None\n    active : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, default 0\n    public : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, default 0\n    metric_id : int, optional\n        Fount metric ID, default None\n\n        If a metric ID is provided, only that metric will be returned\n    private : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, default 0\n    groups : int or list[int], optional\n        Brand metrics group ID or list of brand metrics group IDs, default None\n    filters : BrandMetricsFilters or dict[str, Any], optional\n        BrandMetricsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandMetricsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metrics` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.brand_metrics(\n            name,\n            active,\n            public,\n            metric_id=metric_id,\n            private=private,\n            groups=groups,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brands","title":"<code>brands(token, name=None, country_codes=None, year_numbers=None, *, brand_id=None, studies=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brands by name, default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict[str, Any]</code> <p>BrandsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[BrandsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def brands(\n    token: str,\n    name: Optional[str] = None,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    *,\n    brand_id: Optional[int] = None,\n    studies: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brands` endpoint\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brands by name, default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_numbers : int or list[int], optional\n        Study years, default None\n    brand_id : int, optional\n        Fount brand ID, default None\n\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, default None\n    filters : BrandsFilters or dict[str, Any], optional\n        BrandsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[BrandsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.brands(\n            name,\n            country_codes,\n            year_numbers,\n            brand_id=brand_id,\n            studies=studies,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brandscape_data","title":"<code>brandscape_data(token, country_code=None, year_number=None, audiences=None, brand_name=None, *, studies=None, filters=None, fields=None, include=None, metric_keys=None, metric_group_keys=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of parameters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 100 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>Also note that due to a name clash in the \"brand\" <code>include</code>, brand columns will be prefixed with <code>\"global_\"</code>. Thus, these columns will refer to the global brand, while the <code>brand_name</code> column will refer to the local brand/spelling.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict[str, Any]</code> <p>BrandscapeFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, default None</p> <code>None</code> <code>metric_group_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metric groups included in the response, default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>None</code> <code>query</code> <code>Query[BrandscapeFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def brandscape_data(\n    token: str,\n    country_code: OptionalListOr[str] = None,\n    year_number: OptionalListOr[int] = None,\n    audiences: OptionalListOr[int] = None,\n    brand_name: Optional[str] = None,\n    *,\n    studies: OptionalListOr[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    metric_keys: OptionalListOr[str] = None,\n    metric_group_keys: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.BrandscapeFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brandscape-data` endpoint.\n\n    This endpoint requires at least one of the following combinations of parameters:\n\n    - Study + Audience + Brand + Category\n    - Country + Year + Audience\n    - Brand + Audience + Country + Year\n\n    You should read these from left to right. A combination of \"Study + Audience\"\n    worksjust as well as \"Study + Audience + Brand\".\n    However, \"Category + Audience\" will not.\n\n    If you use Country or Year filters, you must use both filters together.\n\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 100 standard audiences).\n\n    The `Audiences` class is provided to make it easier to filter audiences.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n\n    Any additional valid includes will be added to the default set.\n\n    Also note that due to a name clash in the \"brand\" `include`, brand columns\n    will be prefixed with `\"global_\"`. Thus, these columns will refer to the global\n    brand, while the `brand_name` column will refer to the local brand/spelling.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_number : int or list[int], optional\n        Study years, default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, default None\n\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, default None\n    studies : int or list[int], optional\n        Fount studies IDs, default None\n    filters : BrandscapeFilters or dict[str, Any], optional\n        BrandscapeFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, default None\n    metric_group_keys: str or list[str], optional\n        Key or list of keys for the metric groups included in the response, default None\n\n        Currently, this parameter is only available for the `brandscape-data` endpoint.\n    query : Query[BrandscapeFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results\n\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.brandscape_data(\n            country_code,\n            year_number,\n            audiences,\n            brand_name,\n            studies=studies,\n            filters=filters,\n            fields=fields,\n            metric_keys=metric_keys,\n            metric_group_keys=metric_group_keys,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.categories","title":"<code>categories(token, name=None, sectors=None, *, category_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>categories</code> endpoint.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>sector</code></p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search categories by name, default None</p> <code>None</code> <code>sectors</code> <code>int or list[int]</code> <p>Filter categories by sector ID, default 0</p> <code>None</code> <code>category_id</code> <code>int</code> <p>Fount category ID, default None</p> <p>If a category ID is provided, only that category will be returned</p> <code>None</code> <code>filters</code> <code>CategoriesFilters or dict[str, Any]</code> <p>CategoriesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CategoriesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>categories</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def categories(\n    token: str,\n    name: Optional[str] = None,\n    sectors: OptionalListOr[int] = None,\n    *,\n    category_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CategoriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CategoriesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `categories` endpoint.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `sector`\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search categories by name, default None\n    sectors : int or list[int], optional\n        Filter categories by sector ID, default 0\n    category_id : int, optional\n        Fount category ID, default None\n\n        If a category ID is provided, only that category will be returned\n    filters : CategoriesFilters or dict[str, Any], optional\n        CategoriesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CategoriesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `categories` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.categories(\n            name,\n            sectors,\n            category_id=category_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.cities","title":"<code>cities(token, name=None, capitals=0, countries=None, in_best_countries=None, *, city_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>cities</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search cities by name, default None</p> <code>None</code> <code>capitals</code> <code>Literal[0, 1]</code> <p>Return capitals only, default 0</p> <code>0</code> <code>countries</code> <code>OptionalListOr[int]</code> <p>Fount country ID or list of country IDs, default None</p> <code>None</code> <code>in_best_countries</code> <code>OptionalListOr[int]</code> <p>Year number(s) of the Best Countries reports, default None</p> <p>Only return cities that appear in the Best Countries reports for those years</p> <code>None</code> <code>city_id</code> <code>int</code> <p>Fount city ID, default None</p> <p>If a city ID is provided, only that city will be returned</p> <code>None</code> <code>filters</code> <code>CitiesFilters or dict[str, Any]</code> <p>CitiesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CitiesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>cities</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def cities(\n    token: str,\n    name: Optional[str] = None,\n    capitals: Literal[0, 1] = 0,\n    countries: OptionalListOr[int] = None,\n    in_best_countries: OptionalListOr[int] = None,\n    *,\n    city_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CitiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CitiesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `cities` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search cities by name, default None\n    capitals: Literal[0, 1], optional\n        Return capitals only, default 0\n    countries: int or list[int], optional\n        Fount country ID or list of country IDs, default None\n    in_best_countries: int or list[int], optional\n        Year number(s) of the Best Countries reports, default None\n\n        Only return cities that appear in the Best Countries reports for those years\n    city_id : int, optional\n        Fount city ID, default None\n\n        If a city ID is provided, only that city will be returned\n    filters : CitiesFilters or dict[str, Any], optional\n        CitiesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CitiesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `cities` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.cities(\n            name,\n            capitals,\n            countries,\n            in_best_countries,\n            city_id=city_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.collections","title":"<code>collections(token, name=None, public=0, *, collection_id=None, shared_with_me=0, mine=0, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>collections</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search collections by name, default None</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public collections only if set to <code>1</code>, default 0</p> <code>0</code> <code>collection_id</code> <code>int</code> <p>Fount collection ID, default None</p> <p>If a collection ID is provided, only that collection will be returned</p> <code>None</code> <code>shared_with_me</code> <code>Literal[0, 1]</code> <p>Only return collections that have been shared with the user, default 0</p> <code>0</code> <code>mine</code> <code>Literal[0, 1]</code> <p>Only return collections created by the user, default 0</p> <code>0</code> <code>filters</code> <code>CollectionsFilters or dict[str, Any]</code> <p>CollectionsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CollectionsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>collections</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def collections(\n    token: str,\n    name: Optional[str] = None,\n    public: Literal[0, 1] = 0,\n    *,\n    collection_id: Optional[int] = None,\n    shared_with_me: Literal[0, 1] = 0,\n    mine: Literal[0, 1] = 0,\n    filters: OptionalFiltersOrMapping[_filters.CollectionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CollectionsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `collections` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search collections by name, default None\n    public : Literal[0, 1], optional\n        Return public collections only if set to `1`, default 0\n    collection_id : int, optional\n        Fount collection ID, default None\n\n        If a collection ID is provided, only that collection will be returned\n    shared_with_me : Literal[0, 1], optional\n        Only return collections that have been shared with the user, default 0\n    mine : Literal[0, 1], optional\n        Only return collections created by the user, default 0\n    filters : CollectionsFilters or dict[str, Any], optional\n        CollectionsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CollectionsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `collections` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.collections(\n            name,\n            public,\n            collection_id=collection_id,\n            shared_with_me=shared_with_me,\n            mine=mine,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.companies","title":"<code>companies(token, name=None, public=0, private=0, brands=None, *, company_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>countries</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search companies by name, default None</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public (listed) companies only, default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return private (not listed) companies only, default 0</p> <code>0</code> <code>brands</code> <code>OptionalListOr[int]</code> <p>Fount brand ID or list of brand IDs, default None</p> <p>Only return companies that own the specified brands</p> <code>None</code> <code>company_id</code> <code>int</code> <p>Fount company ID, default None</p> <p>If a company ID is provided, only that company will be returned</p> <code>None</code> <code>filters</code> <code>CompaniesFilters or dict[str, Any]</code> <p>CompaniesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CompaniesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>companies</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def companies(\n    token: str,\n    name: Optional[str] = None,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    brands: OptionalListOr[int] = None,\n    *,\n    company_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CompaniesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CompaniesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `countries` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search companies by name, default None\n    public: Literal[0, 1], optional\n        Return public (listed) companies only, default 0\n    private: Literal[0, 1], optional\n        Return private (not listed) companies only, default 0\n    brands: int or list[int], optional\n        Fount brand ID or list of brand IDs, default None\n\n        Only return companies that own the specified brands\n    company_id : int, optional\n        Fount company ID, default None\n\n        If a company ID is provided, only that company will be returned\n    filters : CompaniesFilters or dict[str, Any], optional\n        CompaniesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CompaniesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `companies` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.companies(\n            name,\n            public,\n            private,\n            brands,\n            company_id=company_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.countries","title":"<code>countries(token, name=None, active=0, regions=None, with_studies=0, *, country_id=None, with_recent_studies=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>countries</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search countries by name, default None</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active countries only, default 0</p> <code>0</code> <code>regions</code> <code>OptionalListOr[int]</code> <p>Fount region ID or list of region IDs, default None</p> <code>None</code> <code>with_studies</code> <code>Literal[0, 1]</code> <p>Only return countries which have had a BAV study, default 0</p> <code>0</code> <code>country_id</code> <code>int</code> <p>Fount country ID, default None</p> <p>If a country ID is provided, only that country will be returned</p> <code>None</code> <code>with_recent_studies</code> <code>Optional[int]</code> <p>Years of recency of studies in a specific country, default None</p> <p>Only return countries which have had a BAV study in the past X years</p> <code>None</code> <code>filters</code> <code>CountriesFilters or dict[str, Any]</code> <p>CountriesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[CountriesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>countries</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def countries(\n    token: str,\n    name: Optional[str] = None,\n    active: Literal[0, 1] = 0,\n    regions: OptionalListOr[int] = None,\n    with_studies: Literal[0, 1] = 0,\n    *,\n    country_id: Optional[int] = None,\n    with_recent_studies: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.CountriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.CountriesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `countries` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search countries by name, default None\n    active : Literal[0, 1], optional\n        Return active countries only, default 0\n    regions: int or list[int], optional\n        Fount region ID or list of region IDs, default None\n    with_studies: Literal[0, 1], optional\n        Only return countries which have had a BAV study, default 0\n    country_id : int, optional\n        Fount country ID, default None\n\n        If a country ID is provided, only that country will be returned\n    with_recent_studies: int, optional\n        Years of recency of studies in a specific country, default None\n\n        Only return countries which have had a BAV study in the past X years\n    filters : CountriesFilters or dict[str, Any], optional\n        CountriesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[CountriesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `countries` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.countries(\n            name,\n            active,\n            regions,\n            with_studies,\n            country_id=country_id,\n            with_recent_studies=with_recent_studies,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.raw_query","title":"<code>raw_query(token, endpoint, query, *, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn')</code>  <code>async</code>","text":"<p>Perform a raw GET query to the Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>query</code> <code>Query</code> <p>bavapi.Query object with query parameters.</p> required <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def raw_query(\n    token: str,\n    endpoint: str,\n    query: Query[F],\n    *,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n) -&gt; List[JSONDict]:\n    \"\"\"Perform a raw GET query to the Fount API, returning the response JSON data\n    instead of a `pandas` DataFrame.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    endpoint : str\n        Endpoint name\n    query : Query\n        bavapi.Query object with query parameters.\n    timeout : float\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.raw_query(endpoint, query)\n</code></pre>"},{"location":"reference/sync/#sync.regions","title":"<code>regions(token, name=None, *, region_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>regions</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search regions by name, default None</p> <code>None</code> <code>region_id</code> <code>int</code> <p>Fount region ID, default None</p> <p>If a region ID is provided, only that region will be returned</p> <code>None</code> <code>filters</code> <code>RegionsFilters or dict[str, Any]</code> <p>RegionsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[RegionsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>regions</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def regions(\n    token: str,\n    name: Optional[str] = None,\n    *,\n    region_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.RegionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.RegionsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `regions` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search regions by name, default None\n    region_id : int, optional\n        Fount region ID, default None\n\n        If a region ID is provided, only that region will be returned\n    filters : RegionsFilters or dict[str, Any], optional\n        RegionsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[RegionsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `regions` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.regions(\n            name,\n            region_id=region_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.sectors","title":"<code>sectors(token, name=None, in_most_influential=0, *, sector_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>sectors</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search categories by name, default None</p> <code>None</code> <code>in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are part of the Most Influential lists, default 0</p> <code>0</code> <code>sector_id</code> <code>int</code> <p>Fount sectors ID, default None</p> <p>If a sector ID is provided, only that sector will be returned</p> <code>None</code> <code>filters</code> <code>SectorsFilters or dict[str, Any]</code> <p>SectorsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[SectorsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>sectors</code> endpoint results.</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def sectors(\n    token: str,\n    name: Optional[str] = None,\n    in_most_influential: Literal[0, 1] = 0,\n    *,\n    sector_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.SectorsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.SectorsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `sectors` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search categories by name, default None\n    in_most_influential : Literal[0, 1], optional\n        Sectors that are part of the Most Influential lists, default 0\n    sector_id : int, optional\n        Fount sectors ID, default None\n\n        If a sector ID is provided, only that sector will be returned\n    filters : SectorsFilters or dict[str, Any], optional\n        SectorsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[SectorsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `sectors` endpoint results.\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.sectors(\n            name,\n            in_most_influential,\n            sector_id=sector_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.studies","title":"<code>studies(token, country_codes=None, year_numbers=None, full_year=0, released=0, bav_study=0, *, study_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>released</code> <code>Literal[0, 1]</code> <p>Return released studies when set to <code>1</code>, default 0</p> <code>0</code> <code>bav_study</code> <code>Literal[0, 1]</code> <p>Return full BAV studies when set to <code>1</code>, default 0</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict[str, Any]</code> <p>StudiesFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[StudiesFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def studies(\n    token: str,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    full_year: Literal[0, 1] = 0,\n    released: Literal[0, 1] = 0,\n    bav_study: Literal[0, 1] = 0,\n    *,\n    study_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.StudiesFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `studies` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, default None\n    year_numbers : int or list[int], optional\n        Study years, default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, default 0\n\n        A value of 1 will filter non-full-year studies.\n    released : Literal[0, 1], optional\n        Return released studies when set to `1`, default 0\n    bav_study : Literal[0, 1], optional\n        Return full BAV studies when set to `1`, default 0\n    study_id : int, optional\n        Fount study ID, default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict[str, Any], optional\n        StudiesFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[StudiesFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.studies(\n            country_codes,\n            year_numbers,\n            full_year,\n            released,\n            bav_study,\n            study_id=study_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.years","title":"<code>years(token, year=None, *, year_id=None, filters=None, fields=None, include=None, query=None, stack_data=False, timeout=30.0, verbose=True, batch_size=10, n_workers=2, retries=3, on_errors='warn', **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>years</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>year</code> <code>int</code> <p>Search years by year number, default None</p> <code>None</code> <code>year_id</code> <code>int</code> <p>Fount year ID, default None</p> <p>If a year ID is provided, only that year will be returned</p> <code>None</code> <code>filters</code> <code>YearsFilters or dict[str, Any]</code> <p>YearsFilters object or dictionary of filter parameters, default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, default None</p> <code>None</code> <code>query</code> <code>Query[YearsFilters]</code> <p>Query object to perform request with, default None</p> <p>If query is used, all parameters listed before <code>query</code> will be ignored.</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, default True</p> <code>True</code> <code>batch_size</code> <code>int</code> <p>Size of batches to make requests with, default 10</p> <code>10</code> <code>n_workers</code> <code>int</code> <p>Number of workers to make requests, default 2</p> <code>2</code> <code>retries</code> <code>int</code> <p>Number of times to retry a request, default 3</p> <code>3</code> <code>on_errors</code> <code>Literal['warn', 'raise']</code> <p>Warn about failed requests or raise immediately on failure, default <code>\"warn\"</code></p> <code>'warn'</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>years</code> endpoint results</p> Source code in <code>bavapi/sync.py</code> <pre><code>@_coro\nasync def years(\n    token: str,\n    year: Optional[int] = None,\n    *,\n    year_id: Optional[int] = None,\n    filters: OptionalFiltersOrMapping[_filters.YearsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    query: Optional[Query[_filters.YearsFilters]] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    batch_size: int = 10,\n    n_workers: int = 2,\n    retries: int = 3,\n    on_errors: Literal[\"warn\", \"raise\"] = \"warn\",\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `years` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    year : int, optional\n        Search years by year number, default None\n    year_id : int, optional\n        Fount year ID, default None\n\n        If a year ID is provided, only that year will be returned\n    filters : YearsFilters or dict[str, Any], optional\n        YearsFilters object or dictionary of filter parameters, default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, default None\n    query : Query[YearsFilters], optional\n        Query object to perform request with, default None\n\n        If query is used, all parameters listed before `query` will be ignored.\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, default True\n    batch_size : int, optional\n        Size of batches to make requests with, default 10\n    n_workers : int, optional\n        Number of workers to make requests, default 2\n    retries : int, optional\n        Number of times to retry a request, default 3\n    on_errors : Literal[\"warn\", \"raise\"], optional\n        Warn about failed requests or raise immediately on failure, default `\"warn\"`\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, default None\n    per_page : int, optional\n        Number of results per page, default None\n    max_pages : int, optional\n        Max number of results to return, default None\n    sort : str, optional\n        Sort response by field, default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `years` endpoint results\n    \"\"\"\n\n    async with Client(\n        token,\n        timeout=timeout,\n        verbose=verbose,\n        batch_size=batch_size,\n        n_workers=n_workers,\n        retries=retries,\n        on_errors=on_errors,\n    ) as client:\n        return await client.years(\n            year,\n            year_id=year_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            query=query,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/parsing/","title":"parsing","text":"<p>Modules for parsing parameters and responses.</p>"},{"location":"reference/parsing/params/","title":"params","text":"<p>Functions to parse parameter values.</p>"},{"location":"reference/parsing/params/#parsing.params.list_to_str","title":"<code>list_to_str(mapping)</code>","text":"<p>Convert any lists in a dictionary to a string with comma-separated elements.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>ParamsMapping</code> <p>Dictionary with lists</p> required <p>Returns:</p> Type Description <code>ParamsMappingValues</code> <p>Dictionary with lists converted to comma-separated strings</p> Source code in <code>bavapi/parsing/params.py</code> <pre><code>def list_to_str(mapping: BaseMutableParamsMapping) -&gt; BaseMutableParamsMappingValues:\n    \"\"\"Convert any lists in a dictionary to a string with comma-separated elements.\n\n    Parameters\n    ----------\n    mapping : ParamsMapping\n        Dictionary with lists\n\n    Returns\n    -------\n    ParamsMappingValues\n        Dictionary with lists converted to comma-separated strings\n    \"\"\"\n    for key, value in mapping.items():\n        if not isinstance(value, str) and isinstance(value, Sequence):\n            mapping[key] = \",\".join(str(i) for i in value)\n\n    return cast(BaseMutableParamsMappingValues, mapping)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.parse_date","title":"<code>parse_date(value)</code>","text":"<p>Parse date string or datetime value into a date string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>(str, datetime, date)</code> <p>Input to parse into a date string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The parsed date as a string.</p> Source code in <code>bavapi/parsing/params.py</code> <pre><code>def parse_date(value: Union[str, dt.datetime, dt.date]) -&gt; str:\n    \"\"\"Parse date string or datetime value into a date string.\n\n    Parameters\n    ----------\n    value : str, dt.datetime, dt.date\n        Input to parse into a date string.\n\n    Returns\n    -------\n    str\n        The parsed date as a string.\n    \"\"\"\n    fmt_out = \"%Y-%m-%d %H:%M:%S\"\n    if isinstance(value, dt.datetime):\n        return value.strftime(fmt_out)\n    if isinstance(value, dt.date):\n        return dt.datetime.combine(value, dt.datetime.min.time()).strftime(fmt_out)\n    try:\n        return dt.datetime.strptime(value, fmt_out).strftime(fmt_out)\n    except ValueError:\n        return dt.datetime.fromisoformat(value).strftime(fmt_out)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.to_fount_params","title":"<code>to_fount_params(data, param)</code>","text":"<p>Constructs dictionary keys for special Fount API formatting.</p> <p>The resulting dictionary keys will be formatted to include <code>param</code> as the main parameter name:</p> <p>to_fount_params({\"a\":1}, \"test\")</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary to format.</p> required <code>param</code> <code>str</code> <p>Parameter name.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount API parameter dictionary.</p> Source code in <code>bavapi/parsing/params.py</code> <pre><code>def to_fount_params(data: Mapping[str, T], param: str) -&gt; Dict[str, T]:\n    \"\"\"Constructs dictionary keys for special Fount API formatting.\n\n    The resulting dictionary keys will be formatted to include `param` as the\n    main parameter name:\n\n    &gt;&gt;&gt; to_fount_params({\"a\":1}, \"test\")\n    {\"test[a]\":1}\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        Dictionary to format.\n    param : str\n        Parameter name.\n\n    Returns\n    -------\n    dict[str, Any]\n        Fount API parameter dictionary.\n    \"\"\"\n    return {f\"{param}[{k}]\": v for k, v in data.items()}\n</code></pre>"},{"location":"reference/parsing/responses/","title":"responses","text":"<p>Functions for parsing Fount API responses</p>"},{"location":"reference/parsing/responses/#parsing.responses.convert_numeric","title":"<code>convert_numeric(series)</code>","text":"<p>Convert pandas series into appropriate numeric types.</p> <ul> <li>Float and int values are returned directly with no conversion.</li> <li>String values are converted to int if possible, else float. Otherwise, return the series with no conversion.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Pandas series to convert to numeric type</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas series with numeric dtype, or current dtype if coercion is not possible</p> Source code in <code>bavapi/parsing/responses.py</code> <pre><code>def convert_numeric(series: pd.Series) -&gt; pd.Series:\n    \"\"\"Convert pandas series into appropriate numeric types.\n\n    - Float and int values are returned directly with no conversion.\n    - String values are converted to int if possible, else float. Otherwise, return the\n    series with no conversion.\n\n    Parameters\n    ----------\n    series : pd.Series\n        Pandas series to convert to numeric type\n\n    Returns\n    -------\n    pd.Series\n        Pandas series with numeric dtype, or current dtype if coercion is not possible\n    \"\"\"\n    if series.dtype in (float, int):\n        return series\n    try:\n        return series.astype(int)\n    except (ValueError, TypeError):\n        return series.astype(float, errors=\"ignore\")\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.flatten","title":"<code>flatten(mapping, parent='', sep='_', prefix='', expand=False)</code>","text":"<p>Recursively flatten all nested mappings and lists in the given mapping.</p> <p>Returns an iterator because it expands any nested lists into new dictionaries, then yields each repeated dictionary with its corresponding value from the list.</p> <p>This is equivalent to a <code>JOIN</code> operation in a relational database, where lists represent multiple entries on the right table of the <code>JOIN</code>.</p> <p>Note: If many nested lists are present, this function will generate as many entries as the PRODUCT of the nested lists. If the mapping has one nested list with 5 elements, and another nested list with 5 elements, the function will yield 25 (5x5) dictionaries in total.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any]</code> <p>Dictionary with potential nested dictionaries and lists of dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, default \"_\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for keys that clash with keys in the top-level mapping, default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <code>expand</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Yield flattened dictionaries.</p> <p>If expand is True and any nested lists are present, yield each resulting flattened dictionary.</p> Source code in <code>bavapi/parsing/responses.py</code> <pre><code>def flatten(\n    mapping: Entry[T],\n    parent: str = \"\",\n    sep: str = \"_\",\n    prefix: str = \"\",\n    expand: bool = False,\n) -&gt; Iterator[Dict[str, T]]:\n    \"\"\"Recursively flatten all nested mappings and lists in the given mapping.\n\n    Returns an iterator because it expands any nested lists into new dictionaries,\n    then yields each repeated dictionary with its corresponding value from the list.\n\n    This is equivalent to a `JOIN` operation in a relational database, where lists\n    represent multiple entries on the right table of the `JOIN`.\n\n    Note: If many nested lists are present, this function will generate as many entries\n    as the PRODUCT of the nested lists. If the mapping has one nested list with 5\n    elements, and another nested list with 5 elements,\n    the function will yield 25 (5x5) dictionaries in total.\n\n    Parameters\n    ----------\n    mapping : dict[str, Any]\n        Dictionary with potential nested dictionaries and lists of dictionaries\n    parent : str\n        Parent key for generating children keys, default \"\"\n    sep : str\n        Separator to use between keys and parent keys, default \"_\"\n    prefix : str\n        Prefix for keys that clash with keys in the top-level mapping, default \"\"\n\n        An empty prefix will ignore key conflicts.\n    expand : bool, optional\n        Whether to expand nested lists into new dictionaries, default False\n\n    Yields\n    ------\n    Iterator[dict[str, Any]]\n        Yield flattened dictionaries.\n\n        If expand is True and any nested lists are present, yield each resulting\n        flattened dictionary.\n    \"\"\"\n    res: Dict[str, T] = {}\n    to_expand: Dict[str, List[Dict[str, T]]] = {}\n    for k, v in flatten_mapping(mapping, parent, sep, prefix).items():\n        if isinstance(v, list) and expand:\n            to_expand[k] = v\n        else:\n            res[k] = v\n\n    if not to_expand:\n        yield res\n    else:\n        for record in itertools.product(*to_expand.values()):\n            res.update(zip(to_expand.keys(), record))\n            yield from flatten(res, parent, sep, prefix, expand)\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.flatten_mapping","title":"<code>flatten_mapping(mapping, parent='', sep='_', prefix='')</code>","text":"<p>Recursively flattens all nested dictionaries into top level key-value pairs.</p> <p>Include prefixes or suffixes if nested keys clash with top-level keys.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any]</code> <p>Dictionary with potential nested dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, default \"\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for nested keys that clash with keys in the top-level mapping, default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Flattened dictionary.</p> Source code in <code>bavapi/parsing/responses.py</code> <pre><code>def flatten_mapping(\n    mapping: Entry[T], parent: str = \"\", sep: str = \"_\", prefix: str = \"\"\n) -&gt; Dict[str, T]:\n    \"\"\"Recursively flattens all nested dictionaries into top level key-value pairs.\n\n    Include prefixes or suffixes if nested keys clash with top-level keys.\n\n    Parameters\n    ----------\n    mapping : dict[str, Any]\n        Dictionary with potential nested dictionaries\n    parent : str\n        Parent key for generating children keys, default \"\"\n    sep : str\n        Separator to use between keys and parent keys, default \"\"\n    prefix : str\n        Prefix for nested keys that clash with keys in the top-level mapping, default \"\"\n\n        An empty prefix will ignore key conflicts.\n\n    Returns\n    -------\n    dict[str, Any]\n        Flattened dictionary.\n    \"\"\"\n    res: Dict[str, T] = {}\n    to_expand: Dict[str, Dict[str, T]] = {}\n    for key, value in mapping.items():\n        if parent:\n            key = f\"{parent}{sep}{key}\"\n\n        if isinstance(value, dict):\n            to_expand[key] = value\n        else:\n            res[key] = value\n\n    with_prefix: Set[str] = (\n        {k for k in to_expand if any(_k.startswith(k) for _k in res)}\n        if prefix\n        else set()\n    )\n\n    expanded: Dict[str, T] = {}\n    for key, value in to_expand.items():\n        if key in with_prefix:\n            key = f\"{prefix}{sep}{key}\"\n\n        expanded.update(flatten_mapping(value, key, sep, prefix))\n\n    res.update(expanded)\n    return res\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.parse_response","title":"<code>parse_response(page, prefix='', index=None, expand=False)</code>","text":"<p>Parse Fount API JSON into a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Iterable[dict[str, Any]]</code> <p>Page from API response.</p> required <code>prefix</code> <code>str</code> <p>Prefix to prepend to columns with clashing names, default <code>\"\"</code></p> <code>''</code> <code>index</code> <code>str</code> <p>Column name to use as index, default None.</p> <code>None</code> <code>expand</code> <code>bool</code> <p>Whether to expand lists of dictionaries into new entries (rows) in the resulting DataFrame, default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of the response data.</p> Source code in <code>bavapi/parsing/responses.py</code> <pre><code>def parse_response(\n    page: Iterable[Entry[T]],\n    prefix: str = \"\",\n    index: Optional[str] = None,\n    expand: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Parse Fount API JSON into a pandas DataFrame.\n\n    Parameters\n    ----------\n    page : Iterable[dict[str, Any]]\n        Page from API response.\n    prefix : str, optional\n        Prefix to prepend to columns with clashing names, default `\"\"`\n    index : str, optional\n        Column name to use as index, default None.\n    expand : bool, optional\n        Whether to expand lists of dictionaries into new entries (rows)\n        in the resulting DataFrame, default False.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame of the response data.\n    \"\"\"\n    return (\n        pd.DataFrame.from_records(\n            (i for item in page for i in flatten(item, prefix=prefix, expand=expand)),\n            index=index,\n        )\n        .dropna(axis=1, how=\"all\")\n        .transform(convert_numeric)\n    )\n</code></pre>"},{"location":"usage/advanced/","title":"Advanced Usage","text":"<p>This section is intended for developers who are interested in embedding <code>bavapi</code> functionality into their APIs and applications.</p> <p>Async support</p> <p><code>bavapi</code> natively supports asynchronous execution, so it is ready to work with popular <code>async</code> libraries such as <code>fastapi</code>.</p>"},{"location":"usage/advanced/#the-client-interface","title":"The <code>Client</code> interface","text":"<p>The <code>Client</code> class is the backbone of <code>bavapi</code>, and it is the recommended way to interact with the Fount for more advanced users.</p> <p>Tip</p> <p>If you're familiar with the <code>requests</code> or <code>httpx</code> python packages, this is similar to using <code>requests.Session()</code> or <code>httpx.Client()</code>.</p> <p>Using the <code>Client</code> class instead of the top-level endpoint functions (<code>bavapi.brands</code>, for example), can bring significant performance improvements, especially when performing multiple requests at the same time.</p> <p>The <code>Client</code> interface is based on <code>httpx.Client</code>, so it benefits from all the performance features from <code>httpx</code>:</p> <p>Quote from the <code>httpx</code> docs</p> <ul> <li>Reduced latency across requests (no handshaking).</li> <li>Reduced CPU usage and round-trips.</li> <li>Reduced network congestion.</li> </ul> <p>By using <code>Client</code>, you will also get all these benefits, including in Jupyter Notebooks.</p>"},{"location":"usage/advanced/#using-the-client-interface","title":"Using the <code>Client</code> interface","text":"<p>It is recommended to use <code>Client</code> in an <code>async with</code> block:</p> <pre><code>async with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brands(\"Swatch\")\n</code></pre> <p>Otherwise, it is possible to use <code>Client</code> methods outside of an <code>async with</code> block, but it might be slightly less performant.</p> <pre><code>bav = bavapi.Client(\"TOKEN\")\nresult = await bav.brands(\"Swatch\")\nawait bav.aclose()  # (1)\n</code></pre> <ol> <li> Close the connection by awaiting <code>aclose</code> after you're done with your requests.</li> </ol>"},{"location":"usage/advanced/#other-endpoints","title":"Other endpoints","text":"<p>Because of the large number of available endpoints in the Fount and the highly customizable queries, some endpoints won't have extended support from the start.</p> <p>Open for feedback</p> <p>If you would like to see new endpoints with full type annotation support, please open an issue on GitHub with the Feature Request template.</p> <p><code>bavapi</code> provides <code>raw_query</code> functions/methods to access all the available endpoints without existing endpoint functions/methods:</p> <ul> <li><code>bavapi.raw_query</code> for synchronous requests.</li> <li><code>bavapi.Client.raw_query</code> for asynchronous requests.</li> </ul> <p>These <code>raw_query</code> methods require the use of <code>bavapi.Query</code> instances to make the request:</p> <pre><code>import bavapi\nfrom bavapi import Query\nfrom bavapi.filters import FountFilters\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    res = await bav.raw_query(\"companies\", Query(filters=FountFilters(name=\"Apple\")))\n</code></pre> <p>These functions will return a list of JSON dictionaries, one for each entry retrieved from the Fount:</p> <pre><code>[\n    {\"name\": \"Apple\", \"id\": 1},\n    {\"name\": \"Applebee's\", \"id\": 2},\n    // ...\n]\n</code></pre> <p>Tip</p> <p>These methods are meant to be used for custom processing of data (not resulting in a <code>pandas</code> DataFrame), but it is also possible to use some of the parsing functions available in bavapi.parsing.responses.</p>"},{"location":"usage/advanced/#the-query-class","title":"The <code>Query</code> class","text":"<p><code>bavapi.Query</code> is a <code>pydantic</code>-powered class that holds and validates all the common (aside from endpoint-specific filters) query parameters to pass to the Fount API.</p> <p>The default values for the class are the same as the default values in the Fount API itself, so an empty <code>Query</code> object can be used to get all entries for a specific endpoint:</p> <pre><code>query = bavapi.Query()\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    res = await bav.raw_query(\"brand-metrics\", query) # (1)\n</code></pre> <ol> <li> Returns all entries for <code>brand-metrics</code>. Similar to making a <code>GET</code> request with no parameters.</li> </ol> <p><code>Query</code> can be used to set limits on the number of pages retrieved, or to request a specific page from a query:</p> <pre><code>bavapi.Query(\n    per_page = 200,\n    max_pages = 50,\n    ...  # Other params\n)\n</code></pre>"},{"location":"usage/advanced/#query-parameters","title":"<code>Query</code> parameters","text":"<p>All Fount queries performed with <code>bavapi.Query</code> support the following parameters:</p> <ul> <li><code>id</code>: Return only results for a specific id.</li> <li><code>page</code>: The page number of results to return.</li> <li><code>per_page</code>: The number of results to return per page. Default is 25 and maximum is 100.</li> <li><code>max_pages</code>: The maximum number of pages to request. Defaults to requesting all pages in a query.</li> <li><code>fields</code>: The keys for the fields to include in the response. Usually they are the field name in lower case.</li> <li><code>sort</code>: The key(s) for the field(s) to order the response results by.</li> <li><code>include</code>: Additional linked resources to include in the response.</li> <li><code>updated_since</code>: Only return items that have been updated since this timestamp.</li> </ul> <p>For more information on the behavior of each of these parameters, see the Fount API docs.</p>"},{"location":"usage/advanced/#raw-parameter-dictionary","title":"Raw parameter dictionary","text":"<p>The <code>to_params</code> method can be used to parse the parameters into a dictionary of what will be sent to the Fount API:</p> <pre><code>&gt;&gt;&gt; bavapi.Query(\n...     filters=BrandscapeFilters(\n...         brand_name=\"Facebook\",\n...         year_numbers=[2012, 2013, 2014, 2015]\n...     ),\n...     include=[\"company\"]\n... ).to_params(endpoint=\"brandscape-data\")  # (1)\n{\n    \"include[brandscape-data]\": \"company\",  # (2)\n    \"filter[brand_name]\": \"Facebook\",\n    \"year_numbers\": \"2012,2013,2014,2015\",\n}\n</code></pre> <ol> <li>Needs the endpoint name to format parameters correctly.</li> <li> Parses <code>filters</code> and <code>include</code> into the correct format for the Fount API, and parses all elements in lists of parameters to their string representation.</li> </ol>"},{"location":"usage/advanced/#control-bavapi-batching-behavior","title":"Control <code>bavapi</code> batching behavior","text":"<p>New in <code>v0.13</code></p> <p><code>bavapi</code> will automatically batch paginated requests to the API to improve latency and throughput. Default values are set to maintain around twenty concurrent requests at a time.</p> <p>In addition, <code>bavapi</code> will also automatically retry failed requests a number of times (default <code>2</code>), which can be defined by the user.</p> <p>Both top-level functions and the <code>Client</code> class have the following parameters to control the behavior of the requests:</p> <ul> <li><code>batch_size</code>: Number of pages to include in each batch of requests, default <code>10</code>.</li> <li><code>n_workers</code>: Number of worker coroutines that will make batched requests at once, default <code>2</code>.</li> <li><code>retries</code>: Number of times to retry a page request before raising an exception, default <code>3</code>.</li> <li><code>on_errors</code>: Whether to <code>\"warn\"</code> about failed requests at the end of the query, or <code>\"raise\"</code> immediately upon failure (after retries), default <code>\"warn\"</code>.</li> </ul> <p>These parameters can be set in both top-level functions and the async <code>Client</code> class:</p> SyncAsync <pre><code>bavapi.brands(\n    TOKEN,\n    batch_size=5,  # number of requests per batch\n    n_workers=5,  # number of concurrent workers\n    retries=2,  # number of retry attempts\n    on_errors=\"raise\",  # raise on failure after retries\n)\n</code></pre> <pre><code>async with bavapi.Client(\n    TOKEN,\n    batch_size=5,  # number of requests per batch\n    n_workers=5,  # number of concurrent workers\n    retries=2,  # number of retry attempts\n    on_errors=\"raise\",  # raise on failure after retries\n) as client:\n    await client.brands()\n</code></pre> <p>The query from the examples above will result in 25 concurrent API requests (5 <code>batch_size</code> * 5 <code>n_workers</code>), and <code>bavapi</code> will retry each failed request twice (after the initial request). <code>on_errors=\"raise\"</code> will ensure that an exception is raised if all retries for any page result in exceptions.</p> <p>Warning</p> <p>In order to avoid SSL and timeout issues, it is recommended to set <code>batch_size</code> and <code>n_workers</code> so <code>bavapi</code> will perform at most 20-30 concurrent requests. The default is 20 concurrent requests (10 <code>batch_size</code> * 2 <code>n_workers</code>).</p>"},{"location":"usage/advanced/#user-agent","title":"User Agent","text":"<p>New in <code>v0.8</code></p> <p>It is possible to set the <code>User Agent</code> parameter for HTTP requests.</p> <p>The default user agent is <code>\"BAVAPI SDK Python\"</code>.</p> <p>If you want to change the user agent for your application, you can set it when instantiating a <code>Client</code>:</p> <pre><code>bav = bavapi.Client(user_agent=\"Your User Agent\")\n</code></pre>"},{"location":"usage/basic/","title":"Basic usage","text":"<p>Once you have installed <code>bavapi</code> and acquired a token from the Fount, you can start using <code>bavapi</code> directly in Python or in a Jupyter Notebook.</p> <pre><code>import bavapi\n</code></pre>"},{"location":"usage/basic/#using-bavapi","title":"Using bavapi","text":"<p>You can query the available endpoints with their corresponding methods:</p> <pre><code>swatch = bavapi.brands(\"TOKEN\", name=\"Swatch\")  # (1)\n</code></pre> <ol> <li> Replace <code>TOKEN</code> with your API key</li> </ol> <p>These endpoints methods will return a pandas DataFrame containing the data retrieved for your query:</p> id name ... 0 2342 Swatch ... 1 127896 Swatch ... ... ... ... ... <p>You can make requests to other endpoints in the same way:</p> <p>Tip</p> <p>You can also use <code>bavapi</code> Reference classes to define more readable filters. See more in Reference classes.</p> <pre><code>uk_studies = bavapi.studies(\"TOKEN\", country_code=\"GB\")\n\nuk22 = bavapi.brandscape_data(\"TOKEN\", year_number=2022, country_code=\"GB\", audiences=12)\n\nall_adults = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre> <p>Want to use other endpoints?</p> <p>The BAV API is very extensive, so not all endpoints are fully implemented yet.</p> <p>To query unsupported endpoints see the Other endpoints section in Advanced Usage.</p>"},{"location":"usage/basic/#bavapi-query-parameters","title":"<code>bavapi</code> query parameters","text":"<p>In order to validate the request parameters before sending a bad request, <code>bavapi</code> will automatically check that the parameters from your query and filters are of the type expected by the Fount API. If any parameter doesn't conform to the API requirements, <code>bavapi</code> will raise a <code>ValidationError</code>.</p> <p>What it's doing</p> <p><code>bavapi</code> performs an initial request to make sure the query parameters are valid, and to retrieve information about the number of pages it will need to fetch.</p> <p>If the initial request fails, <code>bavapi</code> will not perform more requests.</p> <p>Similarly, if the initial request returns the entirety of the query (e.g., there are only 10 results and <code>per_page</code> is above 10, which it is by default), no further requests will be performed, and instead the data from the initial response will be returned.</p>"},{"location":"usage/basic/#filters","title":"Filters","text":"<p>Each endpoint function has a filter class associated with it, as each endpoint has its own filter requirements:</p> Endpoint Function Filters class <code>audiences</code> <code>AudiencesFilters</code> <code>brand_metric_groups</code> <code>BrandMetricGroupsFilters</code> <code>brand_metrics</code> <code>BrandMetricsFilters</code> <code>brands</code> <code>BrandsFilters</code> <code>brandscape_data</code> <code>BrandscapeFilters</code> <code>categories</code> <code>CategoriesFilters</code> <code>cities</code> <code>CitiesFilters</code> <code>collections</code> <code>CollectionsFilters</code> <code>companies</code> <code>CompaniesFilters</code> <code>countries</code> <code>CountriesFilters</code> <code>sectors</code> <code>SectorsFilters</code> <code>studies</code> <code>StudiesFilters</code> <code>years</code> <code>YearsFilters</code> <p>Warning</p> <p>Using a filters class not meant for a specific endpoint won't raise any errors from the outset, but it also won't provide IDE type support or type validation to the parameters that are associated with each endpoint.</p> <p>Similarly, using a dictionary (as seen in the example below) won't provide validation or type hints. Use the dictionary method with caution.</p> <p>These classes are available in the <code>bavapi.filters</code> module.</p> <p>Some of the more common filters for each endpoint have been added directly to the <code>bavapi</code> functions. More info in the endpoints section.</p> <p>Example</p> <p><code>bavapi.brands</code> has parameters such as <code>name</code>, <code>country_codes</code>, <code>year_numbers</code>, <code>brand_id</code> or <code>studies</code>, which you can use directly from the function without creating a filters instance.</p> <p>However, less commonly used filters, as well as value filters must be specified by using the <code>filters</code> parameters in each function.</p> <p>Filters can be specified using a Python dictionary (if you know the name of the filters you need), or directly creating a Filters instance:</p> Filters instances (recommended)Dictionary <pre><code>result = bavapi.brands(\n    filters=BrandsFilters(name=\"Swatch\", country_codes=[\"US\", \"UK\"])\n)\n</code></pre> <pre><code>result = bavapi.brands(\n    filters={\"name\":\"Swatch\", \"country_codes\":[\"US\", \"UK\"]}\n)\n</code></pre> <p>Warning</p> <p>If both regular function parameters and <code>filters</code> are specified, the values in the <code>filters</code> parameter will take precedence for the actual request:</p> <pre><code>result = bavapi.brands(name=\"Swatch\", filters={\"name\": \"Facebook\"})\n</code></pre> <p>The request will use <code>name=\"Facebook\"</code>, because values specified in the <code>filters</code> parameter take precedence.</p>"},{"location":"usage/basic/#value-filters","title":"Value filters","text":"<p>Read more in the API documentation</p> <p>\"Value\" filters refer to filtering on the values of the data returned by the endpoint, as opposed to filtering via query parameters specified in the Fount API documentation. For example, filtering by category name or by sector in the <code>brandscape-data</code> endpoint.</p> <p>These value filters must be specified in the <code>filters</code> parameter. If they are added to the function call as regular keyword arguments, a <code>ValidationError</code> will be raised.</p> <pre><code>bavapi.brands(name=\"Swatch\", filters={\"sector_name\": \"Watches\"})  # ok\n\nbavapi.brands(name=\"Swatch\", sector_name=\"Watches\")  # raises ValidationError\n</code></pre> <p>When using additional value filters, which might not be available in the arguments to the function call, it is recommended to use the <code>filters</code> parameter instead of mixing function parameters and Filters parameters:</p> <pre><code>bavapi.brands(filters=BrandsFilters(name=\"Swatch\", sector_name=\"Watches\"))\n</code></pre> <p>The following query parameters are available for all endpoints (unless stated otherwise).</p>"},{"location":"usage/basic/#fields","title":"Fields","text":"<p>Read more in the API documentation</p> <p>It is possible to specify which fields a response should contain. If so, the API will only return those fields.</p> <pre><code>result = bavapi.brands(name=\"Swatch\", fields=[\"id\", \"name\"])\nresult.columns  # will only have [\"id\", \"name\"] as columns\n</code></pre>"},{"location":"usage/basic/#sorting","title":"Sorting","text":"<p>Read more in the API documentation</p> <p>It is possible to sort the data by a column from the response.</p> <pre><code># sorted by name\nresult = bavapi.brands(name=\"Swatch\", sort=\"name\")\n\n# descending sorted by name (note the '-')\nresult = bavapi.brands(name=\"Swatch\", sort=\"-name\")\n</code></pre> <p>Responses are sorted by item id, in ascending order, by default.</p>"},{"location":"usage/basic/#includes-related-data","title":"Includes (related data)","text":"<p>Read more in the API documentation</p> <p>Aside from the data directly available for each of the resources in the Fount, these resources can also be connected across endpoints.</p> <p>Example</p> <p>From the <code>brands</code> endpoint, you can request info about a brand's <code>company</code>, <code>sector</code> or <code>studies</code>, among others.</p> <p>Each endpoint supports different <code>includes</code> fields. Please read the Fount API documentation for more info on the specific set of includes supported by each endpoint.</p> <pre><code># will include info about the brand's company\nresult = bavapi.brands(name=\"Swatch\", includes=\"company\")\n</code></pre> <p>Default <code>includes</code></p> <p>The <code>brandscape_data</code> function includes <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code> by default, to align functionality with other sources of data like the Fount website and the Cultural Rank Tool. More info. The <code>categories</code> function also has default includes.</p>"},{"location":"usage/basic/#pagination","title":"Pagination","text":"<p>Read more in the API documentation</p> <p>All requests to the Fount are \"paginated\", meaning that one must request and receive from the server one page at a time. <code>bavapi</code> then combines all responses into one data table.</p> <p>New in <code>v0.12</code></p> <p>Pagination is controlled by three parameters:</p> <ul> <li><code>page</code></li> <li><code>per_page</code></li> <li><code>max_pages</code></li> </ul> <p>If only <code>page</code> is set to an integer greater than <code>0</code>, that single page will be requested.</p> <pre><code>bavapi.studies(page=1)  # Will request a single page of data\n</code></pre> <p>If either <code>per_page</code> or <code>max_pages</code> are set, <code>bavapi</code> will request the appropriate pages from the Fount API.</p> <p>While the Fount API default is <code>25</code>, the default <code>per_page</code> set by <code>bavapi</code> is <code>100</code>.</p> <p>Info</p> <p>The maximum number of elements per page allowed by the Fount API is <code>1000</code>.</p> <p><code>bavapi</code> will calculate the number of pages from the total items reported by the Fount.</p> <p>It is also possible to set the number of <code>max_pages</code>, which will limit the number of pages requested regardless of the reported total.</p> <p>The <code>page</code> value will be used as the starting page for the request. Therefore, if <code>page=10</code> and, for example, <code>max_pages=30</code>, <code>bavapi</code> will request pages <code>10</code> to <code>40</code>.</p> <pre><code># Request pages with 50 items per page\n# up to pages calculated from total reported\nbavapi.studies(\"TOKEN\", per_page=50)\n\n# Request pages with 100 items (default) per page up to 10 pages\n# or pages calculated from total reported, whichever is smaller\nbavapi.studies(\"TOKEN\", max_pages=10)\n\n# Request pages with 10 items per page up to 100 pages\n# or pages calculated from total reported, whichever is smaller\nbavapi.studies(\"TOKEN\", per_page=10, max_pages=100)\n\n# Request pages with 100 items (default) per page from page 3 to 33\n# or pages calculated from total reported, whichever is smaller\nbavapi.studies(\"TOKEN\", page=3, max_pages=30)\n</code></pre>"},{"location":"usage/basic/#metric-and-metric-group-keys","title":"Metric and metric group keys","text":"<p>New in <code>v0.12</code></p> <p>Read more in the API documentation</p> <p><code>metric_keys</code> and <code>metric_group_keys</code> are special filters to specify the data columns that the response should contain.</p> <p>The API response will include all score types for that metric or metric group.</p> <p>Note</p> <p>Currently, only the <code>brandscape-data</code> endpoint supports the use of metric and metric group keys. All other endpoints will ignore this parameter. More info in the <code>brandscape-data</code> endpoint section.</p>"},{"location":"usage/basic/#using-query-objects","title":"Using <code>Query</code> objects","text":"<p>New in <code>v0.11</code></p> <p>While the available parameters in endpoint functions and methods are provided for convenience, it is possible to use <code>bavapi.Query</code> objects directly inside function calls.</p> <p>This can be combined with the techniques covered in the saving query objects section of the documentation for powerful reproducibility.</p> <p>Similarly to filters objects, when using <code>Query</code> in one of the endpoint methods, the parameter values specified in the <code>Query</code> object will take precedence over parameters specified at the function level.</p> <pre><code># will use `name=\"Facebook\"` because `query` values take precedence.\nbavapi.brands(name=\"Swatch\", query=bavapi.Query(filters={\"name\":\"Facebook\"}))\n</code></pre> <p>Info</p> <p>Read more about <code>Query</code> in the Advanced usage section.</p>"},{"location":"usage/basic/#formatting-output","title":"Formatting output","text":"<p>It is possible that some of the data retrieved from the Fount includes multiple items.</p> <p>Example</p> <p>For example, requesting the <code>studies</code> include in <code>bavapi.brands</code> will return a column containing lists of dictionaries with study info for all studies that a brand appears in.</p> id name studies 0 24353 Facebook [{'id': 254, 'name': 'Argentin...}] ... ... ... ... <p><code>bavapi</code> has a <code>stack_data</code> parameter in its functions and methods that will take those lists of dictionaries and recursively generate a new entry (row) in the resulting DataFrame for each element in the list.</p> <pre><code>bavapi.brands(\"Facebook\", include=\"studies\", stack_data=True)\n</code></pre> id name studies_id studies_name ... 0 24353 Facebook 254 Argentina - Adults 2011 ... 1 24353 Facebook 787 Argentina - Adults 2012 ... ... ... ... ... ... ..."},{"location":"usage/basic/#suppressing-progress-bars","title":"Suppressing progress bars","text":"<p>New in <code>v0.9</code></p> <p><code>bavapi</code> displays progress bars to show download progress. Each tick in the progress bar refers to individual pages being downloaded.</p> <p>It's possible to supress progress bar outputs via the <code>verbose</code> parameter in function calls and <code>Client</code> init methods:</p> Sync (Won't show progress bar)Async (Won't show progress bar) <pre><code>bavapi.brands(\"TOKEN\", \"Facebook\", verbose=False)\n</code></pre> <pre><code>async with bavapi.Client(\"TOKEN\", verbose=False) as bav:\n    bav.brands(\"Facebook\")\n</code></pre>"},{"location":"usage/basic/#timeout","title":"Timeout","text":"<p>New in <code>v0.8</code></p> <p>By default, API requests will timeout after 30 seconds in order to avoid hangups.</p> <p>It is possible to set the time before timeout when performing requests with <code>bavapi</code>:</p> SyncAsync <pre><code>bavapi.brands(\"TOKEN\", \"Facebook\", timeout=60)\n</code></pre> <pre><code>async with bavapi.Client(\"TOKEN\", timeout=60) as bav:\n    await bav.brands(\"Facebook\")\n</code></pre>"},{"location":"usage/basic/#error-handling","title":"Error handling","text":"<p>New in <code>v0.13</code></p>"},{"location":"usage/basic/#warn-or-raise-when-a-page-fails-to-download","title":"Warn or raise when a page fails to download","text":"<p>You can control the error handling behavior of <code>bavapi</code> by changing the <code>on_errors</code> parameter in top-level functions and the <code>Client</code> interface.</p> <p>Options and examples:</p> <ul> <li><code>\"warn\"</code> (default): Will return all successfully downloaded data, and warn at the end about any pages that failed downloading so they can be manually retried.</li> <li><code>\"raise\"</code>: Will raise any exception that occurs immediately. This was the default behavior until <code>v0.13</code>.</li> </ul> WarnRaise <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", \"Facebook\", verbose=False, on_errors=\"warn\") # Fails page 1\nUserWarning: Could not fetch pages: [\"page 1: Exception(...)\"]  # Does not raise\n</code></pre> <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", \"Facebook\", verbose=False, on_errors=\"raise\") # Fails page 1\nException: ...  # Raised\n</code></pre> <p>Some requests may still raise</p> <p>During the initial handshake between <code>bavapi</code> and the Fount API, only SSL errors are retried. Therefore, some queries may still raise exceptions even if <code>on_errors</code> is set to <code>\"warn\"</code>:</p> <ul> <li>Invalid parameters will raise a <code>ValidationError</code> if they are not of the correct Python type</li> <li>Server errors will raise an <code>APIError</code> with additional details about the issue</li> <li>Queries with no results found will raise a <code>DataNotFoundError</code></li> <li>Requests which exceed the user's rate limit will raise a <code>RateLimitExceededError</code></li> </ul>"},{"location":"usage/basic/#retry-failed-requests","title":"Retry failed requests","text":"<p><code>bavapi</code> will automatically retry requests that fail because of an exception. The number of retry attempts can be controlled via the <code>retries</code> parameter in top-level functions and the <code>Client</code> interface:</p> <pre><code>bavapi.brands(\"TOKEN\", retries=5)  # Will retry pages 5 times after original failure\n</code></pre> <p>Tip</p> <p>There are some additional, advanced options for controlling the behavior of <code>bavapi</code> requests. More info in the Control <code>bavapi</code> batching behavior section from the Advanced Usage documentation.</p>"},{"location":"usage/project-tips/","title":"Tips for using <code>bavapi</code> in your projects","text":""},{"location":"usage/project-tips/#retry-failed-requests","title":"Retry failed requests","text":"<p>New default behavior</p> <p><code>bavapi</code> automatically retries failed requests starting from <code>v0.13</code>. The number of retry attempts can be controlled by the <code>retries</code> parameter in top-level functions and the <code>Client</code> interface. More info.</p> <p>If you are using an older version of <code>bavapi</code>, this tip should still apply.</p> <p>You can use the <code>retry</code> package to automatically retry requests upon failure.</p> <p>Here's an example snippet:</p> <pre><code>from retry.api import retry_call\nimport ssl\nimport bavapi\n\nretry_call(bavapi.brands, (\"TOKEN\", \"Facebook\"), exceptions=ssl.SSLError, tries=3)\n</code></pre> <p>This will attempt to make the request 3 times upon failure. If none of the tries succeeds, it will raise the exception resulting from the last retry.</p>"},{"location":"usage/project-tips/#batch-requests","title":"Batch requests","text":"<p>New default behavior</p> <p><code>bavapi</code> automatically batches requests starting from <code>v0.13</code>. Number of requests per batch and number of worker coroutines can be controlled by the <code>batch_size</code> and <code>n_workers</code> parameters in top-level functions and the <code>Client</code> interface. More info.</p> <p>If you are using an older version of <code>bavapi</code>, or you want to work around API rate limits, this tip should still apply.</p> <p>New in <code>v0.12</code></p> <p>Thanks to the new pagination logic, it is now possible to batch large requests to manage rate limits using <code>page</code>, <code>per_page</code> and <code>max_pages</code>.</p> <pre><code>import time\nfrom typing import Sequence\n\nimport pandas as pd\nimport bavapi\n\ndef make_batched_brand_request(\n    query: bavapi.Query,\n    batch_size: int,\n    per_page: int = 100,\n    wait: int = 60,  # BAV API rate limit duration\n) -&gt; pd.DataFrame:\n    n_items = per_page\n    page = query.page or 1\n    max_pages = query.max_pages \n    results: list[pd.DataFrame] = []\n\n    def collected_all(results: Sequence[pd.DataFrame]) -&gt; bool:\n        return max_pages and len(results) * batch_size &gt;= max_pages\n\n    # Loop if max_pages hasn't been reached OR n_items (per page) still equals per_page\n    while not collected_all(results) or n_items == per_page:\n        try:\n            res = bavapi.brands(query=query.with_page(page, per_page, batch_size))\n        except DataNotFoundError:\n            break  # If no more data found, in case last page has the same items as per_page\n        results.append(res)\n        page += batch_size\n        n_items = res[\"id\"].nunique()  # Supports `stack_data` functionality\n        time.sleep(wait)  # Wait for the rate limit to reset\n\n    return pd.concat(results)  # return all results as one DataFrame\n</code></pre> <p>With this function you can run:</p> <pre><code># Will perform batches of requests for 100 pages and wait 60 seconds\n# between batches until all the data is acquired\n&gt;&gt;&gt; make_batched_brand_request(query=bavapi.Query(), batch_size=100)\n</code></pre>"},{"location":"usage/project-tips/#save-load-filters-and-queries","title":"Save &amp; load filters and queries","text":"<p>One beneficial side-effect of using <code>bavapi</code> is the ability to save specific queries or filters in order to be able to reproduce them later on.</p> <p>Imagine that you need to share with your team a query that someone else will need to run.</p> <p>You could share the data if you save the file and then share with them, but another option which might work better if you have to manage multiple audiences/data files is to save the <code>bavapi</code> queries and load them for later use.</p> <p>The recommended (simplest) way to achieve this would be to save the query in a JSON file.</p> <pre><code>to_save = bavapi.filters.BrandsFilters(name=\"Facebook\", country_code=\"GB\")\n\nwith open(\"my_filters.json\", \"w\", encoding=\"utf-8\") as file:\n    file.write(to_save.model_dump_json())\n</code></pre> <p>The code above will save your filters as a JSON file:</p> my_filters.json<pre><code>{\n    \"updated_since\": null,\n    \"country_codes\": \"GB\",\n    \"year_numbers\": null,\n    \"categories\": null,\n    \"countries\": null,\n    \"regions\": null,\n    \"sectors\": null,\n    \"studies\": null,\n    \"years\": null,\n    \"name\": \"Facebook\"\n}\n</code></pre> <p>You can then load the file into a <code>bavapi.filters.BrandsFilters</code> (or any <code>FountFilters</code>) object like so:</p> <pre><code>import json\n\nwith open(\"my_filters.json\", \"r\", encoding=\"utf-8\") as file:\n    loaded = bavapi.filters.BrandsFilters(**json.load(file))\n</code></pre> <p>This should restore all filter values, so you can use it again with other requests:</p> <pre><code>&gt;&gt;&gt; loaded\nBrandsFilters(name=\"Facebook\", country_code=\"GB\", ...)\n</code></pre> <p>This also works for <code>Query</code> objects:</p> <pre><code>to_save = bavapi.Query(...)\n\nwith open(\"my_query.json\", \"w\", encoding=\"utf-8\") as file:\n    file.write(to_save.model_dump_json(), file)\n\n# Saved to `my_query.json`\n\nwith open(\"my_query.json\", \"r\", encoding=\"utf-8\") as file:\n    loaded = bavapi.Query(**json.load(file))\n</code></pre> <p>When saving and re-loading <code>Query</code> objects, its filters will be loaded as the base <code>FountFilters</code> class. Everything should work normally, but filter values won't be validated.</p> <p>For that reason, it is recommended NOT to create the filters and query in JSON directly, but to create the query in Python and then dump to JSON, so the values get validated before saving the query to a JSON file.</p> <p>New in <code>v0.11</code></p> <p>You can save and load Query objects to be used with any endpoint function or method.</p> <pre><code># continuing from code above...\nbavapi.brands(\"TOKEN\", query=loaded) # (1)\n</code></pre> <ol> <li>Will use the query parameters loaded from the <code>my_query.json</code> file.</li> </ol> <p>Note that only parameters specified in the <code>Query</code> object will be used.</p>"},{"location":"usage/project-tips/#using-bavapi-to-develop-real-time-applications","title":"Using <code>bavapi</code> to develop real-time applications","text":"<p><code>bavapi</code> provides asynchronous functionality for embedding <code>bavapi</code> into applications.</p> <p>Please see the Advanced Usage section for more information.</p>"}]}