{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BAV API Python SDK - <code>bavapi</code> documentation","text":"<p>WPPBAV provides a python consumer for the WPPBAV Fount API.</p> <p>It is published as <code>wpp-bavapi</code> in PyPI and hosted on GitHub.</p> <p>With <code>bavapi</code> you can access the full BAV data catalog, the largest and most comprehensive database of brand data in the world.</p> <p>Queries are validated automatically thanks to <code>pydantic</code> and retrieved asynchronously via the <code>httpx</code> package.</p> <p>For more information about the Fount API, see the API documentation website.</p>"},{"location":"#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p><code>bavapi</code> should work with any Python installation above version 3.8.</p> <p>Install <code>bavapi</code> using pip:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>See Installation for more detailed instructions.</p>"},{"location":"#example-usage","title":"Example usage","text":"<p>Protected access</p> <p> To use <code>bavapi</code>, you will need a Fount API token. Read more in the Authentication section.</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; result = bavapi.brands(\"TOKEN\", name=\"Swatch\") # (1)\n&gt;&gt;&gt; result\n</code></pre> <ol> <li> Replace \"TOKEN\" with your token.</li> </ol> sector_id sector_name id name ... 0 233 Apparel &amp; Accessories 8635 Swatch ... ... ... ... ... ... ..."},{"location":"#features","title":"Features","text":"<ul> <li>Support for all endpoints in the Fount API.<ul> <li>Extended support for the following endpoints:<ul> <li><code>audiences</code></li> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>brands</code></li> <li><code>brandscape-data</code></li> <li><code>categories</code></li> <li><code>collections</code></li> <li><code>sectors</code></li> <li><code>studies</code></li> </ul> </li> <li>Other endpoints are available via the <code>raw_query</code> functions and methods.</li> </ul> </li> <li>Validates query parameters are of the correct types and provides type hints for better IDE support.</li> <li>Retrieve multiple pages of data simultaneously, monitoring and preventing exceeding API rate limit.</li> <li>Both synchronous and asynchronous APIs for accessing BAV data.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>To start using <code>bavapi</code>, go to the Getting Started section.</p> <p>After going through the \"Getting Started\" section, please see Basic Usage.</p> <p>For more advanced topics, see the Advanced Usage section.</p> <p>Each Fount API endpoint may behave slightly differently. You can find detailed explanations in the Endpoints section.</p> <p>You can also find a detailed SDK reference in the Code Reference section.</p>"},{"location":"#issues","title":"Issues","text":"<p>For bug reports and feature requests, please open an issue on GitHub.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute to <code>bavapi</code>, please read the Contributing section of the documentation.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-bavapi","title":"Contributing to <code>bavapi</code>","text":"<p><code>bavapi</code> is an open source library provided by WPPBAV, and we're happy to accept contributions from the community.</p> <p>In order to keep a high level of quality and accessibility for our users, there are certain code style and testing requirements that we ask to accept your contributions.</p> <p><code>bavapi</code> uses <code>nox</code> to run development scripts.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>The easiest way to contribute when you see something wrong is to open an issue on GitHub. You can do so here.</p> <p>Please read the instructions in the issue template and fill out as much information as possible.</p> <p>This should be your first stop to start contributing to <code>bavapi</code>. We kindly ask that you let us know if you would like to contribute any changes to the code base by opening an issue on GitHub.</p> <p>Please return to this page once you have opened an issue on GitHub and are ready to start contributing.</p>"},{"location":"contributing/#cloning-bavapi-repository","title":"Cloning <code>bavapi</code> repository","text":"<p>In order to make sure you work on the latest version of <code>bavapi</code>, please fork the GitHub repository into your account and clone your fork of <code>bavapi</code> into your machine:</p> <pre><code>git clone https://github.com/{your-username}/bavapi-sdk-python\n</code></pre> <p>Once cloned, enter the newly created directory, create a virtual environment and install all optional dependencies in edit mode:</p> <pre><code>pip install -e .[dev, doc, test, lint]\n</code></pre> <p>This will install all optional dependencies which are necessary for contributing to the code base.</p>"},{"location":"contributing/#bav-api-key","title":"BAV API Key","text":"<p>You will need a BAV API key to perform requests to the API through <code>bavapi</code>.</p> <p>To get and use an API key, see the Authentication section of the Getting Started guide.</p> <p>In order to run integration tests and the <code>bavapi-gen-refs</code> command, you will need to use an <code>.env</code> file to store your BAV API key as <code>BAV_API_KEY</code> (you can also set the environment variable directly). See the instructions for more details.</p>"},{"location":"contributing/#tools-and-frameworks","title":"Tools and frameworks","text":"<p><code>bavapi</code> uses the following frameworks for development:</p> <ul> <li>Fully type-hinted and tested with <code>mypy</code>.</li> <li>Unit and integration tests using <code>pytest</code>.</li> <li>Full test coverage using <code>coverage</code>.</li> <li>Run development scripts in multiple Python versions with <code>nox</code>.</li> <li>Documentation using <code>mkdocs-material</code>.</li> <li>Code auto-formatting with <code>black</code>.</li> <li>Linting with <code>pylint</code>.</li> </ul> <p>Please familiarize yourself with using these libraries in order to get started with contributing to <code>bavapi</code>.</p>"},{"location":"contributing/#developing-in-windows","title":"Developing in Windows","text":"<p>It is highly recommended that you use <code>mamba</code> to manage Python environments in Windows. It is a faster implementation of <code>conda</code> and testing of <code>bavapi</code> on multiple versions of Python is set up to use <code>mamba</code> on Windows.</p> <p>Once you have <code>mamba</code> installed in your system, and you have set up an environment with <code>nox</code>, you should be able to run the <code>nox</code> commands for <code>bavapi</code>.</p>"},{"location":"contributing/#nox-commands","title":"Nox commands","text":"<p>To run <code>nox</code> commands, run the following command in your terminal:</p> <pre><code>nox -s {command_name}\n</code></pre>"},{"location":"contributing/#available-nox-commands","title":"Available <code>nox</code> commands","text":"<p>To see a list of all available <code>nox</code> commands, run <code>nox -l</code> in your terminal. Here is a quick summary:</p> <ul> <li><code>tests</code> and <code>tests_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information. Suitable for CI/CD pipeline and for Linux (would require <code>pyenv</code> to manage Python versions).</li> <li><code>tests_mamba</code> and <code>tests_mamba_e2e</code>: run <code>pytest</code> unit (or end-to-end) tests and collect <code>coverage</code> information, using <code>mamba</code> to run multiple versions of Python. Suitable for local testing on Windows.</li> <li>The commands above, ending with <code>_nocov</code>: run <code>pytest</code> unit (or end-to-end) tests without collecting <code>coverage</code> information.</li> <li><code>coverage</code>: combine and report coverage results.</li> <li><code>build</code>: build distributable files for <code>bavapi</code>. Suitable for CI/CD pipeline.</li> <li><code>docs_deploy</code>: publish <code>bavapi</code> documentation to GitHub Pages. Suitable for local development and CI/CD pipelines.</li> <li><code>docs_serve</code>: serve <code>bavapi</code> documentation with <code>mike</code>. Suitable for local development.</li> <li><code>docs_build_and_serve</code>: run both <code>docs_deploy</code> and <code>docs_serve</code>. Suitable for local development.</li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":"<p><code>bavapi</code> supports Python 3.8 and above, so your code should be able to run in all the latest versions of python.</p> <ol> <li>Run <code>black bavapi</code> after writing or modifying code. This way the code style of the whole project will remain consistent.</li> <li>Run <code>mypy bavapi</code> after writing or modifying code to make sure type hints are correctly defined.</li> <li>Fully test your code using <code>pytest</code> and make sure you covered all your changes in the repository by running all <code>tests_mamba</code>, <code>tests_mamba_e2e</code> and <code>coverage</code> sessions from <code>nox</code>.</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>If your contribution changes the functionality of the library, you will need to update the documentation.</p> <p><code>mkdocs-material</code> will automatically generate documentation for your code by parsing docstrings with <code>mkdocstrings</code>. Please make sure that the docstrings in your code follow the <code>numpydoc</code> standard.</p> <p>If your contribution changes the basic or advanced functionality of the library, or changes how the library is installed, please update those sections of the documentation.</p> <p>Each fully implemented endpoint should have a corresponding documentation page in the <code>endpoints</code> folder. Please follow the same structure as other endpoint pages for consistency.</p>"},{"location":"contributing/#cicd","title":"CI/CD","text":"<p><code>bavapi</code> has a CI/CD pipeline set up that checks for testing and coverage. All code must be tested and will fail integration if test coverage is not 100%.</p> <p>One way to ensure success is to run the three testing commands mentioned above. You can copy/paste the following command for convenience:</p> <pre><code>nox -s tests_mamba &amp;&amp; nox -s tests_mamba_e2e &amp;&amp; nox -s coverage\n</code></pre>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>In order to integrate changes into <code>bavapi</code>, you must create a pull request on GitHub.</p> <p>Please follow the instructions in the pull request template and fill out as much information as possible.</p> <p>GitHub actions will automatically run tests on the pull request content.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#version-010","title":"Version 0.10","text":""},{"location":"release-notes/#version-0101-october-17th-2023","title":"Version 0.10.1 (October 17th, 2023)","text":""},{"location":"release-notes/#fix","title":"Fix","text":"<ul> <li> (Breaking) Fix <code>metric_id</code> param to correct <code>group_id</code> name in <code>bavapi.brand_metric_groups</code> top level function.</li> </ul>"},{"location":"release-notes/#internal","title":"Internal","text":"<ul> <li> Renamed <code>reference</code> module as private. This will remove it from the code reference docs.</li> <li> Set new dependency minimum versions for compatibility.</li> </ul>"},{"location":"release-notes/#docs","title":"Docs","text":"<ul> <li> Code reference section now directs to the <code>sync</code> documentation by default.</li> <li> Added all available filters to the summary table in the Basic Usage section.</li> <li> More documentation for the <code>sync</code> and <code>client</code> modules.</li> <li> Added more clarity around expected environment variables when storing API keys. <code>bavapi</code> will always look for an API key in the <code>BAV_API_KEY</code> environment variable.</li> <li> Refactored code reference generation to support renaming of <code>reference</code> module.</li> </ul>"},{"location":"release-notes/#version-0100-october-16th-2023","title":"Version 0.10.0 (October 16th, 2023)","text":""},{"location":"release-notes/#feature","title":"Feature","text":"<ul> <li> The following endpoints have been fully implmented with type hints and validation:<ul> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>categories</code></li> <li><code>collections</code></li> <li><code>sectors</code></li> </ul> </li> </ul>"},{"location":"release-notes/#docs_1","title":"Docs","text":"<ul> <li> Documentation for newly supported endpoints.</li> <li> Documented the use of <code>\"no_default\"</code> as the <code>include</code> value for <code>brandscape_data</code> and <code>categories</code> functions/methods.</li> </ul>"},{"location":"release-notes/#internal_1","title":"Internal","text":"<ul> <li> Generalized internal <code>_default_includes</code> function to be able to reuse it with the <code>categories</code> endpoint.</li> <li> <code>nox</code> session <code>docs_build_and_serve</code> will now rebase local branch if local version data is not synced with GitHub.</li> </ul>"},{"location":"release-notes/#version-09","title":"Version 0.9","text":""},{"location":"release-notes/#version-090-october-11th-2023","title":"Version 0.9.0 (October 11th, 2023)","text":""},{"location":"release-notes/#feature_1","title":"Feature","text":"<ul> <li> Official support for Python 3.12.</li> <li> Added ability to show/hide progress bar when making requests with the <code>verbose</code> parameter. This is available for all top-level endpoint functions and when creating an instance of <code>bavapi.Client</code>. To hide the progress bar, set <code>verbose</code> to <code>False</code> (by default <code>True</code>).</li> </ul>"},{"location":"release-notes/#docs_2","title":"Docs","text":"<ul> <li> Added a section to the Usage Tips page explaining how to retry failed requests when an SSL exception is raised.</li> <li> Fix absolute/relative documentation links in the GitHub <code>CONTRIBUTING.md</code> file and the synced docs version.</li> <li> Added documentation for changing the User Agent for HTTP requests.</li> <li> Fix incorrect code example in the <code>brandscape-data</code> endpoint page.</li> <li> Added explicit documentation about which filters are available in top-level functions and methods to all endpoint pages.</li> </ul>"},{"location":"release-notes/#internal_2","title":"Internal","text":"<ul> <li> Fix deprecation warning due to timezone-aware <code>datetime</code> usage when generating reference classes in Python 3.12.</li> </ul>"},{"location":"release-notes/#ci","title":"CI","text":"<ul> <li> Upgraded <code>nox</code> GitHub Action versions.</li> <li> Added Python 3.12 to GitHub Actions CI/testing.</li> </ul>"},{"location":"release-notes/#typing","title":"Typing","text":"<ul> <li> Enabled support for PEP 692 <code>TypedDict</code> kwargs via <code>Unpack</code> on all endpoint functions and methods.</li> </ul>"},{"location":"release-notes/#dependencies","title":"Dependencies","text":"<ul> <li> Updated minimum required version of <code>typing-extensions</code> for Python versions below 3.12.</li> </ul>"},{"location":"release-notes/#version-08","title":"Version 0.8","text":""},{"location":"release-notes/#version-081-september-29th-2023","title":"Version 0.8.1 (September 29th, 2023)","text":""},{"location":"release-notes/#performance","title":"Performance","text":"<ul> <li> Improved response parsing performance by ~4x (about 0.6 seconds faster per Fount query).</li> </ul>"},{"location":"release-notes/#fix_1","title":"Fix","text":"<ul> <li> Fix required filters in <code>brandscape_data</code> functions and methods.</li> <li> Remove buried print statement in response flattening logic.</li> </ul>"},{"location":"release-notes/#docs_3","title":"Docs","text":"<ul> <li> Fixed and clarified required filters in <code>brandscape_data</code> functions and methods.</li> </ul>"},{"location":"release-notes/#internal_3","title":"Internal","text":"<ul> <li> Renamed <code>jupyter</code> compatibility module as private. This will remove it from the code reference docs.</li> </ul>"},{"location":"release-notes/#version-080-september-15th-2023","title":"Version 0.8.0 (September 15th, 2023)","text":""},{"location":"release-notes/#feature_2","title":"Feature","text":"<ul> <li> It is now possible to set a <code>timeout</code> parameter from top-level sync endpoint functions.</li> <li> It is now possible to set a <code>user_agent</code> parameter when creating a <code>bavapi.Client</code> instance.</li> </ul>"},{"location":"release-notes/#fix_2","title":"Fix","text":"<ul> <li> Fixed <code>bavapi-gen-refs</code> command tests overwriting reference files.</li> </ul>"},{"location":"release-notes/#internal_4","title":"Internal","text":"<ul> <li> <code>'BAVAPI SDK Python'</code> is now the default <code>User-Agent</code> for <code>bavapi</code>.</li> </ul>"},{"location":"release-notes/#docs_4","title":"Docs","text":"<ul> <li> Documentation for <code>timeout</code> usage.</li> <li> Automatically sync top level <code>CONTRIBUTING.md</code> file with the docs version.</li> <li> Fixed instructions to generate reference classes while specifying a token in the CLI command.</li> <li> Added missing parameter documentation for <code>Query</code> methods.</li> </ul>"},{"location":"release-notes/#ci_1","title":"CI","text":"<ul> <li> Removed end-to-end tests from CI pipeline due to various issues. They will have to be run manually in the near future.</li> </ul>"},{"location":"release-notes/#version-07","title":"Version 0.7","text":""},{"location":"release-notes/#version-070-august-22nd-2023","title":"Version 0.7.0 (August 22nd, 2023)","text":""},{"location":"release-notes/#feature_3","title":"Feature","text":"<ul> <li> It is now possible to specify a token with <code>-t</code>/<code>--token</code> when generating reference files via the <code>bavapi-gen-refs</code> command.</li> </ul>"},{"location":"release-notes/#fix_3","title":"Fix","text":"<ul> <li> <code>bavapi-gen-refs</code> would not run if <code>python-dotenv</code> was not installed. Now it will require an explicit token with <code>-t</code>/<code>--token</code> or, if <code>dotenv</code> is not installed, will prompt the user to install it and set the right environment variables.</li> </ul>"},{"location":"release-notes/#docs_5","title":"Docs","text":"<ul> <li> Fixed some links not pointing to the correct documentation pages.</li> <li> Added a \"Usage Tips\" section describing how to save queries for later use.</li> </ul>"},{"location":"release-notes/#ci_2","title":"CI","text":"<ul> <li> Set up automatic building of docs using <code>mike</code> and Github Actions.</li> <li> Fix <code>deploy_docs</code> nox session to install dependencies and actually run the deploy command.</li> </ul>"},{"location":"release-notes/#version-06","title":"Version 0.6","text":""},{"location":"release-notes/#version-061-july-19th-2023","title":"Version 0.6.1 (July 19th, 2023)","text":""},{"location":"release-notes/#fix_4","title":"Fix","text":"<ul> <li> Fix <code>metric_keys</code> incorrectly categorized as a filter instead of a top-level parameter within the <code>Query</code> class.</li> </ul>"},{"location":"release-notes/#internal_5","title":"Internal","text":"<ul> <li> Changed the custom <code>IntEnum</code> implementation to not override the standard lib's <code>IntEnum.__str__</code>.</li> <li> Added <code>nox</code> session for deploying docs.</li> </ul>"},{"location":"release-notes/#tests","title":"Tests","text":"<ul> <li> Added tests for checking that filters and parameters are assigned correctly in <code>Client</code> methods.</li> </ul>"},{"location":"release-notes/#docs_6","title":"Docs","text":"<ul> <li> Added warning about potential SSL errors outside of <code>bavapi</code> when using the Fount API.</li> </ul>"},{"location":"release-notes/#version-060-july-13th-2023","title":"Version 0.6.0 (July 13th, 2023)","text":""},{"location":"release-notes/#internal_6","title":"Internal","text":"<ul> <li> Upgraded <code>pydantic</code> to v2. Use <code>bavapi</code> v0.5 for compatibility with <code>pydantic</code> v1.</li> </ul>"},{"location":"release-notes/#typing_1","title":"Typing","text":"<ul> <li> Fixed use of <code>type</code> in type hints not compatible with Python 3.8.</li> <li> Cleaned up type hints in tests.</li> </ul>"},{"location":"roadmap/","title":"<code>bavapi</code> Roadmap","text":"<p>Note</p> <p>As of <code>v0.10.1</code>, <code>bavapi</code> is in beta. New features won't likely be developed until the full release of <code>bavapi</code>.</p> <p>This is a non-exhaustive list of potential features &amp; changes to <code>bavapi</code> before it is ready for full release:</p>"},{"location":"roadmap/#core-tooling","title":"Core tooling","text":"<ul> <li> <code>pydantic</code> V2 support <code>v0.6.0</code></li> <li> Strict <code>mypy</code> support with PEP 692 <code>Unpack</code> and <code>TypedDict</code> <code>v0.9.0</code></li> </ul>"},{"location":"roadmap/#known-issues","title":"Known issues","text":"<ul> <li> Sporadic <code>SSL: CERTIFICATE_VERIFY_FAILED</code> errors when making requests to the Fount API. Currently, retrying the request usually fixes the issue.</li> </ul>"},{"location":"roadmap/#new-fully-supported-endpoints","title":"New fully-supported endpoints","text":"<p>Eventually, the plan is to support all endpoints. This is the current priority list:</p> <ul> <li> Categories <code>v0.10.0</code></li> <li> Collections <code>v0.10.0</code></li> <li> Brand Metrics <code>v0.10.0</code></li> <li> Sectors <code>v0.10.0</code></li> <li> Brand Metric Groups <code>v0.10.0</code></li> </ul>"},{"location":"roadmap/#stretch-goals","title":"Stretch goals","text":"<ul> <li> Smarter flattening of JSON responses, possibly through <code>pandas.json_normalize</code>. <code>v0.8.1</code></li> <li> Parse datetime values to <code>pandas</code> datetime. <code>de-scoped</code></li> </ul>"},{"location":"endpoints/","title":"Endpoints","text":"<p>As of <code>v0.10</code>, there are four endpoints that have been fully implemented in <code>bavapi</code>:</p> <ul> <li><code>audiences</code></li> <li><code>brand-metrics</code></li> <li><code>brand-metric-groups</code></li> <li><code>brands</code></li> <li><code>brandscape-data</code></li> <li><code>categories</code></li> <li><code>collections</code></li> <li><code>sectors</code></li> <li><code>studies</code></li> </ul> <p>\"Implemented\" meaning that the endpoint has a corresponding function, <code>Client</code> method, and filters class associated with them. More info in each endpoint's respective section linked above.</p> <p>If an existing endpoint does not appear in the list above, you can still perform queries to it using the <code>raw_query</code> function/method (see below), but <code>bavapi</code> won't validate filter parameters.</p> <p>Examples for each endpoint are available in each of their individual sections, both for the top-level, synchronous functions, and the asynchronous methods in <code>bavapi.Client</code>.</p> <p>For a summary of all existing Fount endpoints, as well as their parameters and supported filters, please see the Resources section of the Fount API documentation.</p>"},{"location":"endpoints/#other-endpoints","title":"Other endpoints","text":"<p>While there are some commonly used endpoints with more extensive validation support, there are a lot of additional endpoints available for querying.</p> <p>With the <code>raw_query</code> functions and methods, you can perform requests to any endpoint in the Fount, even if it's not supported with dedicated code.</p> Endpoint Function <code>Client</code> method Filters class <code>{any}</code> <code>raw_query</code> <code>Client.raw_query</code> <code>FountFilters</code> <p>Queries from <code>raw_query</code> functions and methods return a list of JSON dictionaries, instead of a <code>pandas</code> DataFrame.</p> <p>Note</p> <p>You need to use a <code>Query</code> instance to perform queries with <code>raw_query</code> methods. More info</p>"},{"location":"endpoints/#usage","title":"Usage","text":"AsyncSync <pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.raw_query(\"companies\", bavapi.Query())\n</code></pre> <pre><code>import bavapi\n\nresult = bavapi.raw_query(\"TOKEN\", \"companies\", bavapi.Query())\n</code></pre> <p>Since the result of these queries will be a list of JSON dictionaries, you can use the <code>parse_response</code> function in the <code>bavapi.parsing.responses</code> module to parse the JSON response into a DataFrame:</p> <pre><code>import bavapi\nfrom bavapi.parsing.responses import parse_response\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.raw_query(\"companies\", bavapi.Query())\n\nparsed = parse_response(result)  # will return a DataFrame\n</code></pre>"},{"location":"endpoints/audiences/","title":"Audiences","text":"<p>The <code>audiences</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"audiences\"</code> <code>audiences</code> <code>Client.audiences</code> <code>AudiencesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>audiences</code> endpoint.</p>"},{"location":"endpoints/audiences/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.audiences(name=\"All Adults\")\n</code></pre>"},{"location":"endpoints/audiences/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>audience_id</code></li> <li><code>active</code></li> <li><code>inactive</code></li> <li><code>public</code></li> <li><code>private</code></li> <li><code>groups</code></li> </ul> <p>For other filters, passing an <code>AudienceFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brand-metric-groups/","title":"Brand Metric Groups","text":"<p>New in <code>v0.10</code></p> <p>The <code>brand-metric-groups</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brand-metric-groups\"</code> <code>brand_metric_groups</code> <code>Client.brand_metric_groups</code> <code>BrandMetricsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brand-metric-groups</code> endpoint.</p>"},{"location":"endpoints/brand-metric-groups/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brand_metric_groups(\"TOKEN\", name=\"Pillars\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brand_metric_groups(name=\"Pillars\")\n</code></pre>"},{"location":"endpoints/brand-metric-groups/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>group_id</code></li> <li><code>active</code></li> <li><code>inactive</code></li> </ul> <p>For other filters, passing a <code>BrandMetricGroupsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brand-metrics/","title":"Brand Metrics","text":"<p>New in <code>v0.10</code></p> <p>The <code>brand-metrics</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brand-metrics\"</code> <code>brand_metrics</code> <code>Client.brand_metrics</code> <code>BrandMetricsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brand-metrics</code> endpoint.</p>"},{"location":"endpoints/brand-metrics/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brand_metrics(\"TOKEN\", name=\"Differentiation\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brand_metrics(name=\"Differentiation\")\n</code></pre>"},{"location":"endpoints/brand-metrics/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>metric_id</code></li> <li><code>active</code></li> <li><code>inactive</code></li> <li><code>public</code></li> <li><code>private</code></li> <li><code>groups</code></li> </ul> <p>For other filters, passing a <code>BrandMetricsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brands/","title":"Brands","text":"<p>The <code>brands</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brands\"</code> <code>brands</code> <code>Client.brands</code> <code>BrandsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brands</code> endpoint.</p>"},{"location":"endpoints/brands/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brands(\"TOKEN\", name=\"Facebook\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brands(name=\"Facebook\")\n</code></pre>"},{"location":"endpoints/brands/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>country_codes</code></li> <li><code>year_numbers</code></li> <li><code>brand_id</code></li> <li><code>studies</code></li> </ul> <p>For other filters, passing a <code>BrandsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brandscape-data/","title":"Brandscape Data","text":"<p>The <code>brandscape-data</code> endpoint has full support, including query validation.</p> <p>This is the main entry point to WPPBAV's extensive brand data catalog.</p> Endpoint Function <code>Client</code> method Filters class <code>\"brandscape-data\"</code> <code>brandscape_data</code> <code>Client.brandscape_data</code> <code>BrandscapeFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>brandscape-data</code> endpoint.</p>"},{"location":"endpoints/brandscape-data/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.brandscape_data(\"TOKEN\", name=\"Facebook\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brandscape_data(name=\"Facebook\")\n</code></pre> <p>Warning</p> <p><code>brandscape-data</code> has filters which have a slightly different name than for other endpoints:</p> <ul> <li><code>year_number</code> instead of <code>year_numbers</code>.</li> <li><code>country_code</code> instead of <code>country_codes</code>.</li> </ul> <p>This is to maintain parity with the way the API is structured. Using the wrong spelling of these parameters will likely result in an error.</p>"},{"location":"endpoints/brandscape-data/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>country_code</code></li> <li><code>year_number</code></li> <li><code>audiences</code></li> <li><code>brand_name</code> (will perform a search on brand name)</li> <li><code>studies</code></li> </ul> <p>For other filters, passing a <code>BrandscapeFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/brandscape-data/#required-filters","title":"Required filters","text":"<p><code>brandscape-data</code> can retrieve brand datasets from an arbitrary combination of studies, audiences and years, so it is possible that the request becomes too large for the server to deliver effectively for all users.</p> <p>Thus, the <code>brandscape-data</code> endpoint has been restricted to require at least one of these specific set of filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" works just as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>If a query does not have any of these combinations of filters, it will raise a <code>ValidationError</code>:</p> <pre><code>bavapi.brandscape_data(\"TOKEN\")  # Error, no filters specified\n\nbavapi.brandscape_data(\"TOKEN\", year_number=2022) # Error, not enough filters\n\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\") # OK\n\nbavapi.brandscape_data(\n    \"TOKEN\", filters=bavapi.filters.BrandscapeFilters(audience=22, brands=123)\n)  # OK\n</code></pre>"},{"location":"endpoints/brandscape-data/#default-includes","title":"Default includes","text":"<p>In order to provide critical information about the data retrieved from <code>brandscape-data</code>, and to move its structure in line with data downloads from the Fount or BAV's Cultural Rank Tool (CRT), some <code>include</code> values are requested by default: <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code>.</p> <p>If you add any of these values in the <code>include</code> field by themselves, the default won't be used, and <code>bavapi</code> will make a request with the specified <code>include</code> instead.</p> <p>If, on the other hand, you request an <code>include</code> that is not part of the default values, <code>bavapi</code> will append that new value to the default <code>include</code> values.</p> <pre><code># All default (study, brand, category and audience) includes will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\")\n\n# Only the \"brand\" include will be requested\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"brand\")\n\n# The \"company\" include will be appended to the default `include` values\nbavapi.brandscape_data(\"TOKEN\", brand_name=\"Facebook\", include=\"company\")\n</code></pre> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p>"},{"location":"endpoints/brandscape-data/#clashing-column-names","title":"Clashing column names","text":"<p>Some includes can have clashing column names with the original data. This happens, for example, with the <code>\"brand\"</code> include, which when expanded will have column names such as <code>\"brand_name\"</code>, which is already present in the <code>brandscape-data</code> table.</p> <p>To circumvent this issue, the response parsing function will append the <code>\"global_\"</code> prefix to includes with potentially clashing names.</p> <p>As a result, you will see a set of columns, extracted from the <code>\"brand\"</code> include, which will have a <code>\"global_\"</code> prefix in their names.</p> <p>Warning</p> <p>This may change in future versions of <code>bavapi</code> as the parsing logic is upgraded.</p>"},{"location":"endpoints/brandscape-data/#metric-keys","title":"Metric keys","text":"<p><code>brandscape-data</code> functions and methods provide a parameter to specify the data columns that the response should contain: <code>metric_keys</code>.</p> <p>You can specify the metrics that your response should contain, and the API will include all score types for that metric.</p> <p>Example</p> <p>Setting <code>metric_keys</code> to <code>[\"differentiation\", \"relevance\"]</code> will instruct the request to only return the following columns:</p> <ul> <li><code>differentiation_c</code></li> <li><code>differentiation_rank</code></li> <li><code>relevance_c</code></li> <li><code>relevance_rank</code></li> <li>Brand information such as <code>id</code>, <code>brand_name</code>, and <code>category_name</code></li> <li>Any additional columns from the <code>include</code> parameter (see default behavior above)</li> </ul> <pre><code>bavapi.brandscape_data(studies=111, metric_keys=\"differentiation\") # (1)\n</code></pre> <ol> <li>Will only return <code>differentiation_c</code> and <code>differentiation_rank</code> data.</li> </ol>"},{"location":"endpoints/categories/","title":"Categories","text":"<p>New in <code>v0.10</code></p> <p>The <code>categories</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"categories\"</code> <code>categories</code> <code>Client.categories</code> <code>CategoriesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>categories</code> endpoint.</p>"},{"location":"endpoints/categories/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.categories(\"TOKEN\", name=\"Soap\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.categories(name=\"Soap\")\n</code></pre>"},{"location":"endpoints/categories/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>category_id</code></li> <li><code>sector</code></li> </ul> <p>For other filters, passing a <code>CategoriesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/categories/#default-includes","title":"Default includes","text":"<p>In order to provide critical information about the data retrieved from <code>categories</code>, and to move its structure in line with data downloads from the Fount or BAV's Cultural Rank Tool (CRT), some <code>include</code> values are requested by default: <code>sector</code>.</p> <pre><code># All default (sector) includes will be requested\nbavapi.categories(\"TOKEN\", name=\"All Adults\")\n</code></pre> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p>"},{"location":"endpoints/collections/","title":"Collections","text":"<p>New in <code>v0.10</code></p> <p>The <code>collections</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"collections\"</code> <code>collections</code> <code>Client.collections</code> <code>CollectionsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>collections</code> endpoint.</p>"},{"location":"endpoints/collections/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.collections(\"TOKEN\", name=\"Unilever\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.collections(name=\"Unilever\")\n</code></pre>"},{"location":"endpoints/collections/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>collection_id</code></li> <li><code>public</code></li> <li><code>shared_with_me</code></li> <li><code>mine</code></li> </ul> <p>For other filters, passing a <code>CollectionsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/sectors/","title":"Sectors","text":"<p>New in <code>v0.10</code></p> <p>The <code>sectors</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"sectors\"</code> <code>sectors</code> <code>Client.sectors</code> <code>SectorsFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>sectors</code> endpoint.</p>"},{"location":"endpoints/sectors/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.sectors(\"TOKEN\", name=\"Distribution\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.sectors(name=\"Distribution\")\n</code></pre>"},{"location":"endpoints/sectors/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>name</code></li> <li><code>sector_id</code></li> <li><code>in_most_influential</code></li> <li><code>not_in_most_influential</code></li> </ul> <p>For other filters, passing a <code>SectorsFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"endpoints/studies/","title":"Studies","text":"<p>The <code>studies</code> endpoint has full support, including query validation.</p> Endpoint Function <code>Client</code> method Filters class <code>\"studies\"</code> <code>studies</code> <code>Client.studies</code> <code>StudiesFilters</code> <p>For more information on available filters and functionality, see the Fount documentation for the <code>studies</code> endpoint.</p>"},{"location":"endpoints/studies/#usage","title":"Usage","text":"SyncAsync Using top-level functions<pre><code>import bavapi\n\nresult = bavapi.studies(\"TOKEN\", country_codes=\"US\")\n</code></pre> Using Client asynchronously<pre><code>import bavapi\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.studies(country_codes=\"US\")\n</code></pre>"},{"location":"endpoints/studies/#available-filters-in-function-calls","title":"Available filters in function calls","text":"<p>These filters are available directly within the function/method:</p> <ul> <li><code>country_codes</code></li> <li><code>year_numbers</code></li> <li><code>full_year</code></li> <li><code>study_id</code></li> </ul> <p>For other filters, passing a <code>StudiesFilters</code> instance to the <code>filters</code> parameter is required.</p>"},{"location":"getting-started/authentication/","title":"Authentication","text":"<p>The first thing you will need to use <code>bavapi</code> is a Fount API authentication token (a.k.a. key).</p> <p>This token is a specific code that is assigned to you and is needed to confirm that you have access to the Fount data.</p>"},{"location":"getting-started/authentication/#getting-a-fount-api-token","title":"Getting a Fount API token","text":"<p>Please follow the instructions in the Authentication section of the Fount API documentation.</p> <p>Warning</p> <p>Do NOT share your API token publicly or with anyone else. That token is tied to your account exclusively. If somebody else needs a token, they should create their own from their account settings.</p>"},{"location":"getting-started/authentication/#recommended-way-to-manage-api-keys","title":"Recommended way to manage API keys","text":"<p>In order to keep your API token secure, you should avoid using your token directly in your code and applications. Instead, place the code in a <code>.env</code> file at the top of your project directory, and use <code>python-dotenv</code> to load the token into your environment:</p> <pre><code>my-project-folder\n\u251c\u2500\u2500\u2500 .env\n\u2514\u2500\u2500\u2500 ... (other stuff)\n</code></pre> <p>Create this <code>.env</code> file (note the leading dot) in the top level of your working directory, and write down your token like so:</p> <pre><code>BAV_API_KEY = \"your_token_here\"\n</code></pre> <p>Tip</p> <p>The <code>bavapi-gen-refs</code> command also uses the <code>BAV_API_KEY</code> variable name.</p> <p>To now use this file, you will need to install the <code>python-dotenv</code> package:</p> <pre><code>pip install python-dotenv\n</code></pre> <p>Now, paste this code at the top of your Python files or Jupyter Notebooks:</p> <pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()  # (1)\nTOKEN = os.environ[\"BAV_API_KEY\"]  # (2)\n</code></pre> <ol> <li>Load variables from <code>.env</code> into the system's environment</li> <li>Assign the <code>\"BAV_API_KEY\"</code> environment variable to our <code>TOKEN</code> local variable</li> </ol> <p>Now you can use <code>TOKEN</code> in your API requests:</p> <pre><code>bavapi.brands(TOKEN, name=\"Swatch\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<p><code>bavapi</code> requires python 3.8 or higher to run.</p> <p>If you don't have python installed, you can download it from the official Python website or Anaconda.</p> <p>You will also need a Fount API bearer token to peform requests to the Fount. For instructions on how to get your own API token, see the Authentication section.</p> <p>Once you have installed Python and have acquired your Fount API token, return to this page to continue.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p><code>bavapi</code> depends on the following excellent libraries:</p> <ul> <li><code>httpx</code> for communication with the Fount API.</li> <li><code>pandas</code> for processing retrieved data into tables.</li> <li><code>pydantic</code> to validate query and filter parameters.</li> <li><code>nest-asyncio</code> to support Jupyter notebooks.</li> <li><code>tqdm</code> to show helpful progress bars.</li> <li><code>typing-extensions</code> for type-checking compatibility in Python &lt; 3.12.</li> </ul> <p>These libraries will be installed automatically when you install <code>bavapi</code>.</p>"},{"location":"getting-started/installation/#installing-bavapi","title":"Installing <code>bavapi</code>","text":"<p>Once you have your virtual environment activated, you can install <code>bavapi</code> with the following command:</p> <pre><code>pip install wpp-bavapi\n</code></pre> <p>Installing with <code>conda</code></p> <p><code>bavapi</code> is not currently available from <code>conda</code> directly, though it should be possible to install and use it within a <code>conda</code> environment.</p> <p>Use the following commands to maximize compatibility between <code>conda</code> and <code>pip</code>:</p> <pre><code>conda install httpx, pandas, pydantic, nest-asyncio, tqdm, typing_extensions\n\npip install wpp-bavapi --no-deps\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from source","text":"<p>To install from source, clone the GitHub repository into your local machine:</p> <pre><code>git clone https://github.com/wppbav/bavapi-sdk-python.git\n</code></pre> <p>Go into the cloned directory and install <code>bavapi</code>:</p> <pre><code>cd bavapi-sdk-python\npip install .\n</code></pre>"},{"location":"getting-started/reference-classes/","title":"Installing <code>bavapi</code> Reference classes","text":"<p><code>bavapi</code> can generate some convenience reference classes which map Fount resource IDs with a more readable name, both for ease of use and for autocompletion in IDEs.</p> <p>These classes are automatically generated by a console command that becomes available once <code>bavapi</code> is installed.</p> <p>Protected Access</p> <p>A Fount API token is required to generate reference files. See the Authentication section for more information and instructions for using <code>.env</code> files.</p> <p>As of <code>v0.10</code> the following reference classes will be generated in a folder named <code>bavapi_refs</code>:</p> <ul> <li><code>Audiences</code>: encodes audience IDs</li> <li><code>Countries</code>: encodes country IDs</li> </ul> <p>A sample reference class would look like this:</p> <pre><code>class Audiences(Enum):\n    ALL_ADULTS = 27  # Random ID\n    ...\n</code></pre> <p>And could be used to have better visibility when filtering API responses:</p> Using Reference classNot using Reference class Explicit audience filter<pre><code>bavapi.brandscape_data(country_code=\"US\", year=2022, audiences=Audiences.ALL_ADULTS)\n</code></pre> Audience filter not human-readable<pre><code>bavapi.brandscape_data(country_code=\"US\", year=2022, audiences=27)\n</code></pre> <p>Warning</p> <p>Don't commit reference classes to public repositories. Add <code>bavapi_refs/</code> to your <code>.gitignore</code> file.</p>"},{"location":"getting-started/reference-classes/#generate-reference-classes","title":"Generate Reference classes","text":"<p>New in <code>v0.7.0</code></p> <p>To generate these reference classes, there are two options for authenticating your requests:</p> <ul> <li>Specify the Fount API token via the <code>-t</code>/<code>--token</code> argument</li> <li>Use a <code>.env</code> file to store your Fount API token as the <code>BAV_API_KEY</code> environment variable, and install <code>python-dotenv</code> to read the file into your environment. See the Authentication section for more info.</li> </ul> <p>To generate the reference files, run the following command:</p> With a <code>.env</code> fileUsing the <code>-t</code>/<code>--token</code> argument <pre><code>bavapi-gen-refs --all\n</code></pre> <pre><code>bavapi-gen-refs -t \"TOKEN\" --all\n</code></pre> <p>You can also specify the name of the reference class to generate:</p> <pre><code>bavapi-gen-refs -t \"TOKEN\" --name audiences\n</code></pre> <p>To update existing reference classes with the latest data, re-run <code>bavapi-gen-refs</code> with the appropriate parameters on your terminal.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>sync</li> <li>client</li> <li>exceptions</li> <li>filters</li> <li>http</li> <li>parsing<ul> <li>params</li> <li>responses</li> </ul> </li> <li>query</li> </ul>"},{"location":"reference/client/","title":"client","text":"<p>Asynchronous BAV API client interface.</p> <p>Similar to <code>requests.Session</code> or <code>httpx.AsyncClient</code> (uses the latter as dependency).</p> <p>Examples:</p> <p>Create a client instance and make a request to the <code>brands</code> endpoint.</p> <pre><code>&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result = await bav.brands(\"Facebook\")\n</code></pre> <p>A more complex query:</p> <pre><code>&gt;&gt;&gt; from bavapi_refs.audiences import Audiences\n&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     bss = await bav.brandscape_data(\n...         country_code=\"UK\",\n...         year_number=2022,\n...         audiences=Audiences.ALL_ADULTS,\n...     )\n</code></pre> <p>Multiple queries will share the client connection for better performance:</p> <pre><code>&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result1 = await bav.brands(\"Facebook\")\n...     result2 = await bav.brands(\"Instagram\")\n</code></pre> <p>Use <code>Client.raw_query</code> (with <code>bavapi.Query</code>) for endpoints that aren't fully supported:</p> <pre><code>&gt;&gt;&gt; query = bavapi.Query(filters=bavapi.filters.FountFilters(name=\"Meta\"))\n&gt;&gt;&gt; async with bavapi.Client(\"TOKEN\") as bav:\n...     result = await bav.raw_query(\"companies\", params=query)\n</code></pre>"},{"location":"reference/client/#client.Client","title":"<code>Client</code>","text":"<p>Asynchronous API to interact with the WPPBAV Fount API.</p> <p>This class uses <code>asyncio</code> to perform asynchronous requests to the Fount API.</p> <p>Asynchronous requests allow you to make multiple requests at the same time, extremely helpful for working with a paginated API like the Fount. (returns data in multiple pages or requests instead of one single download)</p> <p>To use the Client class, you will need to precede calls with <code>await</code>:</p> <pre><code>bav = Client(\"TOKEN\")  # creating client instance does not use `await`\ndata = await bav.brands(\"Swatch\")  # must use `await`\n</code></pre> <p>For more information, see the <code>asyncio</code> documentation for Python.</p> <p>Either <code>auth_token</code> or <code>client</code> are required to instantiate a Client.</p> <p>Parameters:</p> Name Type Description Default <code>auth_token</code> <code>str</code> <p>WPPBAV Fount API authorization token, by default <code>''</code></p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, by default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, by default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>user_agent</code> <code>str</code> <p>The name of the User-Agent to send to the Fount API, by default <code>''</code>.</p> <p>If no user_agent is set, <code>bavapi</code> will use <code>\"BAVAPI SDK Python\"</code> by default.</p> <code>''</code> <code>client</code> <code>HTTPClient</code> <p>Authenticated async client from <code>bavapi.http</code>, by default None</p> <p>If <code>client</code> is passed, all other parameters will be ignored.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>auth_token</code> nor <code>client</code> are provided</p> <p>Examples:</p> <p>Use <code>async with</code> to get data and close the connection.</p> <p>This way you get the benefits from <code>httpx</code> speed improvements and closes the connection when exiting the async with block.</p> <pre><code>&gt;&gt;&gt; async with Client(\"TOKEN\") as bav:\n...     data = await bav.brands(\"Swatch\")\n</code></pre> <p>When not using <code>async with</code>, close the connection manually by awaiting <code>aclose</code>.</p> <pre><code>&gt;&gt;&gt; bav = Client(\"TOKEN\")\n&gt;&gt;&gt; data = await bav.brands(\"Swatch\")\n&gt;&gt;&gt; await bav.aclose()\n</code></pre> <p>If you want to perform multiple endpoint requests with the same <code>Client</code>, it is recommended to use <code>verbose=False</code> to avoid jumping progress bars.</p> <pre><code>&gt;&gt;&gt; async with Client(\"TOKEN\", verbose=False) as bav:\n...     resp1 = await bav.brands(\"Facebook\")\n...     resp2 = await bav.brands(\"Microsoft\")\n</code></pre> Source code in <code>bavapi\\client.py</code> <pre><code>class Client:\n    \"\"\"Asynchronous API to interact with the WPPBAV Fount API.\n\n    This class uses `asyncio` to perform asynchronous requests to the Fount API.\n\n    Asynchronous requests allow you to make multiple requests at the same time,\n    extremely helpful for working with a paginated API like the Fount. (returns\n    data in multiple pages or requests instead of one single download)\n\n    To use the Client class, you will need to precede calls with `await`:\n\n    ```py\n    bav = Client(\"TOKEN\")  # creating client instance does not use `await`\n    data = await bav.brands(\"Swatch\")  # must use `await`\n    ```\n\n    For more information, see the `asyncio` documentation for Python.\n\n    Either `auth_token` or `client` are required to instantiate a Client.\n\n    Parameters\n    ----------\n    auth_token : str, optional\n        WPPBAV Fount API authorization token, by default `''`\n    per_page : int, optional\n        Default number of entries per page, by default 100\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verify : bool or str, optional\n        Verify SSL credentials, by default True\n\n        Also accepts a path string to an SSL certificate file.\n    user_agent : str, optional\n        The name of the User-Agent to send to the Fount API, by default `''`.\n\n        If no user_agent is set, `bavapi` will use `\"BAVAPI SDK Python\"` by default.\n    client : HTTPClient, optional\n        Authenticated async client from `bavapi.http`, by default None\n\n        If `client` is passed, all other parameters will be ignored.\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n\n    Raises\n    ------\n    ValueError\n        If neither `auth_token` nor `client` are provided\n\n    Examples\n    --------\n    Use `async with` to get data and close the connection.\n\n    This way you get the benefits from `httpx` speed improvements\n    and closes the connection when exiting the async with block.\n\n    &gt;&gt;&gt; async with Client(\"TOKEN\") as bav:\n    ...     data = await bav.brands(\"Swatch\")\n\n    When not using `async with`, close the connection manually by awaiting `aclose`.\n\n    &gt;&gt;&gt; bav = Client(\"TOKEN\")\n    &gt;&gt;&gt; data = await bav.brands(\"Swatch\")\n    &gt;&gt;&gt; await bav.aclose()\n\n    If you want to perform multiple endpoint requests with the same `Client`, it is\n    recommended to use `verbose=False` to avoid jumping progress bars.\n\n    &gt;&gt;&gt; async with Client(\"TOKEN\", verbose=False) as bav:\n    ...     resp1 = await bav.brands(\"Facebook\")\n    ...     resp2 = await bav.brands(\"Microsoft\")\n    \"\"\"\n\n    @overload\n    def __init__(self, auth_token: str) -&gt; None:\n        ...\n\n    @overload\n    def __init__(\n        self,\n        auth_token: str,\n        per_page: int = 100,\n        timeout: float = 30.0,\n        verify: Union[bool, str] = True,\n        user_agent: str = \"\",\n        *,\n        verbose: bool = True,\n    ) -&gt; None:\n        ...\n\n    @overload\n    def __init__(\n        self,\n        *,\n        client: HTTPClient = ...,\n    ) -&gt; None:\n        ...\n\n    def __init__(\n        self,\n        auth_token: str = \"\",\n        per_page: int = 100,\n        timeout: float = 30.0,\n        verify: Union[bool, str] = True,\n        user_agent: str = \"\",\n        *,\n        client: Optional[HTTPClient] = None,\n        verbose: bool = True,\n    ) -&gt; None:\n        if client is not None:\n            self._client = client\n        else:\n            if not auth_token:\n                raise ValueError(\"You must provide `auth_token` or `client`.\")\n            self._client = HTTPClient(\n                base_url=BASE_URL,\n                per_page=per_page,\n                timeout=timeout,\n                verify=verify,\n                headers={\n                    \"Authorization\": f\"Bearer {auth_token}\",\n                    \"Accept\": \"application/json\",\n                    \"User-Agent\": user_agent or \"BAVAPI SDK Python\",\n                },\n                verbose=verbose,\n            )\n\n    @property\n    def per_page(self) -&gt; int:\n        \"\"\"Default number of items to retrieve per page.\"\"\"\n        return self._client.per_page\n\n    @per_page.setter\n    def per_page(self, value: int) -&gt; None:\n        self._client.per_page = value\n\n    @property\n    def verbose(self) -&gt; bool:\n        \"\"\"Show progress bar when making requests.\"\"\"\n        return self._client.verbose\n\n    @verbose.setter\n    def verbose(self, value: bool) -&gt; None:\n        self._client.verbose = value\n\n    async def __aenter__(self) -&gt; \"Client\":\n        await self._client.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_value: Optional[BaseException] = None,\n        traceback: \"Optional[TracebackType]\" = None,\n    ) -&gt; None:\n        await self._client.__aexit__(exc_type, exc_value, traceback)\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Close existing HTTP connections.\"\"\"\n        return await self._client.aclose()\n\n    async def raw_query(self, endpoint: str, params: Query[F]) -&gt; List[JSONDict]:\n        \"\"\"Perform a raw GET query to the WPPBAV Fount API, returning\n        the response JSON data instead of a `pandas` DataFrame.\n\n        Parameters\n        ----------\n        endpoint : str\n            Endpoint name\n        params : Query\n            Query `pydantic` model with query parameters.\n\n        Returns\n        -------\n        list[dict[str, Any]]\n            List of JSON response data\n        \"\"\"\n        return list(await self._client.query(endpoint, params))\n\n    async def audiences(\n        self,\n        name: Optional[str] = None,\n        audience_id: Optional[int] = None,\n        active: Literal[0, 1] = 0,\n        inactive: Literal[0, 1] = 0,\n        public: Literal[0, 1] = 0,\n        private: Literal[0, 1] = 0,\n        groups: OptionalListOr[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `audiences` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search audiences by name, by default None\n        audience_id : int, optional\n            Fount audience ID, by default None\n\n            If an audience ID is provided, only that audience will be returned\n        active : Literal[0, 1], optional\n            Return active audiences only if set to `1`, by default 0\n        inactive : Literal[0, 1], optional\n            Return inactive audiences only if set to `1`, by default 0\n        public : Literal[0, 1], optional\n            Return active audiences only if set to `1`, by default 0\n        private : Literal[0, 1], optional\n            Return inactive audiences only if set to `1`, by default 0\n        groups : int or list[int], optional\n            Audience group ID or list of audience group IDs, by default None\n        filters : AudiencesFilters or dict of filters, optional\n            AudiencesFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brands` endpoint results.\n        \"\"\"\n\n        filters = _filters.AudiencesFilters.ensure(\n            filters,\n            name=name,\n            active=active,\n            inactive=inactive,\n            public=public,\n            private=private,\n            groups=groups,\n        )\n\n        query: Query[_filters.AudiencesFilters] = Query(\n            id=audience_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"audiences\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def brand_metrics(\n        self,\n        name: Optional[str] = None,\n        metric_id: Optional[int] = None,\n        active: Literal[0, 1] = 0,\n        inactive: Literal[0, 1] = 0,\n        public: Literal[0, 1] = 0,\n        private: Literal[0, 1] = 0,\n        groups: OptionalListOr[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.BrandMetricsFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `brand-metrics` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search brand metrics by name, by default None\n        metric_id : int, optional\n            Fount metric ID, by default None\n\n            If an metric ID is provided, only that metric will be returned\n        active : Literal[0, 1], optional\n            Return active brand metrics only if set to `1`, by default 0\n        inactive : Literal[0, 1], optional\n            Return inactive brand metrics only if set to `1`, by default 0\n        public : Literal[0, 1], optional\n            Return active brand metrics only if set to `1`, by default 0\n        private : Literal[0, 1], optional\n            Return inactive brand metrics only if set to `1`, by default 0\n        groups : int or list[int], optional\n            Brand metrics group ID or list of Brand metrics group IDs, by default None\n        filters : BrandMetricsFilters or dict of filters, optional\n            BrandMetricsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brand-metrics` endpoint results.\n        \"\"\"\n\n        filters = _filters.BrandMetricsFilters.ensure(\n            filters,\n            name=name,\n            active=active,\n            inactive=inactive,\n            public=public,\n            private=private,\n            groups=groups,\n        )\n\n        query: Query[_filters.BrandMetricsFilters] = Query(\n            id=metric_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"brand-metrics\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def brand_metric_groups(\n        self,\n        name: Optional[str] = None,\n        group_id: Optional[int] = None,\n        active: Literal[0, 1] = 0,\n        inactive: Literal[0, 1] = 0,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.BrandMetricGroupsFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `brand-metric-groups` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search brand metric groups by name, by default None\n        group_id : int, optional\n            Fount metric group ID, by default None\n\n            If an metric group ID is provided, only that metric group will be returned\n        active : Literal[0, 1], optional\n            Return active brand metric groups only if set to `1`, by default 0\n        inactive : Literal[0, 1], optional\n            Return inactive brand metric groups only if set to `1`, by default 0\n        filters : BrandMetricGroupsFilters or dict of filters, optional\n            BrandMetricGroupsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brand-metric-groups` endpoint results.\n        \"\"\"\n\n        filters = _filters.BrandMetricGroupsFilters.ensure(\n            filters,\n            name=name,\n            active=active,\n            inactive=inactive,\n        )\n\n        query: Query[_filters.BrandMetricGroupsFilters] = Query(\n            id=group_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"brand-metric-groups\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def brands(\n        self,\n        name: Optional[str] = None,\n        country_codes: OptionalListOr[str] = None,\n        year_numbers: OptionalListOr[int] = None,\n        brand_id: Optional[int] = None,\n        studies: OptionalListOr[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `brands` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search brands by name, by default None\n        country_codes: str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_numbers : int or list[int], optional\n            Study years, by default None\n        brand_id : int, optional\n            Fount brand ID, by default None\n\n            If a brand ID is provided, only that brand will be returned\n        studies : int or list[int], optional\n            Fount study IDs, by default None\n        filters : BrandsFilters or dict of filters, optional\n            BrandsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brands` endpoint results.\n        \"\"\"\n\n        filters = _filters.BrandsFilters.ensure(\n            filters,\n            name=name,\n            country_codes=country_codes,\n            year_numbers=year_numbers,\n            studies=studies,\n        )\n\n        query: Query[_filters.BrandsFilters] = Query(\n            id=brand_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"brands\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def brandscape_data(\n        self,\n        country_code: OptionalListOr[str] = None,\n        year_number: OptionalListOr[int] = None,\n        audiences: OptionalListOr[int] = None,\n        brand_name: Optional[str] = None,\n        studies: OptionalListOr[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        metric_keys: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `brandscape-data` endpoint.\n\n        This endpoint requires at least one of the following combinations of filters:\n\n        - Study + Audience + Brand + Category\n        - Country + Year + Audience\n        - Brand + Audience + Country + Year\n\n        You should read these from left to right. A combination of \"Study + Audience\"\n        worksjust as well as \"Study + Audience + Brand\".\n        However, \"Category + Audience\" will not.\n\n        If you use Country or Year filters, you must use both filters together.\n\n        An audience filter is also highly recommended, as otherwise the API will return\n        data for all audiences (there are more than 100 standard audiences).\n\n        The `Audiences` class is provided to make it easier to filter audiences.\n\n        Note that this endpoint has a default set of `include` resources:\n        - `brand`\n        - `study`\n        - `category`\n        - `audience`\n\n        Any additional valid includes will be added to the default set.\n\n        If any of the default includes are used in `include`, then only that resource\n        will be retrieved. This is to allow requesting individual includes if they are\n        part of the default.\n\n        To suppress default includes, set `include` to `\"no_default\"`.\n\n        Parameters\n        ----------\n        country_code : str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_number : int or list[int], optional\n            Study years, by default None\n        audiences : int or list[int], optional\n            Audiences to retrieve by audience ID, by default None\n\n            The `Audiences` class can help with this filter.\n        brand_name : str, optional\n            Search by brand name, by default None\n        studies : int or list[int], optional\n            Fount studies IDs, by default None\n        filters : BrandscapeFilters or dict of filters, optional\n            BrandscapeFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        metric_keys: str or list[str], optional\n            Key or list of keys for the metrics included in the response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `brandscape-data` endpoint results.\n\n        Raises\n        ------\n        ValidationError\n            If used with an invalid combination of parameters (see above)\n        \"\"\"\n\n        filters = _filters.BrandscapeFilters.ensure(\n            filters,\n            country_code=country_code,\n            year_number=year_number,\n            audiences=audiences,\n            brand_name=brand_name,\n            studies=studies,\n        )\n\n        query: Query[_filters.BrandscapeFilters] = Query(\n            filters=filters,\n            fields=fields,\n            include=_default_include(include, BRANDSCAPE_DEFAULTS),\n            metric_keys=metric_keys,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"brandscape-data\", query)\n\n        # Prefix 'global' to avoid clashing with 'brand_name' on 'brand' includes\n        return parse_response(items, \"global\", expand=stack_data)\n\n    async def categories(\n        self,\n        name: Optional[str] = None,\n        category_id: Optional[int] = None,\n        sector: OptionalListOr[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.CategoriesFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `categories` endpoint.\n\n        Note that this endpoint has a default set of `include` resources:\n        - `sector`\n\n        Any additional valid includes will be added to the default set.\n\n        If any of the default includes are used in `include`, then only that resource\n        will be retrieved. This is to allow requesting individual includes if they are\n        part of the default.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search categories by name, by default None\n        category_id : int, optional\n            Fount category ID, by default None\n\n            If an category ID is provided, only that category will be returned\n        sector : int or list[int], optional\n            Filter categories by sector ID, by default None\n        filters : CategoriesFilters or dict of filters, optional\n            CategoriesFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `categories` endpoint results.\n        \"\"\"\n\n        filters = _filters.CategoriesFilters.ensure(\n            filters,\n            name=name,\n            sector=sector,\n        )\n\n        query: Query[_filters.CategoriesFilters] = Query(\n            id=category_id,\n            filters=filters,\n            fields=fields,\n            include=_default_include(include, CATEGORIES_DEFAULTS),\n            **kwargs,\n        )\n\n        items = await self._client.query(\"categories\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def collections(\n        self,\n        name: Optional[str] = None,\n        collection_id: Optional[int] = None,\n        public: Literal[0, 1] = 0,\n        shared_with_me: Literal[0, 1] = 0,\n        mine: Literal[0, 1] = 0,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.CollectionsFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `collections` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search collections by name, by default None\n        collection_id : int, optional\n            Fount collection ID, by default None\n\n            If an collection ID is provided, only that collection will be returned\n        public : Literal[0, 1], optional\n            Return public collections only, by default 0\n        shared_with_me : Literal[0, 1], optional\n            Only return collections that have been shared with the user, by default 0\n        mine : Literal[0, 1], optional\n            Only return collections created by the user, by default 0\n\n        filters : CollectionsFilters or dict of filters, optional\n            CollectionsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `collections` endpoint results.\n        \"\"\"\n\n        filters = _filters.CollectionsFilters.ensure(\n            filters,\n            name=name,\n            public=public,\n            shared_with_me=shared_with_me,\n            mine=mine,\n        )\n\n        query: Query[_filters.CollectionsFilters] = Query(\n            id=collection_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"collections\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def sectors(\n        self,\n        name: Optional[str] = None,\n        sector_id: Optional[int] = None,\n        in_most_influential: Literal[0, 1] = 0,\n        not_in_most_influential: Literal[0, 1] = 0,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.SectorsFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `sectors` endpoint.\n\n        Parameters\n        ----------\n        name : str, optional\n            Search sectors by name, by default None\n        sector_id : int, optional\n            Fount sectors ID, by default None\n\n            If a sector ID is provided, only that sector will be returned\n        in_most_influential : Literal[0, 1], optional\n            Sectors that are part of the Most Influential lists, by default 0\n        not_in_most_influential : Literal[0, 1], optional\n            Sectors that are not part of the Most Influential lists, by default 0\n        filters : SectorsFilters or dict of filters, optional\n            SectorsFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `sectors` endpoint results.\n        \"\"\"\n\n        filters = _filters.SectorsFilters.ensure(\n            filters,\n            name=name,\n            in_most_influential=in_most_influential,\n            not_in_most_influential=not_in_most_influential,\n        )\n\n        query: Query[_filters.SectorsFilters] = Query(\n            id=sector_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"sectors\", query)\n\n        return parse_response(items, expand=stack_data)\n\n    async def studies(\n        self,\n        country_codes: OptionalListOr[str] = None,\n        year_numbers: OptionalListOr[int] = None,\n        full_year: Literal[0, 1] = 0,\n        study_id: Optional[int] = None,\n        *,\n        filters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\n        fields: OptionalListOr[str] = None,\n        include: OptionalListOr[str] = None,\n        stack_data: bool = False,\n        **kwargs: Unpack[CommonQueryParams],\n    ) -&gt; \"DataFrame\":\n        \"\"\"Query the Fount `studies` endpoint.\n\n        Parameters\n        ----------\n        country_codes: str or list[str], optional\n            ISO-3166-1 alpha-2 country codes, by default None\n        year_numbers : int or list[int], optional\n            Study years, by default None\n        full_year : Literal[0, 1], optional\n            Include or exclude studies which are not \"full year\" studies,\n            such as US quarterly studies or special studies, by default 0\n\n            A value of 1 will filter non-full-year studies.\n        study_id : int, optional\n            Fount study ID, by default None\n            If a study ID is provided, only that study will be returned\n        filters : StudiesFilters or dict of filters, optional\n            StudiesFilters object or dictionary of filter parameters, by default None\n        fields : str or list[str], optional\n            Fields to retrieve in API response, by default None\n\n            Only specified fields are returned.\n            If `fields` is None, all fields are returned.\n        include : str or list[str], optional\n            Additional resources to include in API response, by default None\n        stack_data : bool, optional\n            Whether to expand nested lists into new dictionaries, by default False\n        **kwargs\n            Additional parameters to pass to the Query. See `Other Parameters`.\n            For any filters, use the `filters` parameter.\n\n        Other Parameters\n        ----------------\n        page : int, optional\n            Page number to fetch, by default None\n        per_page : int, optional\n            Number of results per page, by default None\n        max_pages : int, optional\n            Max number of results to return, by default None\n        sort : str, optional\n            Sort response by field, by default None\n\n            To sort in descending (highest first) order, use a `-` before the field name:\n\n            `sort=\"-differentiation_rank\"`\n\n            Sorts by item ID by default.\n\n        Returns\n        -------\n        pandas.DataFrame\n            DataFrame with `studies` endpoint results.\n        \"\"\"\n        filters = _filters.StudiesFilters.ensure(\n            filters,\n            country_codes=country_codes,\n            year_numbers=year_numbers,\n            full_year=full_year,\n        )\n\n        query: Query[_filters.StudiesFilters] = Query(\n            id=study_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            **kwargs,\n        )\n\n        items = await self._client.query(\"studies\", query)\n\n        return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.per_page","title":"<code>per_page: int</code>  <code>property</code> <code>writable</code>","text":"<p>Default number of items to retrieve per page.</p>"},{"location":"reference/client/#client.Client.verbose","title":"<code>verbose: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Show progress bar when making requests.</p>"},{"location":"reference/client/#client.Client.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Close existing HTTP connections.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close existing HTTP connections.\"\"\"\n    return await self._client.aclose()\n</code></pre>"},{"location":"reference/client/#client.Client.audiences","title":"<code>audiences(name=None, audience_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search audiences by name, by default None</p> <code>None</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, by default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, by default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict of filters</code> <p>AudiencesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def audiences(\n    self,\n    name: Optional[str] = None,\n    audience_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `audiences` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search audiences by name, by default None\n    audience_id : int, optional\n        Fount audience ID, by default None\n\n        If an audience ID is provided, only that audience will be returned\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n    filters : AudiencesFilters or dict of filters, optional\n        AudiencesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results.\n    \"\"\"\n\n    filters = _filters.AudiencesFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        inactive=inactive,\n        public=public,\n        private=private,\n        groups=groups,\n    )\n\n    query: Query[_filters.AudiencesFilters] = Query(\n        id=audience_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"audiences\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brand_metric_groups","title":"<code>brand_metric_groups(name=None, group_id=None, active=0, inactive=0, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metric-groups</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brand metric groups by name, by default None</p> <code>None</code> <code>group_id</code> <code>int</code> <p>Fount metric group ID, by default None</p> <p>If an metric group ID is provided, only that metric group will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metric groups only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive brand metric groups only if set to <code>1</code>, by default 0</p> <code>0</code> <code>filters</code> <code>BrandMetricGroupsFilters or dict of filters</code> <p>BrandMetricGroupsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metric-groups</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brand_metric_groups(\n    self,\n    name: Optional[str] = None,\n    group_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricGroupsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metric-groups` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brand metric groups by name, by default None\n    group_id : int, optional\n        Fount metric group ID, by default None\n\n        If an metric group ID is provided, only that metric group will be returned\n    active : Literal[0, 1], optional\n        Return active brand metric groups only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metric groups only if set to `1`, by default 0\n    filters : BrandMetricGroupsFilters or dict of filters, optional\n        BrandMetricGroupsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metric-groups` endpoint results.\n    \"\"\"\n\n    filters = _filters.BrandMetricGroupsFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        inactive=inactive,\n    )\n\n    query: Query[_filters.BrandMetricGroupsFilters] = Query(\n        id=group_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brand-metric-groups\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brand_metrics","title":"<code>brand_metrics(name=None, metric_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metrics</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brand metrics by name, by default None</p> <code>None</code> <code>metric_id</code> <code>int</code> <p>Fount metric ID, by default None</p> <p>If an metric ID is provided, only that metric will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Brand metrics group ID or list of Brand metrics group IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandMetricsFilters or dict of filters</code> <p>BrandMetricsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metrics</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brand_metrics(\n    self,\n    name: Optional[str] = None,\n    metric_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metrics` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brand metrics by name, by default None\n    metric_id : int, optional\n        Fount metric ID, by default None\n\n        If an metric ID is provided, only that metric will be returned\n    active : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Brand metrics group ID or list of Brand metrics group IDs, by default None\n    filters : BrandMetricsFilters or dict of filters, optional\n        BrandMetricsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metrics` endpoint results.\n    \"\"\"\n\n    filters = _filters.BrandMetricsFilters.ensure(\n        filters,\n        name=name,\n        active=active,\n        inactive=inactive,\n        public=public,\n        private=private,\n        groups=groups,\n    )\n\n    query: Query[_filters.BrandMetricsFilters] = Query(\n        id=metric_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brand-metrics\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brands","title":"<code>brands(name=None, country_codes=None, year_numbers=None, brand_id=None, studies=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search brands by name, by default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, by default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict of filters</code> <p>BrandsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brands(\n    self,\n    name: Optional[str] = None,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    brand_id: Optional[int] = None,\n    studies: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brands` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search brands by name, by default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    brand_id : int, optional\n        Fount brand ID, by default None\n\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, by default None\n    filters : BrandsFilters or dict of filters, optional\n        BrandsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results.\n    \"\"\"\n\n    filters = _filters.BrandsFilters.ensure(\n        filters,\n        name=name,\n        country_codes=country_codes,\n        year_numbers=year_numbers,\n        studies=studies,\n    )\n\n    query: Query[_filters.BrandsFilters] = Query(\n        id=brand_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brands\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.brandscape_data","title":"<code>brandscape_data(country_code=None, year_number=None, audiences=None, brand_name=None, studies=None, *, filters=None, fields=None, include=None, metric_keys=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 100 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code> - <code>audience</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, by default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, by default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict of filters</code> <p>BrandscapeFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def brandscape_data(\n    self,\n    country_code: OptionalListOr[str] = None,\n    year_number: OptionalListOr[int] = None,\n    audiences: OptionalListOr[int] = None,\n    brand_name: Optional[str] = None,\n    studies: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    metric_keys: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brandscape-data` endpoint.\n\n    This endpoint requires at least one of the following combinations of filters:\n\n    - Study + Audience + Brand + Category\n    - Country + Year + Audience\n    - Brand + Audience + Country + Year\n\n    You should read these from left to right. A combination of \"Study + Audience\"\n    worksjust as well as \"Study + Audience + Brand\".\n    However, \"Category + Audience\" will not.\n\n    If you use Country or Year filters, you must use both filters together.\n\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 100 standard audiences).\n\n    The `Audiences` class is provided to make it easier to filter audiences.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n    - `audience`\n\n    Any additional valid includes will be added to the default set.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_number : int or list[int], optional\n        Study years, by default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, by default None\n\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, by default None\n    studies : int or list[int], optional\n        Fount studies IDs, by default None\n    filters : BrandscapeFilters or dict of filters, optional\n        BrandscapeFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results.\n\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\n\n    filters = _filters.BrandscapeFilters.ensure(\n        filters,\n        country_code=country_code,\n        year_number=year_number,\n        audiences=audiences,\n        brand_name=brand_name,\n        studies=studies,\n    )\n\n    query: Query[_filters.BrandscapeFilters] = Query(\n        filters=filters,\n        fields=fields,\n        include=_default_include(include, BRANDSCAPE_DEFAULTS),\n        metric_keys=metric_keys,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"brandscape-data\", query)\n\n    # Prefix 'global' to avoid clashing with 'brand_name' on 'brand' includes\n    return parse_response(items, \"global\", expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.categories","title":"<code>categories(name=None, category_id=None, sector=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>categories</code> endpoint.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>sector</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search categories by name, by default None</p> <code>None</code> <code>category_id</code> <code>int</code> <p>Fount category ID, by default None</p> <p>If an category ID is provided, only that category will be returned</p> <code>None</code> <code>sector</code> <code>int or list[int]</code> <p>Filter categories by sector ID, by default None</p> <code>None</code> <code>filters</code> <code>CategoriesFilters or dict of filters</code> <p>CategoriesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>categories</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def categories(\n    self,\n    name: Optional[str] = None,\n    category_id: Optional[int] = None,\n    sector: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.CategoriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `categories` endpoint.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `sector`\n\n    Any additional valid includes will be added to the default set.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search categories by name, by default None\n    category_id : int, optional\n        Fount category ID, by default None\n\n        If an category ID is provided, only that category will be returned\n    sector : int or list[int], optional\n        Filter categories by sector ID, by default None\n    filters : CategoriesFilters or dict of filters, optional\n        CategoriesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `categories` endpoint results.\n    \"\"\"\n\n    filters = _filters.CategoriesFilters.ensure(\n        filters,\n        name=name,\n        sector=sector,\n    )\n\n    query: Query[_filters.CategoriesFilters] = Query(\n        id=category_id,\n        filters=filters,\n        fields=fields,\n        include=_default_include(include, CATEGORIES_DEFAULTS),\n        **kwargs,\n    )\n\n    items = await self._client.query(\"categories\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.collections","title":"<code>collections(name=None, collection_id=None, public=0, shared_with_me=0, mine=0, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>collections</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search collections by name, by default None</p> <code>None</code> <code>collection_id</code> <code>int</code> <p>Fount collection ID, by default None</p> <p>If an collection ID is provided, only that collection will be returned</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public collections only, by default 0</p> <code>0</code> <code>shared_with_me</code> <code>Literal[0, 1]</code> <p>Only return collections that have been shared with the user, by default 0</p> <code>0</code> <code>mine</code> <code>Literal[0, 1]</code> <p>Only return collections created by the user, by default 0</p> <code>0</code> <p>filters : CollectionsFilters or dict of filters, optional     CollectionsFilters object or dictionary of filter parameters, by default None fields : str or list[str], optional     Fields to retrieve in API response, by default None</p> <pre><code>Only specified fields are returned.\nIf `fields` is None, all fields are returned.\n</code></pre> <p>include : str or list[str], optional     Additional resources to include in API response, by default None stack_data : bool, optional     Whether to expand nested lists into new dictionaries, by default False **kwargs     Additional parameters to pass to the Query. See <code>Other Parameters</code>.     For any filters, use the <code>filters</code> parameter.</p> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>collections</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def collections(\n    self,\n    name: Optional[str] = None,\n    collection_id: Optional[int] = None,\n    public: Literal[0, 1] = 0,\n    shared_with_me: Literal[0, 1] = 0,\n    mine: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.CollectionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `collections` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search collections by name, by default None\n    collection_id : int, optional\n        Fount collection ID, by default None\n\n        If an collection ID is provided, only that collection will be returned\n    public : Literal[0, 1], optional\n        Return public collections only, by default 0\n    shared_with_me : Literal[0, 1], optional\n        Only return collections that have been shared with the user, by default 0\n    mine : Literal[0, 1], optional\n        Only return collections created by the user, by default 0\n\n    filters : CollectionsFilters or dict of filters, optional\n        CollectionsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `collections` endpoint results.\n    \"\"\"\n\n    filters = _filters.CollectionsFilters.ensure(\n        filters,\n        name=name,\n        public=public,\n        shared_with_me=shared_with_me,\n        mine=mine,\n    )\n\n    query: Query[_filters.CollectionsFilters] = Query(\n        id=collection_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"collections\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.raw_query","title":"<code>raw_query(endpoint, params)</code>  <code>async</code>","text":"<p>Perform a raw GET query to the WPPBAV Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>params</code> <code>Query</code> <p>Query <code>pydantic</code> model with query parameters.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def raw_query(self, endpoint: str, params: Query[F]) -&gt; List[JSONDict]:\n    \"\"\"Perform a raw GET query to the WPPBAV Fount API, returning\n    the response JSON data instead of a `pandas` DataFrame.\n\n    Parameters\n    ----------\n    endpoint : str\n        Endpoint name\n    params : Query\n        Query `pydantic` model with query parameters.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\n    return list(await self._client.query(endpoint, params))\n</code></pre>"},{"location":"reference/client/#client.Client.sectors","title":"<code>sectors(name=None, sector_id=None, in_most_influential=0, not_in_most_influential=0, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>sectors</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search sectors by name, by default None</p> <code>None</code> <code>sector_id</code> <code>int</code> <p>Fount sectors ID, by default None</p> <p>If a sector ID is provided, only that sector will be returned</p> <code>None</code> <code>in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are part of the Most Influential lists, by default 0</p> <code>0</code> <code>not_in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are not part of the Most Influential lists, by default 0</p> <code>0</code> <code>filters</code> <code>SectorsFilters or dict of filters</code> <p>SectorsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>sectors</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def sectors(\n    self,\n    name: Optional[str] = None,\n    sector_id: Optional[int] = None,\n    in_most_influential: Literal[0, 1] = 0,\n    not_in_most_influential: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.SectorsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `sectors` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search sectors by name, by default None\n    sector_id : int, optional\n        Fount sectors ID, by default None\n\n        If a sector ID is provided, only that sector will be returned\n    in_most_influential : Literal[0, 1], optional\n        Sectors that are part of the Most Influential lists, by default 0\n    not_in_most_influential : Literal[0, 1], optional\n        Sectors that are not part of the Most Influential lists, by default 0\n    filters : SectorsFilters or dict of filters, optional\n        SectorsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `sectors` endpoint results.\n    \"\"\"\n\n    filters = _filters.SectorsFilters.ensure(\n        filters,\n        name=name,\n        in_most_influential=in_most_influential,\n        not_in_most_influential=not_in_most_influential,\n    )\n\n    query: Query[_filters.SectorsFilters] = Query(\n        id=sector_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"sectors\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/client/#client.Client.studies","title":"<code>studies(country_codes=None, year_numbers=None, full_year=0, study_id=None, *, filters=None, fields=None, include=None, stack_data=False, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, by default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, by default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict of filters</code> <p>StudiesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results.</p> Source code in <code>bavapi\\client.py</code> <pre><code>async def studies(\n    self,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    full_year: Literal[0, 1] = 0,\n    study_id: Optional[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `studies` endpoint.\n\n    Parameters\n    ----------\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, by default 0\n\n        A value of 1 will filter non-full-year studies.\n    study_id : int, optional\n        Fount study ID, by default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict of filters, optional\n        StudiesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results.\n    \"\"\"\n    filters = _filters.StudiesFilters.ensure(\n        filters,\n        country_codes=country_codes,\n        year_numbers=year_numbers,\n        full_year=full_year,\n    )\n\n    query: Query[_filters.StudiesFilters] = Query(\n        id=study_id,\n        filters=filters,\n        fields=fields,\n        include=include,\n        **kwargs,\n    )\n\n    items = await self._client.query(\"studies\", query)\n\n    return parse_response(items, expand=stack_data)\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>Exceptions for handling errors with the WPPBAV Fount API.</p>"},{"location":"reference/exceptions/#exceptions.APIError","title":"<code>APIError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception for errors interacting with APIs.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class APIError(Exception):\n    \"\"\"Exception for errors interacting with APIs.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.DataNotFoundError","title":"<code>DataNotFoundError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception for when the request returns no data.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class DataNotFoundError(Exception):\n    \"\"\"Exception for when the request returns no data.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.RateLimitExceededError","title":"<code>RateLimitExceededError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception for when the request exceeds the rate limit.</p> Source code in <code>bavapi\\exceptions.py</code> <pre><code>class RateLimitExceededError(Exception):\n    \"\"\"Exception for when the request exceeds the rate limit.\"\"\"\n</code></pre>"},{"location":"reference/filters/","title":"filters","text":"<p>Filter objects for WPPBAV Fount API queries based on <code>pydantic</code>.</p> <p>All endpoint filters are subclasses of <code>FountFilters</code>.</p> <p>You can use any endpoint filter class with <code>raw_query</code> functions and methods, but you must use endpoint-specific filters for each endpoint function or method.</p> <p>Examples:</p> <p>Use <code>BrandsFilters</code> with the <code>brands</code> endpoint:</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.BrandsFilters(name=\"Facebook\"))\n</code></pre> <p><code>FountFilters</code> is compatible with all endpoints (including <code>raw_query</code>):</p> <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.FountFilters(name=\"Facebook\"))\n</code></pre> <p>Using the wrong filter can lead to unexpected results:</p> <pre><code>&gt;&gt;&gt; bavapi.brands(\"TOKEN\", filters=bavapi.filters.CategoriesFilters(country_codes=\"UK\"))\n</code></pre> <p>The above example may work, but it is highly discouraged.</p>"},{"location":"reference/filters/#filters.AudiencesFilters","title":"<code>AudiencesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/audiences for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>private</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>groups</code> <code>(int or list[int], optional)</code> <p>Audience group ID or list of audience group IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class AudiencesFilters(FountFilters):\n    \"\"\"Filters for the `brands` endpoint.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/audiences&gt;\n    for more info.\n\n    Attributes\n    ----------\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    active: Literal[0, 1] = 0\n    inactive: Literal[0, 1] = 0\n    public: Literal[0, 1] = 0\n    private: Literal[0, 1] = 0\n    groups: OptionalListOr[int] = None\n</code></pre>"},{"location":"reference/filters/#filters.BrandMetricGroupsFilters","title":"<code>BrandMetricGroupsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brand-metric-groups</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brand-metric-groups for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active brand metrics when set to <code>1</code>, by default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive brand metrics when set to <code>1</code>, by default 0</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandMetricGroupsFilters(FountFilters):\n    \"\"\"Filters for the `brand-metric-groups` endpoint.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brand-metric-groups&gt;\n    for more info.\n\n    Attributes\n    ----------\n    active : Literal[0, 1], optional\n        Return active brand metrics when set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metrics when set to `1`, by default 0\n    \"\"\"\n\n    active: Literal[0, 1] = 0\n    inactive: Literal[0, 1] = 0\n</code></pre>"},{"location":"reference/filters/#filters.BrandMetricsFilters","title":"<code>BrandMetricsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brand-metrics</code> endpoint.</p> <p><code>groups</code> filters by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brand-metrics for more info.</p> <p>Attributes:</p> Name Type Description <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active brand metrics when set to <code>1</code>, by default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive brand metrics when set to <code>1</code>, by default 0</p> <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return public brand metrics when set to <code>1</code>, by default 0</p> <code>private</code> <code>(Literal[0, 1], optional)</code> <p>Return private brand metrics when set to <code>1</code>, by default 0</p> <code>groups</code> <code>(int or list[int], optional)</code> <p>Fount brand metric group ID or list of group IDs, by default None</p> <code>current</code> <code>(Literal[0, 1], optional)</code> <p>Return current brand metrics when set to <code>1</code>, by default 0</p> <code>legacy</code> <code>(Literal[0, 1], optional)</code> <p>Return legacy brand metrics when set to <code>1</code>, by default 0</p> <code>core</code> <code>(Literal[0, 1], optional)</code> <p>Return core brand metrics when set to <code>1</code>, by default 0</p> <code>custom</code> <code>(Literal[0, 1], optional)</code> <p>Return custom brand metrics when set to <code>1</code>, by default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandMetricsFilters(FountFilters):\n    \"\"\"Filters for the `brand-metrics` endpoint.\n\n    `groups` filters by the Fount IDs of the specific resources.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brand-metrics&gt;\n    for more info.\n\n    Attributes\n    ----------\n    active : Literal[0, 1], optional\n        Return active brand metrics when set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metrics when set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return public brand metrics when set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return private brand metrics when set to `1`, by default 0\n    groups : int or list[int], optional\n        Fount brand metric group ID or list of group IDs, by default None\n    current : Literal[0, 1], optional\n        Return current brand metrics when set to `1`, by default 0\n    legacy : Literal[0, 1], optional\n        Return legacy brand metrics when set to `1`, by default 0\n    core : Literal[0, 1], optional\n        Return core brand metrics when set to `1`, by default 0\n    custom : Literal[0, 1], optional\n        Return custom brand metrics when set to `1`, by default 0\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    active: Literal[0, 1] = 0\n    inactive: Literal[0, 1] = 0\n    public: Literal[0, 1] = 0\n    private: Literal[0, 1] = 0\n    groups: OptionalListOr[int] = None\n    current: Literal[0, 1] = 0\n    legacy: Literal[0, 1] = 0\n    core: Literal[0, 1] = 0\n    custom: Literal[0, 1] = 0\n</code></pre>"},{"location":"reference/filters/#filters.BrandsFilters","title":"<code>BrandsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>brands</code> endpoint.</p> <p>Filters other than <code>country_codes</code> and <code>year_numbers</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brands for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_numbers</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), by default None</p> <code>categories</code> <code>(int or list[int], optional)</code> <p>Fount category ID or list of category IDs, by default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, by default None</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, by default None</p> <code>sectors</code> <code>(int or list[int], optional)</code> <p>Fount sector ID or list of sector IDs, by default None</p> <code>studies</code> <code>(int or list[int], optional)</code> <p>Fount study ID or list of study IDs, by default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandsFilters(FountFilters):\n    \"\"\"Filters for the `brands` endpoint.\n\n    Filters other than `country_codes` and `year_numbers` filter by\n    the Fount IDs of the specific resources.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brands&gt;\n    for more info.\n\n    Attributes\n    ----------\n    country_codes : str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    categories : int or list[int], optional\n        Fount category ID or list of category IDs, by default None\n    countries : int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n    regions : int or list[int], optional\n        Fount region ID or list of region IDs, by default None\n    sectors : int or list[int], optional\n        Fount sector ID or list of sector IDs, by default None\n    studies : int or list[int], optional\n        Fount study ID or list of study IDs, by default None\n    years : int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    country_codes: OptionalListOr[str] = None\n    year_numbers: OptionalListOr[int] = None\n    categories: OptionalListOr[int] = None\n    countries: OptionalListOr[int] = None\n    regions: OptionalListOr[int] = None\n    sectors: OptionalListOr[int] = None\n    studies: OptionalListOr[int] = None\n    years: OptionalListOr[int] = None\n</code></pre>"},{"location":"reference/filters/#filters.BrandscapeFilters","title":"<code>BrandscapeFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>audiences</code>, <code>countries</code>, <code>studies</code>, <code>years</code>, <code>brands</code> and <code>categories</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/brandscape-data for more info.</p> <p>The <code>brandscape-data</code> endpoint requires the use of, at minimum, these filters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 30 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Attributes:</p> Name Type Description <code>country_code</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_number</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), by default None</p> <code>audiences</code> <code>(int or list[int], optional)</code> <p>Fount ID of the desired audience, by default None</p> <p>The <code>Audiences</code> class can help with using audience IDs.</p> <code>brand_name</code> <code>(str, optional)</code> <p>Perform a search on the brand name, by default None</p> <code>brands</code> <code>(int or list[int], optional)</code> <p>Fount brand ID or list of brand IDs, by default None</p> <code>categories</code> <code>(int or list[int], optional)</code> <p>Fount category ID or list of category IDs, by default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, by default None</p> <p>The <code>Countries</code> class can help with using country IDs.</p> <code>studies</code> <code>(int or list[int], optional)</code> <p>Fount study ID or list of study IDs, by default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class BrandscapeFilters(FountFilters):\n    \"\"\"Filters for the `studies` endpoint.\n\n    `audiences`, `countries`, `studies`, `years`, `brands` and `categories` filter by\n    the Fount IDs of the specific resources.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/brandscape-data&gt;\n    for more info.\n\n    The `brandscape-data` endpoint requires the use of, at minimum, these filters:\n\n    - Study + Audience + Brand + Category\n    - Country + Year + Audience\n    - Brand + Audience + Country + Year\n\n    You should read these from left to right. A combination of \"Study + Audience\"\n    worksjust as well as \"Study + Audience + Brand\".\n    However, \"Category + Audience\" will not.\n\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 30 standard audiences).\n\n    The `Audiences` class is provided to make it easier to filter audiences.\n\n    Attributes\n    ----------\n    country_code : str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_number : int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    audiences : int or list[int], optional\n        Fount ID of the desired audience, by default None\n\n        The `Audiences` class can help with using audience IDs.\n    brand_name : str, optional\n        Perform a search on the brand name, by default None\n    brands : int or list[int], optional\n        Fount brand ID or list of brand IDs, by default None\n    categories : int or list[int], optional\n        Fount category ID or list of category IDs, by default None\n    countries : int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n\n        The `Countries` class can help with using country IDs.\n    studies : int or list[int], optional\n        Fount study ID or list of study IDs, by default None\n    years : int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    country_code: OptionalListOr[str] = None\n    year_number: OptionalListOr[int] = None\n    audiences: OptionalListOr[int] = None\n    brand_name: Optional[str] = None\n    studies: OptionalListOr[int] = None\n    countries: OptionalListOr[int] = None\n    years: OptionalListOr[int] = None\n    brands: OptionalListOr[int] = None\n    categories: OptionalListOr[int] = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _check_params(cls, values: Dict[str, object]) -&gt; Dict[str, object]:\n        using_country_year = bool(\n            set(values).intersection(\n                (\"country_code\", \"countries\", \"year_number\", \"years\")\n            )\n        )\n\n        if not (\n            \"brands\" in values\n            or \"brand_name\" in values\n            or \"studies\" in values\n            or using_country_year\n        ):\n            raise ValueError(\n                \"You need to apply either the `brands`, or `studies`, or `brand_name` \"\n                \"filters, or the `country_code`/`countries` \"\n                \"and `year_number`/`years` filters together.\"\n            )\n\n        if using_country_year:\n            if not (\n                (\"country_code\" in values or \"countries\" in values)\n                and (\"year_number\" in values or \"years\" in values)\n            ):\n                raise ValueError(\n                    \"`country_code`/`countries` and `year_number`/`years` \"\n                    \"filters must be used together.\"\n                )\n\n        return values\n</code></pre>"},{"location":"reference/filters/#filters.CategoriesFilters","title":"<code>CategoriesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>categories</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/categories for more info.</p> <p>Attributes:</p> Name Type Description <code>sector</code> <code>(int or list[int], optional)</code> <p>Fount sector ID or list of sector IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class CategoriesFilters(FountFilters):\n    \"\"\"Filters for the `categories` endpoint.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/categories&gt;\n    for more info.\n\n    Attributes\n    ----------\n    sector : int or list[int], optional\n        Fount sector ID or list of sector IDs, by default None\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    sector: OptionalListOr[int] = None\n</code></pre>"},{"location":"reference/filters/#filters.CollectionsFilters","title":"<code>CollectionsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>collections</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/collections for more info.</p> <p>Attributes:</p> Name Type Description <code>public</code> <code>(Literal[0, 1], optional)</code> <p>Return public collections only, by default 0</p> <code>shared_with_me</code> <code>(Literal[0, 1], optional)</code> <p>Only return collections that have been shared with the user, by default 0</p> <code>mine</code> <code>(Literal[0, 1], optional)</code> <p>Only return collections created by the user, by default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class CollectionsFilters(FountFilters):\n    \"\"\"Filters for the `collections` endpoint.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/collections&gt;\n    for more info.\n\n    Attributes\n    ----------\n    public : Literal[0, 1], optional\n        Return public collections only, by default 0\n    shared_with_me : Literal[0, 1], optional\n        Only return collections that have been shared with the user, by default 0\n    mine : Literal[0, 1], optional\n        Only return collections created by the user, by default 0\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    public: Literal[0, 1] = 0\n    shared_with_me: Literal[0, 1] = 0\n    mine: Literal[0, 1] = 0\n</code></pre>"},{"location":"reference/filters/#filters.FountFilters","title":"<code>FountFilters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base class for Fount API Filters.</p> <p>Can be used with <code>raw_query</code> endpoints.</p> <p>Attributes:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime, optional)</code> <p>Request items that have been updated since the specified date, by default None</p> <code>**kwargs</code> <code>str, int or float, or list of str, int or floats, optional</code> <p>Any additional filters to apply to the request, including for columns within the response data.</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class FountFilters(BaseModel):\n    \"\"\"Base class for Fount API Filters.\n\n    Can be used with `raw_query` endpoints.\n\n    Attributes\n    ----------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    **kwargs : str, int or float, or list of str, int or floats, optional\n        Any additional filters to apply to the request, including for columns within\n        the response data.\n    \"\"\"\n\n    # Allow arbitrary filters for compatibility with raw_query\n    model_config = {\"extra\": \"allow\"}\n\n    updated_since: DTValues = None\n\n    @field_validator(\"updated_since\", mode=\"before\")\n    @classmethod\n    def _parse_date(cls, value: DTValues) -&gt; Optional[str]:\n        if value is None:\n            return value\n        return parse_date(value)\n\n    @classmethod\n    def ensure(\n        cls: Type[F],\n        filters: Optional[FiltersOrMapping[\"FountFilters\"]],\n        **addl_filters: InputSequenceOrValues,\n    ) -&gt; Optional[F]:\n        \"\"\"Ensure `FountFilters` class from dictionary or other `FountFilters` class.\n\n        Defaults to values passed to `filters` when any additional filters overlap.\n\n        Parameters\n        ----------\n        filters : FountFilters or dict of filter values, optional\n            Dictionary of filters or `FountFilters` class.\n        **addl_filters : SequenceOrValues, optional\n            Additional filters to add to the new `FountFilters` instance.\n\n        Returns\n        -------\n        FountFilters, optional\n            `FountFilters` class or `None` if `filters` is `None` and no additional filters are passed.\n        \"\"\"\n        addl_filters = {k: v for k, v in addl_filters.items() if v}\n\n        if filters is None:\n            if not addl_filters:\n                return None\n            return cls(**addl_filters)  # type: ignore[arg-type]\n\n        new_filters = addl_filters.copy()\n\n        if isinstance(filters, Mapping):\n            new_filters.update(filters)\n        else:\n            new_filters.update(filters.model_dump(exclude_defaults=True))\n\n        return cls(**new_filters)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/filters/#filters.FountFilters.ensure","title":"<code>ensure(filters, **addl_filters)</code>  <code>classmethod</code>","text":"<p>Ensure <code>FountFilters</code> class from dictionary or other <code>FountFilters</code> class.</p> <p>Defaults to values passed to <code>filters</code> when any additional filters overlap.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FountFilters or dict of filter values</code> <p>Dictionary of filters or <code>FountFilters</code> class.</p> required <code>**addl_filters</code> <code>SequenceOrValues</code> <p>Additional filters to add to the new <code>FountFilters</code> instance.</p> <code>{}</code> <p>Returns:</p> Type Description <code>(FountFilters, optional)</code> <p><code>FountFilters</code> class or <code>None</code> if <code>filters</code> is <code>None</code> and no additional filters are passed.</p> Source code in <code>bavapi\\filters.py</code> <pre><code>@classmethod\ndef ensure(\n    cls: Type[F],\n    filters: Optional[FiltersOrMapping[\"FountFilters\"]],\n    **addl_filters: InputSequenceOrValues,\n) -&gt; Optional[F]:\n    \"\"\"Ensure `FountFilters` class from dictionary or other `FountFilters` class.\n\n    Defaults to values passed to `filters` when any additional filters overlap.\n\n    Parameters\n    ----------\n    filters : FountFilters or dict of filter values, optional\n        Dictionary of filters or `FountFilters` class.\n    **addl_filters : SequenceOrValues, optional\n        Additional filters to add to the new `FountFilters` instance.\n\n    Returns\n    -------\n    FountFilters, optional\n        `FountFilters` class or `None` if `filters` is `None` and no additional filters are passed.\n    \"\"\"\n    addl_filters = {k: v for k, v in addl_filters.items() if v}\n\n    if filters is None:\n        if not addl_filters:\n            return None\n        return cls(**addl_filters)  # type: ignore[arg-type]\n\n    new_filters = addl_filters.copy()\n\n    if isinstance(filters, Mapping):\n        new_filters.update(filters)\n    else:\n        new_filters.update(filters.model_dump(exclude_defaults=True))\n\n    return cls(**new_filters)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/filters/#filters.SectorsFilters","title":"<code>SectorsFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>sectors</code> endpoint.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/sectors for more info.</p> <p>Attributes:</p> Name Type Description <code>in_most_influential</code> <code>(Literal[0, 1], optional)</code> <p>Sectors that are part of the Most Influential lists, by default 0</p> <code>not_in_most_influential</code> <code>(Literal[0, 1], optional)</code> <p>Sectors that are not part of the Most Influential lists, by default 0</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class SectorsFilters(FountFilters):\n    \"\"\"Filters for the `sectors` endpoint.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/sectors&gt;\n    for more info.\n\n    Attributes\n    ----------\n    in_most_influential : Literal[0, 1], optional\n        Sectors that are part of the Most Influential lists, by default 0\n    not_in_most_influential : Literal[0, 1], optional\n        Sectors that are not part of the Most Influential lists, by default 0\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    in_most_influential: Literal[0, 1] = 0\n    not_in_most_influential: Literal[0, 1] = 0\n</code></pre>"},{"location":"reference/filters/#filters.StudiesFilters","title":"<code>StudiesFilters</code>","text":"<p>             Bases: <code>FountFilters</code></p> <p>Filters for the <code>studies</code> endpoint.</p> <p><code>years</code>, <code>countries</code> and <code>regions</code> filter by the Fount IDs of the specific resources.</p> <p>See https://developer.wppbav.com/docs/2.x/core-resources/studies for more info.</p> <p>Attributes:</p> Name Type Description <code>country_codes</code> <code>(str or list[str], optional)</code> <p>Two-letter ISO-3166 country code or list of country codes, by default None</p> <code>year_numbers</code> <code>(int or list[int], optional)</code> <p>Study years in numerical format (not IDs), by default None</p> <code>full_year</code> <code>(Literal[0, 1], optional)</code> <p>Return full year studies when set to <code>1</code> (excludes US quarterly), by default 0</p> <code>released</code> <code>(Literal[0, 1], optional)</code> <p>Return released studies when set to <code>1</code>, by default 0</p> <code>unreleased</code> <code>(Literal[0, 1], optional)</code> <p>Return unreleased studies when set to <code>1</code>, by default 0</p> <code>open_survey</code> <code>(Literal[0, 1], optional)</code> <p>Return studies with open brand requests when set to <code>1</code>, by default 0</p> <code>active</code> <code>(Literal[0, 1], optional)</code> <p>Return active audiences when set to <code>1</code>, by default 0</p> <code>inactive</code> <code>(Literal[0, 1], optional)</code> <p>Return inactive audiences when set to <code>1</code>, by default 0</p> <code>bav_study</code> <code>(Literal[0, 1], optional)</code> <p>Return full BAV studies when set to <code>1</code>, by default 0</p> <code>data_updated_since</code> <code>(DTValues, optional)</code> <p>Return studies updated since datetime value, by default None</p> <code>countries</code> <code>(int or list[int], optional)</code> <p>Fount country ID or list of country IDs, by default None</p> <code>regions</code> <code>(int or list[int], optional)</code> <p>Fount region ID or list of region IDs, by default None</p> <code>years</code> <code>(int or list[int], optional)</code> <p>Fount year ID or list of year IDs, by default None</p> <p>Other Parameters:</p> Name Type Description <code>updated_since</code> <code>(str, date or datetime)</code> <p>Request items that have been updated since the specified date, by default None</p> Source code in <code>bavapi\\filters.py</code> <pre><code>class StudiesFilters(FountFilters):\n    \"\"\"Filters for the `studies` endpoint.\n\n    `years`, `countries` and `regions` filter by the Fount IDs of the specific resources.\n\n    See &lt;https://developer.wppbav.com/docs/2.x/core-resources/studies&gt;\n    for more info.\n\n    Attributes\n    ----------\n    country_codes : str or list[str], optional\n        Two-letter ISO-3166 country code or list of country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years in numerical format (not IDs), by default None\n    full_year : Literal[0, 1], optional\n        Return full year studies when set to `1` (excludes US quarterly), by default 0\n    released : Literal[0, 1], optional\n        Return released studies when set to `1`, by default 0\n    unreleased : Literal[0, 1], optional\n        Return unreleased studies when set to `1`, by default 0\n    open_survey : Literal[0, 1], optional\n        Return studies with open brand requests when set to `1`, by default 0\n    active : Literal[0, 1], optional\n        Return active audiences when set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive audiences when set to `1`, by default 0\n    bav_study : Literal[0, 1], optional\n        Return full BAV studies when set to `1`, by default 0\n    data_updated_since : DTValues, optional\n        Return studies updated since datetime value, by default None\n    countries : int or list[int], optional\n        Fount country ID or list of country IDs, by default None\n    regions : int or list[int], optional\n        Fount region ID or list of region IDs, by default None\n    years : int or list[int], optional\n        Fount year ID or list of year IDs, by default None\n\n    Other Parameters\n    ----------------\n    updated_since : str, date or datetime, optional\n        Request items that have been updated since the specified date, by default None\n    \"\"\"\n\n    country_codes: OptionalListOr[str] = None\n    year_numbers: OptionalListOr[int] = None\n    full_year: Literal[0, 1] = 0\n    released: Literal[0, 1] = 0\n    unreleased: Literal[0, 1] = 0\n    open_survey: Literal[0, 1] = 0\n    active: Literal[0, 1] = 0\n    inactive: Literal[0, 1] = 0\n    bav_study: Literal[0, 1] = 0\n    data_updated_since: DTValues = None\n    years: OptionalListOr[int] = None\n    countries: OptionalListOr[int] = None\n    regions: OptionalListOr[int] = None\n\n    @field_validator(\"data_updated_since\", mode=\"before\")\n    @classmethod\n    def _parse_date(cls, value: DTValues) -&gt; Optional[str]:\n        if value is None:\n            return value\n        return parse_date(value)\n</code></pre>"},{"location":"reference/http/","title":"http","text":"<p>Class for interacting with paginated APIs over HTTP.</p>"},{"location":"reference/http/#http.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>HTTP client for interacting with paginated API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the API.</p> <code>''</code> <code>per_page</code> <code>int</code> <p>Default number of entries per page, by default 100</p> <code>100</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 5.0</p> <code>5.0</code> <code>verify</code> <code>bool or str</code> <p>Verify SSL credentials, by default True</p> <p>Also accepts a path string to an SSL certificate file.</p> <code>True</code> <code>headers</code> <code>dict[str, str]</code> <p>Collection of headers to send with each request, by default None</p> <code>None</code> <code>client</code> <code>AsyncClient</code> <p>Authenticated <code>httpx.AsyncClient</code>, by default None</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> Source code in <code>bavapi\\http.py</code> <pre><code>class HTTPClient:\n    \"\"\"HTTP client for interacting with paginated API.\n\n    Parameters\n    ----------\n    base_url : str\n        The base URL of the API.\n    per_page : int, optional\n        Default number of entries per page, by default 100\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 5.0\n    verify : bool or str, optional\n        Verify SSL credentials, by default True\n\n        Also accepts a path string to an SSL certificate file.\n    headers : dict[str, str], optional\n        Collection of headers to send with each request, by default None\n    client : httpx.AsyncClient, optional\n        Authenticated `httpx.AsyncClient`, by default None\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    \"\"\"\n\n    __slots__ = (\"client\", \"per_page\", \"verbose\")\n\n    C = TypeVar(\"C\", bound=\"HTTPClient\")\n\n    @overload\n    def __init__(\n        self,\n        base_url: str,\n        per_page: int = 100,\n        timeout: float = 5.0,\n        verify: Union[bool, str] = True,\n        *,\n        headers: Optional[Dict[str, str]] = None,\n        verbose: bool = True,\n    ) -&gt; None:\n        ...\n\n    @overload\n    def __init__(\n        self,\n        *,\n        client: httpx.AsyncClient = ...,\n        per_page: int = 100,\n        verbose: bool = True,\n    ) -&gt; None:\n        ...\n\n    def __init__(\n        self,\n        base_url: str = \"\",\n        per_page: int = 100,\n        timeout: float = 5.0,\n        verify: Union[bool, str] = True,\n        *,\n        headers: Optional[Dict[str, str]] = None,\n        client: Optional[httpx.AsyncClient] = None,\n        verbose: bool = True,\n    ) -&gt; None:\n        self.per_page = per_page\n        self.verbose = verbose\n\n        if client is not None:\n            self.client = client\n        else:\n            self.client = httpx.AsyncClient(\n                headers=headers,\n                timeout=timeout,\n                verify=verify,\n                base_url=base_url,\n            )\n\n    async def __aenter__(self: C) -&gt; C:\n        await self.client.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_value: Optional[BaseException] = None,\n        traceback: \"Optional[TracebackType]\" = None,\n    ) -&gt; None:\n        await self.client.__aexit__(exc_type, exc_value, traceback)\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Asynchronously close all client connections.\"\"\"\n        return await self.client.aclose()\n\n    async def get(self, endpoint: str, params: _Query) -&gt; httpx.Response:\n        \"\"\"Perform GET request on the given endpoint.\n\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n\n        Returns\n        -------\n        httpx.Response\n            Requested response object.\n\n        Raises\n        ------\n        APIError\n            If request fails.\n        \"\"\"\n        if params.item_id is not None:\n            resp = await self.client.get(f\"{endpoint}/{params.item_id}\")\n        else:\n            resp = await self.client.get(\n                endpoint,\n                params=params.to_params(endpoint),\n            )\n\n        if resp.status_code != 200:\n            try:\n                message = resp.json()[\"message\"]\n            except (KeyError, JSONDecodeError):\n                message = \"An error occurred with the Fount.\"\n\n            raise APIError(f\"Error {resp.status_code}:\\n{message}\\nurl={resp.url}\")\n\n        return resp\n\n    async def get_pages(\n        self, endpoint: str, params: _Query, n_pages: int\n    ) -&gt; List[httpx.Response]:\n        \"\"\"Perform GET requests for a given number of pages on an endpoint.\n\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n        n_pages : int\n            Number of pages to request.\n\n        Returns\n        -------\n        list[httpx.Response]\n            List of response objects.\n        \"\"\"\n        tasks = [\n            asyncio.create_task(self.get(endpoint, p))\n            for p in params.paginated(self.per_page, n_pages)\n        ]\n        try:\n            return await tqdm.gather(\n                *tasks, desc=f\"{endpoint} query\", disable=not self.verbose\n            )\n        except Exception as exc:\n            for task in tasks:\n                task.cancel()\n\n            raise exc\n\n    async def query(self, endpoint: str, params: _Query) -&gt; Iterator[JSONDict]:\n        \"\"\"Perform a paginated GET request on the given endpoint.\n\n        Parameters\n        ----------\n        endpoint : str\n            Path to endpoint.\n        params : Query\n            Request parameters.\n\n        Returns\n        -------\n        Iterator[JSONDict]\n            An iterator of JSONDict objects.\n\n        Raises\n        ------\n        APIError\n            If any request fails.\n        DataNotFoundError\n            If response data is empty.\n        RateLimitExceededError\n            If response would exceed the rate limit.\n        \"\"\"\n        resp = await self.get(endpoint, params=params)\n\n        payload: Dict[str, JSONData] = resp.json()\n        data: JSONData = payload[\"data\"]\n\n        if not data:\n            raise DataNotFoundError(\"Your query returned no results.\")\n\n        if isinstance(data, dict):\n            return iter((data,))\n\n        meta = cast(JSONDict, payload[\"meta\"])\n        total = cast(int, meta[\"total\"])\n\n        if params.page or len(data) == total:\n            return iter(data)\n\n        n_pages = params.max_pages or math.ceil(\n            (total) / (params.per_page or self.per_page)\n        )\n\n        if n_pages &gt; (limit_remaining := int(resp.headers[\"x-ratelimit-remaining\"])):\n            raise RateLimitExceededError(\n                f\"Number of pages ({n_pages}) for this request \"\n                f\"exceeds the rate limit ({limit_remaining}, \"\n                f\"total={resp.headers['x-ratelimit-limit']}).\"\n            )\n\n        pages = await self.get_pages(endpoint, params, n_pages)\n\n        return (i for page in pages for i in page.json()[\"data\"])\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Asynchronously close all client connections.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Asynchronously close all client connections.\"\"\"\n    return await self.client.aclose()\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get","title":"<code>get(endpoint, params)</code>  <code>async</code>","text":"<p>Perform GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Requested response object.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If request fails.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def get(self, endpoint: str, params: _Query) -&gt; httpx.Response:\n    \"\"\"Perform GET request on the given endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n\n    Returns\n    -------\n    httpx.Response\n        Requested response object.\n\n    Raises\n    ------\n    APIError\n        If request fails.\n    \"\"\"\n    if params.item_id is not None:\n        resp = await self.client.get(f\"{endpoint}/{params.item_id}\")\n    else:\n        resp = await self.client.get(\n            endpoint,\n            params=params.to_params(endpoint),\n        )\n\n    if resp.status_code != 200:\n        try:\n            message = resp.json()[\"message\"]\n        except (KeyError, JSONDecodeError):\n            message = \"An error occurred with the Fount.\"\n\n        raise APIError(f\"Error {resp.status_code}:\\n{message}\\nurl={resp.url}\")\n\n    return resp\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.get_pages","title":"<code>get_pages(endpoint, params, n_pages)</code>  <code>async</code>","text":"<p>Perform GET requests for a given number of pages on an endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <code>n_pages</code> <code>int</code> <p>Number of pages to request.</p> required <p>Returns:</p> Type Description <code>list[Response]</code> <p>List of response objects.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def get_pages(\n    self, endpoint: str, params: _Query, n_pages: int\n) -&gt; List[httpx.Response]:\n    \"\"\"Perform GET requests for a given number of pages on an endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n    n_pages : int\n        Number of pages to request.\n\n    Returns\n    -------\n    list[httpx.Response]\n        List of response objects.\n    \"\"\"\n    tasks = [\n        asyncio.create_task(self.get(endpoint, p))\n        for p in params.paginated(self.per_page, n_pages)\n    ]\n    try:\n        return await tqdm.gather(\n            *tasks, desc=f\"{endpoint} query\", disable=not self.verbose\n        )\n    except Exception as exc:\n        for task in tasks:\n            task.cancel()\n\n        raise exc\n</code></pre>"},{"location":"reference/http/#http.HTTPClient.query","title":"<code>query(endpoint, params)</code>  <code>async</code>","text":"<p>Perform a paginated GET request on the given endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Path to endpoint.</p> required <code>params</code> <code>Query</code> <p>Request parameters.</p> required <p>Returns:</p> Type Description <code>Iterator[JSONDict]</code> <p>An iterator of JSONDict objects.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If any request fails.</p> <code>DataNotFoundError</code> <p>If response data is empty.</p> <code>RateLimitExceededError</code> <p>If response would exceed the rate limit.</p> Source code in <code>bavapi\\http.py</code> <pre><code>async def query(self, endpoint: str, params: _Query) -&gt; Iterator[JSONDict]:\n    \"\"\"Perform a paginated GET request on the given endpoint.\n\n    Parameters\n    ----------\n    endpoint : str\n        Path to endpoint.\n    params : Query\n        Request parameters.\n\n    Returns\n    -------\n    Iterator[JSONDict]\n        An iterator of JSONDict objects.\n\n    Raises\n    ------\n    APIError\n        If any request fails.\n    DataNotFoundError\n        If response data is empty.\n    RateLimitExceededError\n        If response would exceed the rate limit.\n    \"\"\"\n    resp = await self.get(endpoint, params=params)\n\n    payload: Dict[str, JSONData] = resp.json()\n    data: JSONData = payload[\"data\"]\n\n    if not data:\n        raise DataNotFoundError(\"Your query returned no results.\")\n\n    if isinstance(data, dict):\n        return iter((data,))\n\n    meta = cast(JSONDict, payload[\"meta\"])\n    total = cast(int, meta[\"total\"])\n\n    if params.page or len(data) == total:\n        return iter(data)\n\n    n_pages = params.max_pages or math.ceil(\n        (total) / (params.per_page or self.per_page)\n    )\n\n    if n_pages &gt; (limit_remaining := int(resp.headers[\"x-ratelimit-remaining\"])):\n        raise RateLimitExceededError(\n            f\"Number of pages ({n_pages}) for this request \"\n            f\"exceeds the rate limit ({limit_remaining}, \"\n            f\"total={resp.headers['x-ratelimit-limit']}).\"\n        )\n\n    pages = await self.get_pages(endpoint, params, n_pages)\n\n    return (i for page in pages for i in page.json()[\"data\"])\n</code></pre>"},{"location":"reference/query/","title":"query","text":"<p>Query objects for Fount API queries based on <code>pydantic</code>.</p>"},{"location":"reference/query/#query.Query","title":"<code>Query</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[F]</code></p> <p>Base WPPBAV Fount query.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>(int, optional)</code> <p>Get specific resource by ID, by default None</p> <code>filters</code> <code>FountFilters instance or dict of filter values, optional</code> <p>Filters to apply to the query, by default None</p> <code>fields</code> <code>(str or list[str], optional)</code> <p>Specific fields to retrieve from the query, by default None</p> <code>include</code> <code>(str or list[str], optional)</code> <p>Additional resources to retrieve from the query, by default None</p> <code>metric_keys</code> <code>(str or list[str], optional)</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <p>Currently, this parameter is only available for the <code>brandscape-data</code> endpoint.</p> <code>sort</code> <code>(str, optional)</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name: <code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <code>page</code> <code>(int, optional)</code> <p>Get specific page from paginated response, by default None</p> <p>When None, the default value in the Fount is 1</p> <code>per_page</code> <code>(int, optional)</code> <p>Number of items per page, by default None</p> <p>When None, the default value in the Fount is 25</p> <p>When performing paged queries, Client uses 100 as the default <code>per_page</code>.</p> <code>max_pages</code> <code>(int, optional)</code> <p>Maximum number of pages to retrieve, by default None</p> <p>When None, all pages will be retrieved with a <code>per_page</code> value of 100 by default.</p> Source code in <code>bavapi\\query.py</code> <pre><code>class Query(BaseModel, Generic[F]):\n    \"\"\"Base WPPBAV Fount query.\n\n    Attributes\n    ----------\n    id: int, optional\n        Get specific resource by ID, by default None\n    filters : FountFilters instance or dict of filter values, optional\n        Filters to apply to the query, by default None\n    fields: str or list[str], optional\n        Specific fields to retrieve from the query, by default None\n    include: str or list[str], optional\n        Additional resources to retrieve from the query, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n\n        Currently, this parameter is only available for the `brandscape-data` endpoint.\n    sort: str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n    page: int, optional\n        Get specific page from paginated response, by default None\n\n        When None, the default value in the Fount is 1\n    per_page: int, optional\n        Number of items per page, by default None\n\n        When None, the default value in the Fount is 25\n\n        When performing paged queries, Client uses 100 as the default `per_page`.\n    max_pages: int, optional\n        Maximum number of pages to retrieve, by default None\n\n        When None, all pages will be retrieved with a `per_page` value of 100 by default.\n    \"\"\"\n\n    item_id: Optional[int] = Field(default=None, alias=\"id\")\n    filters: Optional[_filters.FiltersOrMapping[F]] = None\n    fields: OptionalListOr[str] = None\n    include: OptionalListOr[str] = None\n    metric_keys: OptionalListOr[str] = None\n    sort: Optional[str] = None\n    page: Optional[int] = None\n    per_page: Optional[int] = None\n    max_pages: Optional[int] = None\n\n    def to_params(self, endpoint: str) -&gt; BaseParamsDictValues:\n        \"\"\"Return Fount-compatible dictionary of the query.\n\n        Parameters\n        ----------\n        endpoint : str\n            The endpoint for which to format the query\n\n        Returns\n        -------\n        dict[str, Any]\n            Fount-compatible dictionary of the query.\n        \"\"\"\n        exclude: Final[Set[str]] = {\"filters\", \"fields\", \"max_pages\"}\n\n        filters: BaseParamsMapping = {}\n        fields: BaseMutableParamsMapping = {}\n\n        if isinstance(self.filters, _filters.FountFilters):\n            filters = self.filters.model_dump(by_alias=True, exclude_defaults=True)\n        elif self.filters is not None:\n            filters = cast(BaseParamsDict, self.filters)\n        filters = to_fount_params(filters, \"filter\")\n        fields = to_fount_params(\n            {endpoint.replace(\"-\", \"_\"): self.fields} if self.fields else fields,\n            \"fields\",\n        )\n\n        params = {\n            **self.model_dump(exclude=exclude, by_alias=True, exclude_defaults=True),\n            **filters,\n            **fields,\n        }\n\n        return cast(BaseParamsDictValues, list_to_str(params))\n\n    def with_page(self, page: int, per_page: int) -&gt; \"Query[F]\":\n        \"\"\"Create new instance of `Query` with page parameters if either is set to default.\n\n        Returns new instance of Query.\n\n        Parameters\n        ----------\n        page : int\n            Current page number\n        per_page : int\n            Number of results per page\n\n        Returns\n        -------\n        Query\n            New `Query` instance with page parameters.\n        \"\"\"\n        if self.page and self.per_page:\n            return self\n\n        return self.__class__.model_construct(\n            self.model_fields_set.union(  # pylint: disable=no-member\n                {\"page\", \"per_page\"}\n            ),\n            page=self.page or page,\n            per_page=self.per_page or per_page,\n            filters=self.filters,  # avoid turning filters into dictionary\n            **self.model_dump(\n                by_alias=True,\n                exclude={\"page\", \"per_page\", \"filters\"},\n                exclude_defaults=True,\n            ),\n        )\n\n    def paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query[F]\"]:\n        \"\"\"Yield `Query` instances with page parameters for each page in `n_pages`.\n\n        For performing multiple paginated requests.\n\n        Parameters\n        ----------\n        per_page : int\n            Number of results per page\n        n_pages : int\n            Number of pages for which to generate paginated `Query` instances\n\n        Yields\n        ------\n        Query\n            Query instances with page parameters set.\n        \"\"\"\n        yield from (self.with_page(p, per_page) for p in range(1, n_pages + 1))\n</code></pre>"},{"location":"reference/query/#query.Query.paginated","title":"<code>paginated(per_page, n_pages)</code>","text":"<p>Yield <code>Query</code> instances with page parameters for each page in <code>n_pages</code>.</p> <p>For performing multiple paginated requests.</p> <p>Parameters:</p> Name Type Description Default <code>per_page</code> <code>int</code> <p>Number of results per page</p> required <code>n_pages</code> <code>int</code> <p>Number of pages for which to generate paginated <code>Query</code> instances</p> required <p>Yields:</p> Type Description <code>Query</code> <p>Query instances with page parameters set.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def paginated(self, per_page: int, n_pages: int) -&gt; Iterator[\"Query[F]\"]:\n    \"\"\"Yield `Query` instances with page parameters for each page in `n_pages`.\n\n    For performing multiple paginated requests.\n\n    Parameters\n    ----------\n    per_page : int\n        Number of results per page\n    n_pages : int\n        Number of pages for which to generate paginated `Query` instances\n\n    Yields\n    ------\n    Query\n        Query instances with page parameters set.\n    \"\"\"\n    yield from (self.with_page(p, per_page) for p in range(1, n_pages + 1))\n</code></pre>"},{"location":"reference/query/#query.Query.to_params","title":"<code>to_params(endpoint)</code>","text":"<p>Return Fount-compatible dictionary of the query.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint for which to format the query</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount-compatible dictionary of the query.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def to_params(self, endpoint: str) -&gt; BaseParamsDictValues:\n    \"\"\"Return Fount-compatible dictionary of the query.\n\n    Parameters\n    ----------\n    endpoint : str\n        The endpoint for which to format the query\n\n    Returns\n    -------\n    dict[str, Any]\n        Fount-compatible dictionary of the query.\n    \"\"\"\n    exclude: Final[Set[str]] = {\"filters\", \"fields\", \"max_pages\"}\n\n    filters: BaseParamsMapping = {}\n    fields: BaseMutableParamsMapping = {}\n\n    if isinstance(self.filters, _filters.FountFilters):\n        filters = self.filters.model_dump(by_alias=True, exclude_defaults=True)\n    elif self.filters is not None:\n        filters = cast(BaseParamsDict, self.filters)\n    filters = to_fount_params(filters, \"filter\")\n    fields = to_fount_params(\n        {endpoint.replace(\"-\", \"_\"): self.fields} if self.fields else fields,\n        \"fields\",\n    )\n\n    params = {\n        **self.model_dump(exclude=exclude, by_alias=True, exclude_defaults=True),\n        **filters,\n        **fields,\n    }\n\n    return cast(BaseParamsDictValues, list_to_str(params))\n</code></pre>"},{"location":"reference/query/#query.Query.with_page","title":"<code>with_page(page, per_page)</code>","text":"<p>Create new instance of <code>Query</code> with page parameters if either is set to default.</p> <p>Returns new instance of Query.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Current page number</p> required <code>per_page</code> <code>int</code> <p>Number of results per page</p> required <p>Returns:</p> Type Description <code>Query</code> <p>New <code>Query</code> instance with page parameters.</p> Source code in <code>bavapi\\query.py</code> <pre><code>def with_page(self, page: int, per_page: int) -&gt; \"Query[F]\":\n    \"\"\"Create new instance of `Query` with page parameters if either is set to default.\n\n    Returns new instance of Query.\n\n    Parameters\n    ----------\n    page : int\n        Current page number\n    per_page : int\n        Number of results per page\n\n    Returns\n    -------\n    Query\n        New `Query` instance with page parameters.\n    \"\"\"\n    if self.page and self.per_page:\n        return self\n\n    return self.__class__.model_construct(\n        self.model_fields_set.union(  # pylint: disable=no-member\n            {\"page\", \"per_page\"}\n        ),\n        page=self.page or page,\n        per_page=self.per_page or per_page,\n        filters=self.filters,  # avoid turning filters into dictionary\n        **self.model_dump(\n            by_alias=True,\n            exclude={\"page\", \"per_page\", \"filters\"},\n            exclude_defaults=True,\n        ),\n    )\n</code></pre>"},{"location":"reference/sync/","title":"sync","text":"<p>Top level functions to perform queries to the Fount.</p> <p>You will need your BAV API token to use these functions.</p> <p>Examples:</p> <p>Use top level functions for one-off downloads:</p> <pre><code>&gt;&gt;&gt; import bavapi\n&gt;&gt;&gt; result = bavapi.brands(\"TOKEN\", \"Facebook\")  # Replace TOKEN with your API key\n</code></pre> <p>A more complex query:</p> <pre><code>&gt;&gt;&gt; from bavapi_refs.audiences import Audiences\n&gt;&gt;&gt; bss = bavapi.brandscape_data(\n...     \"TOKEN\",  # Replace TOKEN with your API key\n...     country_code=\"UK\",\n...     year_number=2022,\n...     audiences=Audiences.ALL_ADULTS,\n... )\n</code></pre> <p>Use <code>bavapi.raw_query</code> (with <code>bavapi.Query</code>) for endpoints that aren't fully supported:</p> <pre><code>&gt;&gt;&gt; query = bavapi.Query(filters=bavapi.filters.FountFilters(name=\"Meta\"))\n&gt;&gt;&gt; result = bavapi.raw_query(\"companies\", params=query)\n</code></pre> <p>If you want to make multiple requests or embed <code>bavapi</code> into applications, consider using the <code>bavapi.Client</code> interface.</p>"},{"location":"reference/sync/#sync.audiences","title":"<code>audiences(token, name=None, audience_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>audiences</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search audiences by name, by default None</p> <code>None</code> <code>audience_id</code> <code>int</code> <p>Fount audience ID, by default None</p> <p>If an audience ID is provided, only that audience will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive audiences only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Audience group ID or list of audience group IDs, by default None</p> <code>None</code> <code>filters</code> <code>AudiencesFilters or dict of filters</code> <p>AudiencesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def audiences(\n    token: str,\n    name: Optional[str] = None,\n    audience_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.AudiencesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `audiences` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search audiences by name, by default None\n    audience_id : int, optional\n        Fount audience ID, by default None\n\n        If an audience ID is provided, only that audience will be returned\n    active : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active audiences only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive audiences only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Audience group ID or list of audience group IDs, by default None\n    filters : AudiencesFilters or dict of filters, optional\n        AudiencesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.audiences(\n            name,\n            audience_id,\n            active,\n            inactive,\n            public,\n            private,\n            groups,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brand_metric_groups","title":"<code>brand_metric_groups(token, name=None, group_id=None, active=0, inactive=0, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metric-groups</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brand metric groups by name, by default None</p> <code>None</code> <code>group_id</code> <code>int</code> <p>Fount brand metric group ID, by default None</p> <p>If a metric group ID is provided, only that metric group will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metric groups only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive brand metric groups only if set to <code>1</code>, by default 0</p> <code>0</code> <code>filters</code> <code>BrandMetricGroupsFilters or dict of filters</code> <p>BrandMetricGroupsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metric-groups</code> endpoint results.</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brand_metric_groups(\n    token: str,\n    name: Optional[str] = None,\n    group_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricGroupsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metric-groups` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brand metric groups by name, by default None\n    group_id : int, optional\n        Fount brand metric group ID, by default None\n\n        If a metric group ID is provided, only that metric group will be returned\n    active : Literal[0, 1], optional\n        Return active brand metric groups only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metric groups only if set to `1`, by default 0\n    filters : BrandMetricGroupsFilters or dict of filters, optional\n        BrandMetricGroupsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metric-groups` endpoint results.\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.brand_metric_groups(\n            name,\n            group_id,\n            active,\n            inactive,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brand_metrics","title":"<code>brand_metrics(token, name=None, metric_id=None, active=0, inactive=0, public=0, private=0, groups=None, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brand-metrics</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brand metrics by name, by default None</p> <code>None</code> <code>metric_id</code> <code>int</code> <p>Fount metric ID, by default None</p> <p>If an metric ID is provided, only that metric will be returned</p> <code>None</code> <code>active</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>inactive</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return active brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>private</code> <code>Literal[0, 1]</code> <p>Return inactive brand metrics only if set to <code>1</code>, by default 0</p> <code>0</code> <code>groups</code> <code>int or list[int]</code> <p>Brand metrics group ID or list of brand metrics group IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandMetricsFilters or dict of filters</code> <p>BrandMetricsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brand-metrics</code> endpoint results.</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brand_metrics(\n    token: str,\n    name: Optional[str] = None,\n    metric_id: Optional[int] = None,\n    active: Literal[0, 1] = 0,\n    inactive: Literal[0, 1] = 0,\n    public: Literal[0, 1] = 0,\n    private: Literal[0, 1] = 0,\n    groups: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandMetricsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brand-metrics` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brand metrics by name, by default None\n    metric_id : int, optional\n        Fount metric ID, by default None\n\n        If an metric ID is provided, only that metric will be returned\n    active : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, by default 0\n    inactive : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, by default 0\n    public : Literal[0, 1], optional\n        Return active brand metrics only if set to `1`, by default 0\n    private : Literal[0, 1], optional\n        Return inactive brand metrics only if set to `1`, by default 0\n    groups : int or list[int], optional\n        Brand metrics group ID or list of brand metrics group IDs, by default None\n    filters : BrandMetricsFilters or dict of filters, optional\n        BrandMetricsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brand-metrics` endpoint results.\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.brand_metrics(\n            name,\n            metric_id,\n            active,\n            inactive,\n            public,\n            private,\n            groups,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brands","title":"<code>brands(token, name=None, country_codes=None, year_numbers=None, brand_id=None, studies=None, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brands</code> endpoint</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>name</code> <code>str</code> <p>Search brands by name, by default None</p> <code>None</code> <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>brand_id</code> <code>int</code> <p>Fount brand ID, by default None</p> <p>If a brand ID is provided, only that brand will be returned</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount study IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandsFilters or dict of filters</code> <p>BrandsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brands</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brands(\n    token: str,\n    name: Optional[str] = None,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    brand_id: Optional[int] = None,\n    studies: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brands` endpoint\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    name : str, optional\n        Search brands by name, by default None\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    brand_id : int, optional\n        Fount brand ID, by default None\n\n        If a brand ID is provided, only that brand will be returned\n    studies : int or list[int], optional\n        Fount study IDs, by default None\n    filters : BrandsFilters or dict of filters, optional\n        BrandsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brands` endpoint results\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.brands(\n            name,\n            country_codes,\n            year_numbers,\n            brand_id,\n            studies,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.brandscape_data","title":"<code>brandscape_data(token, country_code=None, year_number=None, audiences=None, brand_name=None, studies=None, *, filters=None, fields=None, include=None, metric_keys=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>brandscape-data</code> endpoint.</p> <p>This endpoint requires at least one of the following combinations of parameters:</p> <ul> <li>Study + Audience + Brand + Category</li> <li>Country + Year + Audience</li> <li>Brand + Audience + Country + Year</li> </ul> <p>You should read these from left to right. A combination of \"Study + Audience\" worksjust as well as \"Study + Audience + Brand\". However, \"Category + Audience\" will not.</p> <p>If you use Country or Year filters, you must use both filters together.</p> <p>An audience filter is also highly recommended, as otherwise the API will return data for all audiences (there are more than 100 standard audiences).</p> <p>The <code>Audiences</code> class is provided to make it easier to filter audiences.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>brand</code> - <code>study</code> - <code>category</code></p> <p>Any additional valid includes will be added to the default set.</p> <p>If any of the default includes are used in <code>include</code>, then only that resource will be retrieved. This is to allow requesting individual includes if they are part of the default.</p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>country_code</code> <code>str or list[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_number</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>audiences</code> <code>int or list[int]</code> <p>Audiences to retrieve by audience ID, by default None</p> <p>The <code>Audiences</code> class can help with this filter.</p> <code>None</code> <code>brand_name</code> <code>str</code> <p>Search by brand name, by default None</p> <code>None</code> <code>studies</code> <code>int or list[int]</code> <p>Fount studies IDs, by default None</p> <code>None</code> <code>filters</code> <code>BrandscapeFilters or dict of filters</code> <p>BrandscapeFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>metric_keys</code> <code>OptionalListOr[str]</code> <p>Key or list of keys for the metrics included in the response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>brandscape-data</code> endpoint results</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If used with an invalid combination of parameters (see above)</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def brandscape_data(\n    token: str,\n    country_code: OptionalListOr[str] = None,\n    year_number: OptionalListOr[int] = None,\n    audiences: OptionalListOr[int] = None,\n    brand_name: Optional[str] = None,\n    studies: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.BrandscapeFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    metric_keys: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `brandscape-data` endpoint.\n\n    This endpoint requires at least one of the following combinations of parameters:\n\n    - Study + Audience + Brand + Category\n    - Country + Year + Audience\n    - Brand + Audience + Country + Year\n\n    You should read these from left to right. A combination of \"Study + Audience\"\n    worksjust as well as \"Study + Audience + Brand\".\n    However, \"Category + Audience\" will not.\n\n    If you use Country or Year filters, you must use both filters together.\n\n    An audience filter is also highly recommended, as otherwise the API will return\n    data for all audiences (there are more than 100 standard audiences).\n\n    The `Audiences` class is provided to make it easier to filter audiences.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `brand`\n    - `study`\n    - `category`\n\n    Any additional valid includes will be added to the default set.\n\n    If any of the default includes are used in `include`, then only that resource\n    will be retrieved. This is to allow requesting individual includes if they are\n    part of the default.\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    country_code : str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_number : int or list[int], optional\n        Study years, by default None\n    audiences : int or list[int], optional\n        Audiences to retrieve by audience ID, by default None\n\n        The `Audiences` class can help with this filter.\n    brand_name : str, optional\n        Search by brand name, by default None\n    studies : int or list[int], optional\n        Fount studies IDs, by default None\n    filters : BrandscapeFilters or dict of filters, optional\n        BrandscapeFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    metric_keys: str or list[str], optional\n        Key or list of keys for the metrics included in the response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `brandscape-data` endpoint results\n\n    Raises\n    ------\n    ValidationError\n        If used with an invalid combination of parameters (see above)\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.brandscape_data(\n            country_code,\n            year_number,\n            audiences,\n            brand_name,\n            studies,\n            filters=filters,\n            fields=fields,\n            metric_keys=metric_keys,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.categories","title":"<code>categories(token, name=None, category_id=None, sector=None, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>categories</code> endpoint.</p> <p>Note that this endpoint has a default set of <code>include</code> resources: - <code>sector</code></p> <p>To suppress default includes, set <code>include</code> to <code>\"no_default\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search categories by name, by default None</p> <code>None</code> <code>category_id</code> <code>int</code> <p>Fount category ID, by default None</p> <p>If an category ID is provided, only that category will be returned</p> <code>None</code> <code>sector</code> <code>int or list[int]</code> <p>Filter categories by sector ID, by default 0</p> <code>None</code> <code>filters</code> <code>CategoriesFilters or dict of filters</code> <p>CategoriesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>categories</code> endpoint results.</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def categories(\n    token: str,\n    name: Optional[str] = None,\n    category_id: Optional[int] = None,\n    sector: OptionalListOr[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.CategoriesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `categories` endpoint.\n\n    Note that this endpoint has a default set of `include` resources:\n    - `sector`\n\n    To suppress default includes, set `include` to `\"no_default\"`.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search categories by name, by default None\n    category_id : int, optional\n        Fount category ID, by default None\n\n        If an category ID is provided, only that category will be returned\n    sector : int or list[int], optional\n        Filter categories by sector ID, by default 0\n    filters : CategoriesFilters or dict of filters, optional\n        CategoriesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `categories` endpoint results.\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.categories(\n            name,\n            category_id,\n            sector,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.collections","title":"<code>collections(token, name=None, collection_id=None, public=0, shared_with_me=0, mine=0, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>collections</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search collections by name, by default None</p> <code>None</code> <code>collection_id</code> <code>int</code> <p>Fount collection ID, by default None</p> <p>If a collection ID is provided, only that collection will be returned</p> <code>None</code> <code>public</code> <code>Literal[0, 1]</code> <p>Return public collections only if set to <code>1</code>, by default 0</p> <code>0</code> <code>shared_with_me</code> <code>Literal[0, 1]</code> <p>Only return collections that have been shared with the user, by default 0</p> <code>0</code> <code>mine</code> <code>Literal[0, 1]</code> <p>Only return collections created by the user, by default 0</p> <code>0</code> <code>filters</code> <code>CollectionsFilters or dict of filters</code> <p>CollectionsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>collections</code> endpoint results.</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def collections(\n    token: str,\n    name: Optional[str] = None,\n    collection_id: Optional[int] = None,\n    public: Literal[0, 1] = 0,\n    shared_with_me: Literal[0, 1] = 0,\n    mine: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.CollectionsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `collections` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search collections by name, by default None\n    collection_id : int, optional\n        Fount collection ID, by default None\n\n        If a collection ID is provided, only that collection will be returned\n    public : Literal[0, 1], optional\n        Return public collections only if set to `1`, by default 0\n    shared_with_me : Literal[0, 1], optional\n        Only return collections that have been shared with the user, by default 0\n    mine : Literal[0, 1], optional\n        Only return collections created by the user, by default 0\n    filters : CollectionsFilters or dict of filters, optional\n        CollectionsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `collections` endpoint results.\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.collections(\n            name,\n            collection_id,\n            public,\n            shared_with_me,\n            mine,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.raw_query","title":"<code>raw_query(token, endpoint, params, timeout=30.0, *, verbose=True)</code>  <code>async</code>","text":"<p>Perform a raw GET query to the Fount API, returning the response JSON data instead of a <code>pandas</code> DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>endpoint</code> <code>str</code> <p>Endpoint name</p> required <code>params</code> <code>Query</code> <p>Query <code>pydantic</code> model with query parameters.</p> required <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of JSON response data</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def raw_query(\n    token: str,\n    endpoint: str,\n    params: Query[F],\n    timeout: float = 30.0,\n    *,\n    verbose: bool = True,\n) -&gt; List[JSONDict]:\n    \"\"\"Perform a raw GET query to the Fount API, returning the response JSON data\n    instead of a `pandas` DataFrame.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    endpoint : str\n        Endpoint name\n    params : Query\n        Query `pydantic` model with query parameters.\n    timeout : float\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of JSON response data\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.raw_query(endpoint, params)\n</code></pre>"},{"location":"reference/sync/#sync.sectors","title":"<code>sectors(token, name=None, sector_id=None, in_most_influential=0, not_in_most_influential=0, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>sectors</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Search categories by name, by default None</p> <code>None</code> <code>sector_id</code> <code>int</code> <p>Fount sectors ID, by default None</p> <p>If a sector ID is provided, only that sector will be returned</p> <code>None</code> <code>in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are part of the Most Influential lists, by default 0</p> <code>0</code> <code>not_in_most_influential</code> <code>Literal[0, 1]</code> <p>Sectors that are not part of the Most Influential lists, by default 0</p> <code>0</code> <code>filters</code> <code>SectorsFilters or dict of filters</code> <p>SectorsFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>sectors</code> endpoint results.</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def sectors(\n    token: str,\n    name: Optional[str] = None,\n    sector_id: Optional[int] = None,\n    in_most_influential: Literal[0, 1] = 0,\n    not_in_most_influential: Literal[0, 1] = 0,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.SectorsFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `sectors` endpoint.\n\n    Parameters\n    ----------\n    name : str, optional\n        Search categories by name, by default None\n    sector_id : int, optional\n        Fount sectors ID, by default None\n\n        If a sector ID is provided, only that sector will be returned\n    in_most_influential : Literal[0, 1], optional\n        Sectors that are part of the Most Influential lists, by default 0\n    not_in_most_influential : Literal[0, 1], optional\n        Sectors that are not part of the Most Influential lists, by default 0\n    filters : SectorsFilters or dict of filters, optional\n        SectorsFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `sectors` endpoint results.\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.sectors(\n            name,\n            sector_id,\n            in_most_influential,\n            not_in_most_influential,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/sync/#sync.studies","title":"<code>studies(token, country_codes=None, year_numbers=None, full_year=0, study_id=None, *, filters=None, fields=None, include=None, stack_data=False, timeout=30.0, verbose=True, **kwargs)</code>  <code>async</code>","text":"<p>Query the Fount <code>studies</code> endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>WPPBAV Fount API token</p> required <code>country_codes</code> <code>OptionalListOr[str]</code> <p>ISO-3166-1 alpha-2 country codes, by default None</p> <code>None</code> <code>year_numbers</code> <code>int or list[int]</code> <p>Study years, by default None</p> <code>None</code> <code>full_year</code> <code>Literal[0, 1]</code> <p>Include or exclude studies which are not \"full year\" studies, such as US quarterly studies or special studies, by default 0</p> <p>A value of 1 will filter non-full-year studies.</p> <code>0</code> <code>study_id</code> <code>int</code> <p>Fount study ID, by default None If a study ID is provided, only that study will be returned</p> <code>None</code> <code>filters</code> <code>StudiesFilters or dict of filters</code> <p>StudiesFilters object or dictionary of filter parameters, by default None</p> <code>None</code> <code>fields</code> <code>str or list[str]</code> <p>Fields to retrieve in API response, by default None</p> <p>Only specified fields are returned. If <code>fields</code> is None, all fields are returned.</p> <code>None</code> <code>include</code> <code>str or list[str]</code> <p>Additional resources to include in API response, by default None</p> <code>None</code> <code>stack_data</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Maximum timeout for requests in seconds, by default 30.0</p> <code>30.0</code> <code>verbose</code> <code>bool</code> <p>Set to False to disable progress bar, by default True</p> <code>True</code> <code>**kwargs</code> <code>Unpack[CommonQueryParams]</code> <p>Additional parameters to pass to the Query. See <code>Other Parameters</code>. For any filters, use the <code>filters</code> parameter.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>page</code> <code>int</code> <p>Page number to fetch, by default None</p> <code>per_page</code> <code>int</code> <p>Number of results per page, by default None</p> <code>max_pages</code> <code>int</code> <p>Max number of results to return, by default None</p> <code>sort</code> <code>str</code> <p>Sort response by field, by default None</p> <p>To sort in descending (highest first) order, use a <code>-</code> before the field name:</p> <p><code>sort=\"-differentiation_rank\"</code></p> <p>Sorts by item ID by default.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with <code>studies</code> endpoint results</p> Source code in <code>bavapi\\sync.py</code> <pre><code>@_coro\nasync def studies(\n    token: str,\n    country_codes: OptionalListOr[str] = None,\n    year_numbers: OptionalListOr[int] = None,\n    full_year: Literal[0, 1] = 0,\n    study_id: Optional[int] = None,\n    *,\n    filters: OptionalFiltersOrMapping[_filters.StudiesFilters] = None,\n    fields: OptionalListOr[str] = None,\n    include: OptionalListOr[str] = None,\n    stack_data: bool = False,\n    timeout: float = 30.0,\n    verbose: bool = True,\n    **kwargs: Unpack[CommonQueryParams],\n) -&gt; \"DataFrame\":\n    \"\"\"Query the Fount `studies` endpoint.\n\n    Parameters\n    ----------\n    token : str\n        WPPBAV Fount API token\n    country_codes: str or list[str], optional\n        ISO-3166-1 alpha-2 country codes, by default None\n    year_numbers : int or list[int], optional\n        Study years, by default None\n    full_year : Literal[0, 1], optional\n        Include or exclude studies which are not \"full year\" studies,\n        such as US quarterly studies or special studies, by default 0\n\n        A value of 1 will filter non-full-year studies.\n    study_id : int, optional\n        Fount study ID, by default None\n        If a study ID is provided, only that study will be returned\n    filters : StudiesFilters or dict of filters, optional\n        StudiesFilters object or dictionary of filter parameters, by default None\n    fields : str or list[str], optional\n        Fields to retrieve in API response, by default None\n\n        Only specified fields are returned.\n        If `fields` is None, all fields are returned.\n    include : str or list[str], optional\n        Additional resources to include in API response, by default None\n    stack_data : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n    timeout : float, optional\n        Maximum timeout for requests in seconds, by default 30.0\n    verbose : bool, optional\n        Set to False to disable progress bar, by default True\n    **kwargs\n        Additional parameters to pass to the Query. See `Other Parameters`.\n        For any filters, use the `filters` parameter.\n\n    Other Parameters\n    ----------------\n    page : int, optional\n        Page number to fetch, by default None\n    per_page : int, optional\n        Number of results per page, by default None\n    max_pages : int, optional\n        Max number of results to return, by default None\n    sort : str, optional\n        Sort response by field, by default None\n\n        To sort in descending (highest first) order, use a `-` before the field name:\n\n        `sort=\"-differentiation_rank\"`\n\n        Sorts by item ID by default.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame with `studies` endpoint results\n    \"\"\"\n\n    async with Client(token, timeout=timeout, verbose=verbose) as client:\n        return await client.studies(\n            country_codes,\n            year_numbers,\n            full_year,\n            study_id,\n            filters=filters,\n            fields=fields,\n            include=include,\n            stack_data=stack_data,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/parsing/","title":"parsing","text":"<p>Modules for parsing parameters and responses.</p>"},{"location":"reference/parsing/params/","title":"params","text":"<p>Functions to parse parameter values.</p>"},{"location":"reference/parsing/params/#parsing.params.list_to_str","title":"<code>list_to_str(mapping)</code>","text":"<p>Convert any lists in a dictionary to a string with comma-separated elements.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>ParamsMapping</code> <p>Dictionary with lists</p> required <p>Returns:</p> Type Description <code>ParamsMappingValues</code> <p>Dictionary without strings</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def list_to_str(mapping: BaseMutableParamsMapping) -&gt; BaseMutableParamsMappingValues:\n    \"\"\"Convert any lists in a dictionary to a string with comma-separated elements.\n\n    Parameters\n    ----------\n    mapping : ParamsMapping\n        Dictionary with lists\n\n    Returns\n    -------\n    ParamsMappingValues\n        Dictionary without strings\n    \"\"\"\n    for key, value in mapping.items():\n        if not isinstance(value, str) and isinstance(value, Sequence):\n            mapping[key] = \",\".join(str(i) for i in value)\n\n    return cast(BaseMutableParamsMappingValues, mapping)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.parse_date","title":"<code>parse_date(value)</code>","text":"<p>Parse date string or datetime value into a date string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>(str, datetime, date)</code> <p>Input to parse into a date string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The parsed date as a string.</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def parse_date(value: Union[str, dt.datetime, dt.date]) -&gt; str:\n    \"\"\"Parse date string or datetime value into a date string.\n\n    Parameters\n    ----------\n    value : str, dt.datetime, dt.date\n        Input to parse into a date string.\n\n    Returns\n    -------\n    str\n        The parsed date as a string.\n    \"\"\"\n    fmt_out = \"%Y-%m-%d %H:%M:%S\"\n    if isinstance(value, dt.datetime):\n        return value.strftime(fmt_out)\n    if isinstance(value, dt.date):\n        return dt.datetime.combine(value, dt.datetime.min.time()).strftime(fmt_out)\n    try:\n        return dt.datetime.strptime(value, fmt_out).strftime(value)\n    except ValueError:\n        return dt.datetime.fromisoformat(value).strftime(fmt_out)\n</code></pre>"},{"location":"reference/parsing/params/#parsing.params.to_fount_params","title":"<code>to_fount_params(data, param)</code>","text":"<p>Constructs dictionary keys for special Fount API formatting.</p> <p>The resulting dictionary keys will be formatted to include <code>param</code> as the main parameter name:</p> <p>to_fount_params({\"a\":1}, \"test\")</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary to format.</p> required <code>param</code> <code>str</code> <p>Parameter name.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Fount API parameter dictionary.</p> Source code in <code>bavapi\\parsing\\params.py</code> <pre><code>def to_fount_params(data: Mapping[str, T], param: str) -&gt; Dict[str, T]:\n    \"\"\"Constructs dictionary keys for special Fount API formatting.\n\n    The resulting dictionary keys will be formatted to include `param` as the\n    main parameter name:\n\n    &gt;&gt;&gt; to_fount_params({\"a\":1}, \"test\")\n    {\"test[a]\":1}\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        Dictionary to format.\n    param : str\n        Parameter name.\n\n    Returns\n    -------\n    dict[str, Any]\n        Fount API parameter dictionary.\n    \"\"\"\n    return {f\"{param}[{k}]\": v for k, v in data.items()}\n</code></pre>"},{"location":"reference/parsing/responses/","title":"responses","text":"<p>Functions for parsing Fount API responses</p>"},{"location":"reference/parsing/responses/#parsing.responses.flatten","title":"<code>flatten(mapping, parent='', sep='_', prefix='', expand=False)</code>","text":"<p>Recursively flatten all nested mappings and lists in the given mapping.</p> <p>Returns an iterator because it expands any nested lists into new dictionaries, then yields each repeated dictionary with its corresponding value from the list.</p> <p>This is equivalent to a <code>JOIN</code> operation in a relational database, where lists represent multiple entries on the right table of the <code>JOIN</code>.</p> <p>Note: If many nested lists are present, this function will generate as many entries as the PRODUCT of the nested lists. If the mapping has one nested list with 5 elements, and another nested list with 5 elements, the function will yield 25 (5x5) dictionaries in total.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any]</code> <p>Dictionary with potential nested dictionaries and lists of dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, by default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, by default \"\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for keys that clash with keys in the top-level mapping, by default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <code>expand</code> <code>bool</code> <p>Whether to expand nested lists into new dictionaries, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[dict[str, Any]]</code> <p>Yield flattened dictionaries.</p> <p>If expand is True and any nested lists are present, yield each resulting flattened dictionary.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def flatten(\n    mapping: Entry[T],\n    parent: str = \"\",\n    sep: str = \"_\",\n    prefix: str = \"\",\n    expand: bool = False,\n) -&gt; Iterator[Dict[str, T]]:\n    \"\"\"Recursively flatten all nested mappings and lists in the given mapping.\n\n    Returns an iterator because it expands any nested lists into new dictionaries,\n    then yields each repeated dictionary with its corresponding value from the list.\n\n    This is equivalent to a `JOIN` operation in a relational database, where lists\n    represent multiple entries on the right table of the `JOIN`.\n\n    Note: If many nested lists are present, this function will generate as many entries\n    as the PRODUCT of the nested lists. If the mapping has one nested list with 5\n    elements, and another nested list with 5 elements,\n    the function will yield 25 (5x5) dictionaries in total.\n\n    Parameters\n    ----------\n    mapping : dict[str, Any]\n        Dictionary with potential nested dictionaries and lists of dictionaries\n    parent : str\n        Parent key for generating children keys, by default \"\"\n    sep : str\n        Separator to use between keys and parent keys, by default \"\"\n    prefix: str\n        Prefix for keys that clash with keys in the top-level mapping, by default \"\"\n\n        An empty prefix will ignore key conflicts.\n    expand : bool, optional\n        Whether to expand nested lists into new dictionaries, by default False\n\n    Yields\n    ------\n    Iterator[dict[str, Any]]\n        Yield flattened dictionaries.\n\n        If expand is True and any nested lists are present, yield each resulting\n        flattened dictionary.\n    \"\"\"\n    new: Dict[str, T] = flatten_mapping(mapping, parent, sep, prefix)\n    expand_keys: List[str] = (\n        [k for k, v in new.items() if isinstance(v, list)] if expand else []\n    )\n\n    if not expand_keys:\n        yield new\n    else:\n        for key in expand_keys:\n            values = cast(List[Dict[str, T]], new[key])\n            for val in values:\n                for i in flatten(val, key, sep, prefix, expand):\n                    yield {**{k: v for k, v in new.items() if k != key}, **i}\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.flatten_mapping","title":"<code>flatten_mapping(mapping, parent='', sep='_', prefix='')</code>","text":"<p>Recursively flattens all nested dictionaries into top level key-value pairs.</p> <p>Include prefixes or suffixes if nested keys clash with top-level keys.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, Any]</code> <p>Dictionary with potential nested dictionaries</p> required <code>parent</code> <code>str</code> <p>Parent key for generating children keys, by default \"\"</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator to use between keys and parent keys, by default \"\"</p> <code>'_'</code> <code>prefix</code> <code>str</code> <p>Prefix for nested keys that clash with keys in the top-level mapping, by default \"\"</p> <p>An empty prefix will ignore key conflicts.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Flattened dictionary.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def flatten_mapping(\n    mapping: Entry[T], parent: str = \"\", sep: str = \"_\", prefix: str = \"\"\n) -&gt; Dict[str, T]:\n    \"\"\"Recursively flattens all nested dictionaries into top level key-value pairs.\n\n    Include prefixes or suffixes if nested keys clash with top-level keys.\n\n    Parameters\n    ----------\n    mapping : dict[str, Any]\n        Dictionary with potential nested dictionaries\n    parent : str\n        Parent key for generating children keys, by default \"\"\n    sep : str\n        Separator to use between keys and parent keys, by default \"\"\n    prefix: str\n        Prefix for nested keys that clash with keys in the top-level mapping, by default \"\"\n\n        An empty prefix will ignore key conflicts.\n\n    Returns\n    -------\n    dict[str, Any]\n        Flattened dictionary.\n    \"\"\"\n    res: Dict[str, T] = {}\n    to_expand: Dict[str, Dict[str, T]] = {}\n    for key, value in mapping.items():\n        if parent:\n            key = f\"{parent}{sep}{key}\"\n\n        if isinstance(value, dict):\n            to_expand[key] = value\n        else:\n            res[key] = value\n\n    with_prefix: set[str] = (\n        {k for k in to_expand if any(_k.startswith(k) for _k in res)}\n        if prefix\n        else set()\n    )\n\n    expanded: Dict[str, T] = {}\n    for key, value in to_expand.items():\n        if key in with_prefix:\n            key = f\"{prefix}{sep}{key}\"\n\n        expanded.update(flatten_mapping(value, key, sep, prefix))\n\n    res.update(expanded)\n    return res\n</code></pre>"},{"location":"reference/parsing/responses/#parsing.responses.parse_response","title":"<code>parse_response(page, prefix='', index=None, expand=False)</code>","text":"<p>Parse Fount API JSON into a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Iterable[dict[str, Any]]</code> <p>Page from API response.</p> required <code>prefix</code> <code>str</code> <p>Prefix to prepend to columns with clashing names, by default <code>\"\"</code></p> <code>''</code> <code>index</code> <code>str</code> <p>Column name to use as index, by default None.</p> <code>None</code> <code>expand</code> <code>bool</code> <p>Whether to expand lists of dictionaries into new entries (rows) in the resulting DataFrame, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of the response data.</p> Source code in <code>bavapi\\parsing\\responses.py</code> <pre><code>def parse_response(\n    page: Iterable[Entry[T]],\n    prefix: str = \"\",\n    index: Optional[str] = None,\n    expand: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Parse Fount API JSON into a pandas DataFrame.\n\n    Parameters\n    ----------\n    page : Iterable[dict[str, Any]]\n        Page from API response.\n    prefix : str, optional\n        Prefix to prepend to columns with clashing names, by default `\"\"`\n    index : str, optional\n        Column name to use as index, by default None.\n    expand : bool, optional\n        Whether to expand lists of dictionaries into new entries (rows)\n        in the resulting DataFrame, by default False.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame of the response data.\n    \"\"\"\n    return (\n        pd.DataFrame.from_records(\n            (i for item in page for i in flatten(item, prefix=prefix, expand=expand)),\n            index=index,\n        )\n        .dropna(axis=1, how=\"all\")\n        .transform(pd.to_numeric, errors=\"ignore\")\n    )\n</code></pre>"},{"location":"usage/advanced/","title":"Advanced Usage","text":"<p>This section is intended for developers who are interested in embedding <code>bavapi</code> functionality into their APIs and applications.</p> <p>Async support</p> <p><code>bavapi</code> natively supports asynchronous execution, so it is ready to work with popular <code>async</code> libraries such as <code>fastapi</code>.</p>"},{"location":"usage/advanced/#the-client-interface","title":"The <code>Client</code> interface","text":"<p>The <code>Client</code> class is the backbone of <code>bavapi</code>, and it is the recommended way to interact with the Fount for more advanced users.</p> <p>Tip</p> <p>If you're familiar with the <code>requests</code> or <code>httpx</code> python packages, this is similar to using <code>requests.Session()</code> or <code>httpx.Client()</code>.</p> <p>Using the <code>Client</code> class instead of the top-level endpoint functions (<code>bavapi.brands</code>, for example), can bring significant performance improvements, especially when performing multiple requests at the same time.</p> <p>The <code>Client</code> interface is based on <code>httpx.Client</code>, so it benefits from all the performance features from <code>httpx</code>:</p> <p>Quote from the <code>httpx</code> docs</p> <ul> <li>Reduced latency across requests (no handshaking).</li> <li>Reduced CPU usage and round-trips.</li> <li>Reduced network congestion.</li> </ul> <p>By using <code>Client</code>, you will also get all these benefits, including in Jupyter Notebooks.</p>"},{"location":"usage/advanced/#using-the-client-interface","title":"Using the <code>Client</code> interface","text":"<p>It is recommended to use <code>Client</code> in an <code>async with</code> block:</p> <pre><code>async with bavapi.Client(\"TOKEN\") as bav:\n    result = await bav.brands(\"Swatch\")\n</code></pre> <p>Otherwise, it is possible to use <code>Client</code> methods outside of an <code>async with</code> block, but it might be slightly less performant.</p> <pre><code>bav = bavapi.Client(\"TOKEN\")\nresult = await bav.brands(\"Swatch\")\nawait bav.aclose()  # (1)\n</code></pre> <ol> <li> Close the connection by awaiting <code>aclose</code> after you're done with your requests.</li> </ol>"},{"location":"usage/advanced/#other-endpoints","title":"Other endpoints","text":"<p>Because of the large number of available endpoints in the Fount and the highly customizable queries, some endpoints won't have extended support from the start.</p> <p>Open for feedback</p> <p>If you would like to see new endpoints with full type annotation support, please open an issue on GitHub with the Feature Request template.</p> <p><code>bavapi</code> provides <code>raw_query</code> functions/methods to access all the available endpoints without existing endpoint functions/methods:</p> <ul> <li><code>bavapi.raw_query</code> for synchronous requests.</li> <li><code>bavapi.Client.raw_query</code> for asynchronous requests.</li> </ul> <p>These <code>raw_query</code> methods require the use of <code>bavapi.Query</code> instances to make the request:</p> <pre><code>async with bavapi.Client(\"TOKEN\") as bav:\n    res = bav.raw_query(\"companies\", Query(filters=FountFilters(name=\"Facebook\")))\n</code></pre> <p>These functions will return a list of JSON dictionaries, one for each entry retrieved from the Fount:</p> <pre><code>[\n    {\"name\": \"Apple\", \"id\": 1},\n    {\"name\": \"Applebee's\", \"id\": 2},\n    // ...\n]\n</code></pre> <p>Tip</p> <p>These methods are meant to be used for custom processing of data (not resulting in a <code>pandas</code> DataFrame), but it is also possible to use some of the parsing functions available in bavapi.parsing.responses.</p>"},{"location":"usage/advanced/#the-query-class","title":"The <code>Query</code> class","text":"<p><code>bavapi.Query</code> is a <code>pydantic</code>-powered class that holds and validates all the common (aside from endpoint-specific filters) query parameters to pass to the Fount API.</p> <p>The default values for the class are the same as the default values in the Fount API itself, so an empty <code>Query</code> object can be used to get all entries for a specific endpoint:</p> <pre><code>query = bavapi.Query()\n\nasync with bavapi.Client(\"TOKEN\") as bav:\n    res = bav.raw_query(\"brand-metrics\", query) # (1)\n</code></pre> <ol> <li> Returns all entries for <code>brand-metrics</code>. Similar to making a <code>GET</code> request with no parameters.</li> </ol> <p><code>Query</code> can be used to set limits on the number of pages retrieved, or to request a specific page from a query:</p> <pre><code>bavapi.Query(\n    per_page = 200,  # (1)\n    max_pages = 50,\n    ...  # Other params\n)\n</code></pre> <ol> <li> <p>Stick with defaults</p> <p>The default <code>per_page</code> value (<code>100</code>) has been set after testing various options for the best download speed. </p> </li> </ol>"},{"location":"usage/advanced/#query-parameters","title":"<code>Query</code> parameters","text":"<p>All Fount queries performed with <code>bavapi.Query</code> support the following parameters:</p> <ul> <li><code>id</code>: Return only results for a specific id.</li> <li><code>page</code>: The page number of results to return.</li> <li><code>per_page</code>: The number of results to return per page. Default is 25 and maximum is 100.</li> <li><code>max_pages</code>: The maximum number of pages to request. Defaults to requesting all pages in a query.</li> <li><code>fields</code>: The keys for the fields to include in the response. Usually they are the field name in lower case.</li> <li><code>sort</code>: The key(s) for the field(s) to order the response results by.</li> <li><code>include</code>: Additional linked resources to include in the response.</li> <li><code>updated_since</code>: Only return items that have been updated since this timestamp.</li> </ul> <p>For more information on the behavior of each of these parameters, see the Fount API docs.</p>"},{"location":"usage/advanced/#raw-parameter-dictionary","title":"Raw parameter dictionary","text":"<p>The <code>to_params</code> method can be used to parse the parameters into a dictionary of what will be sent to the Fount API:</p> <pre><code>&gt;&gt;&gt; bavapi.Query(\n...     filters=BrandscapeFilters(\n...         brand_name=\"Facebook\",\n...         year_numbers=[2012, 2013, 2014, 2015]\n...     ),\n...     include=[\"company\"]\n... ).to_params(endpoint=\"brandscape-data\")\n{\n    \"include[brandscape-data]\": \"company\",  # (1)\n    \"filter[brand_name]\": \"Facebook\",\n    \"year_numbers\": \"2012,2013,2014,2015\",\n}\n</code></pre> <ol> <li> Parses <code>filters</code> and <code>include</code> into the correct format for the Fount API, and parses all elements in lists of parameters to their string representation.</li> </ol>"},{"location":"usage/advanced/#user-agent","title":"User Agent","text":"<p>New in <code>v0.8.0</code></p> <p>It is possible to set the <code>User Agent</code> parameter for HTTP requests.</p> <p>The default user agent is <code>\"BAVAPI SDK Python\"</code>.</p> <p>If you want to change the user agent for your application, you can set it when instantiating a <code>Client</code>:</p> <pre><code>bav = bavapi.Client(user_agent=\"Your User Agent\")\n</code></pre>"},{"location":"usage/basic/","title":"Basic usage","text":"<p>Once you have installed <code>bavapi</code> and acquired a token from the Fount, you can start using <code>bavapi</code> directly in Python or in a Jupyter Notebook.</p> <pre><code>import bavapi\n</code></pre>"},{"location":"usage/basic/#using-bavapi","title":"Using bavapi","text":"<p>SSL Issues</p> <p>It's possible that you get <code>SSL: CERTIFICATE_VERIFY_FAILED</code> errors when performing requests with <code>bavapi</code>. At the moment, it is not clear to what might be the source of the issue; as it only happens sometimes, and the error doesn't appear to happen with other tested URLs.</p> <p>Usually, making the request again solves the issue, but you might have to do so a couple of times if the issue persists.</p> <p> If you have any thoughts on how to solve this, please open an issue on GitHub.</p> <p>You can query the available endpoints with their corresponding methods:</p> <pre><code>swatch = bavapi.brands(\"TOKEN\", name=\"Swatch\")  # (1)\n</code></pre> <ol> <li> Replace <code>TOKEN</code> with your API key</li> </ol> <p>These endpoints methods will return a pandas DataFrame containing the data retrieved for your query:</p> id name ... 0 2342 Swatch ... 1 127896 Swatch ... ... ... ... ... <p>You can make requests to other endpoints in the same way:</p> <pre><code>uk_studies = bavapi.studies(\"TOKEN\", country_code=\"GB\")\n\nuk22 = bavapi.brandscape_data(\"TOKEN\", year_numbers=2022, country_code=\"GB\", audiences=1)\n\nall_adults = bavapi.audiences(\"TOKEN\", name=\"All Adults\")\n</code></pre> <p>Want to use other endpoints?</p> <p>The BAV API is very extensive, so not all endpoints are fully implemented yet.</p> <p>See the Other endpoints section in Advanced Usage.</p>"},{"location":"usage/basic/#filtering-responses","title":"Filtering responses","text":"<p>In order to validate the request parameters before sending a bad request, <code>bavapi</code> will automatically check that the parameters from your query and filters are of the type expected by the Fount API. If any parameter doesn't conform to the API requirements, <code>bavapi</code> will raise a <code>ValidationError</code>.</p> <p>What it's doing</p> <p><code>bavapi</code> performs an initial request to make sure the query parameters are valid, and to retrieve information about the number of pages it will need to fetch.</p> <p>If the initial request fails, <code>bavapi</code> will not perform more requests.</p> <p>Similarly, if the initial request returns the entirety of the query (e.g., there are only 10 results and <code>per_page</code> is above 10, which it is by default), no further requests will be performed, and instead the data from the initial response will be returned.</p> <p>Each endpoint has a filter class associated with it, as each endpoint has its own filter requirements:</p> Endpoint Filters class <code>\"audiences\"</code> <code>AudiencesFilters</code> <code>\"brand-metric-groups\"</code> <code>BrandMetricGroupsFilters</code> <code>\"brand-metrics\"</code> <code>BrandMetricsFilters</code> <code>\"brands\"</code> <code>BrandsFilters</code> <code>\"brandscape-data\"</code> <code>BrandscapeFilters</code> <code>\"categories\"</code> <code>CategoriesFilters</code> <code>\"collections\"</code> <code>CollectionsFilters</code> <code>\"sectors\"</code> <code>SectorsFilters</code> <code>\"studies\"</code> <code>StudiesFilters</code> <p>Warning</p> <p>Using a filters class not meant for a specific endpoint will raise a <code>ValueError</code>.</p> <p>However, using a dictionary instead (as seen in the instructions below) won't raise errors if the dictionary doesn't match the expected filter types. Use the dictionary method with caution.</p> <p>These classes are available in the <code>bavapi.filters</code> module.</p> <p>Some of the more common filters for each endpoint have been added directly to the <code>bavapi</code> functions. More info in the endpoints section.</p> <p>Example</p> <p><code>bavapi.brands</code> has parameters such as <code>name</code>, <code>country_codes</code>, <code>year_numbers</code>, <code>brand_id</code> or <code>studies</code>, which you can use directly from the function without creating a filters instance.</p> <p>However, less commonly used filters, as well as value filters must be specified by using the <code>filters</code> parameters in each function.</p> <p>Filters can be specified using a Python dictionary (if you know the name of the filters you need), or directly creating a Filters instance:</p> Filters instances (recommended)Dictionary <pre><code>result = bavapi.brands(\n    filters=BrandsFilters(name=\"Swatch\", country_codes=[\"US\", \"UK\"])\n)\n</code></pre> <pre><code>result = bavapi.brands(\n    filters={\"name\":\"Swatch\", \"country_codes\":[\"US\", \"UK\"]}\n)\n</code></pre> <p>Warning</p> <p>If both regular function parameters and filters are specified, the values in the filters parameter will take precedence for the actual request:</p> <pre><code>result = bavapi.brands(name=\"Swatch\", filters={\"name\": \"Facebook\"})\n</code></pre> <p>The request will use <code>name=\"Facebook\"</code>, because values specified in the <code>filters</code> parameter take precedence.</p>"},{"location":"usage/basic/#value-filters","title":"Value filters","text":"<p>\"Value\" filters refer to filtering on the values of the data returned by the endpoint, as opposed to filtering via query parameters specified in the Fount API documentation. For example, filtering by category name or by sector in the <code>brandscape-data</code> endpoint.</p> <p>These value filters must be specified in the <code>filters</code> parameter. If they are added to the function call as regular keyword arguments, a <code>ValidationError</code> will be raised.</p> <pre><code>bavapi.brands(name=\"Swatch\", filters={\"sector_name\": \"Watches\"})  # ok\n\nbavapi.brands(name=\"Swatch\", sector_name=\"Watches\")  # raises ValidationError\n</code></pre> <p>When using additional value filters, which might not be available in the arguments to the function call, it is recommended to use the <code>filters</code> parameter instead of mixing function parameters and Filters parameters:</p> <pre><code>bavapi.brands(filters=BrandsFilters(name=\"Swatch\", sector_name=\"Watches\"))\n</code></pre>"},{"location":"usage/basic/#using-reference-classes","title":"Using Reference classes","text":"<p><code>bavapi</code> provides reference classes to make API queries easier to construct.</p> <p>These reference classes must be generated on your machine after installation. Please follow the instructions in the Installing Reference Classes section.</p> <p>The following reference classes are available as of <code>v0.10</code>:</p> <ul> <li><code>Audiences</code>: Audience IDs for all available Fount audiences.</li> <li><code>Countries</code>: Country IDs for all available Fount countries.</li> </ul> <p>They make it easier to use these filters, which require Fount IDs to work:</p> <pre><code>uk22 = bavapi.brandscape_data(\n    \"TOKEN\",\n    countries=Countries.UNITED_KINGDOM,\n    audiences=Audiences.ALL_ADULTS,\n)\n</code></pre>"},{"location":"usage/basic/#timeout","title":"Timeout","text":"<p>New in <code>v0.8</code></p> <p>By default, API requests will timeout after 30 seconds in order to avoid hangups.</p> <p>This may happen more commonly when performing requests with more than 50-100 pages. If you get a <code>TimeoutError</code>, you can change this parameter to allow for longer timeouts.</p> <p>It is possible to set the time before timeout when performing requests with <code>bavapi</code>:</p> SyncAsync <pre><code>bavapi.brands(TOKEN, \"Facebook\", timeout=60)\n</code></pre> <pre><code>async with bavapi.Client(TOKEN, timeout=60) as bav:\n    await bav.brands(\"Facebook\")\n</code></pre>"},{"location":"usage/basic/#suppressing-progress-bars","title":"Suppressing progress bars","text":"<p>New in <code>v0.9</code></p> <p><code>bavapi</code> displays progress bars to show download progress. Each tick in the progress bar refers to individual pages being downloaded.</p> <p>It's possible to supress progress bar outputs via the <code>verbose</code> parameter in function calls and <code>Client</code> init methods:</p> <p>=== Sync (Won't show progress bar)     <pre><code>bavapi.brands(TOKEN, \"Facebook\", verbose=False)\n</code></pre></p> <p>=== Async (Won't show progress bar)     <pre><code>async with bavapi.Client(TOKEN, verbose=False) as bav:\n    bav.brands(\"Facebook\")\n</code></pre></p>"},{"location":"usage/basic/#other-query-parameters","title":"Other query parameters","text":""},{"location":"usage/basic/#fields","title":"Fields","text":"<p>Read more in the API documentation</p> <p>It is possible to specify which fields a response should contain. If so, the API will only return those fields.</p> <pre><code>result = bavapi.brands(name=\"Swatch\", fields=[\"id\", \"name\"])\nresult.columns  # will only have [\"id\", \"name\"] as columns\n</code></pre>"},{"location":"usage/basic/#sorting","title":"Sorting","text":"<p>Read more in the API documentation</p> <p>It is possible to sort the data by a column from the response.</p> <pre><code># sorted by name\nresult = bavapi.brands(name=\"Swatch\", sort=\"name\")\n\n# descending sorted by name (note the '-')\nresult = bavapi.brands(name=\"Swatch\", sort=\"-name\")\n</code></pre> <p>Responses are sorted by item id, in ascending order, by default.</p>"},{"location":"usage/basic/#related-data-includes","title":"Related data (includes)","text":"<p>Read more in the API documentation</p> <p>Aside from the data directly available for each of the resources in the Fount, these resources can also be connected across endpoints.</p> <p>Example</p> <p>From the <code>brands</code> endpoint, you can request info about a brand's <code>company</code>, <code>sector</code> or <code>studies</code>, among others.</p> <p>Each endpoint supports different <code>includes</code> fields. Please read the Fount API documentation for more info on the specific set of includes supported by each endpoint.</p> <pre><code># will include info about the brand's company\nresult = bavapi.brands(name=\"Swatch\", includes=\"company\")\n</code></pre> <p>Default <code>includes</code></p> <p>The <code>brandscape_data</code> function includes <code>study</code>, <code>brand</code>, <code>category</code> and <code>audience</code> by default, to align functionality with other sources of data like the Fount website and the Cultural Rank Tool.</p>"},{"location":"usage/basic/#pagination","title":"Pagination","text":"<p>Read more in the API documentation</p> <p>All requests to the Fount are \"paginated\", meaning that one must request and receive from the server one page at a time. <code>bavapi</code> then combines all responses into one data table.</p> <p>While the default value for <code>bavapi</code> is 100, it is possible to set a custom number of <code>per_page</code> elements for each request:</p> <pre><code># will send requests for the specified number of elements.\nresult = bavapi.brands(name=\"Swatch\", per_page=1000)\n</code></pre> <p>Info</p> <p>The maximum number of elements per page allowed by the Fount API is <code>1000</code>.</p> <p>You can also set a custom number of <code>max_pages</code> for the request, or directly specify the <code>page</code> parameter to get a single page of results.</p>"},{"location":"usage/basic/#metric-keys","title":"Metric keys","text":"<p><code>metric_keys</code> is a special filter to specify the data columns that the response should contain.</p> <p>The API response will include all score types for that metric.</p> <p>Note</p> <p>Currently, only the <code>brandscape-data</code> endpoint supports the use of metric keys. All other endpoints will ignore this parameter.</p> <p>More info in the <code>brandscape-data</code> endpoint section.</p>"},{"location":"usage/basic/#formatting-output","title":"Formatting output","text":"<p>It is possible that some of the data retrieved from the Fount includes multiple items.</p> <p>Example</p> <p>For example, requesting the <code>studies</code> include in <code>bavapi.brands</code> will return a column containing lists of dictionaries with study info for all studies that a brand appears in.</p> id name studies 0 24353 Facebook [{'id': 254, 'name': 'Argentin...}] ... ... ... ... <p><code>bavapi</code> has a <code>stack_data</code> parameter in its functions and methods that will take those lists of dictionaries and recursively generate a new entry (row) in the resulting DataFrame for each element in the list.</p> <pre><code>bavapi.brands(\"Facebook\", include=\"studies\", stack_data=True)\n</code></pre> id name studies_id studies_name ... 0 24353 Facebook 254 Argentina - Adults 2011 ... 1 24353 Facebook 787 Argentina - Adults 2012 ... ... ... ... ... ... ..."},{"location":"usage/basic/#datetime-in-fount-responses","title":"Datetime in Fount responses","text":"<p>Parsing of datetime values in Fount responses is not currently supported, though it is a planned feature.</p> <p>For now, parse datetime values manually using <code>pandas</code> instead.</p> <p>Tip</p> <p>The functions shown in the \"Basic usage\" section are meant for easy use in Jupyter notebooks, experimentation, one-off scripts, etc.</p> <p>For more advanced uses and significant performance benefits, see Advanced Usage next.</p>"},{"location":"usage/project-tips/","title":"Tips for using <code>bavapi</code> in your projects","text":""},{"location":"usage/project-tips/#retry-failed-requests","title":"Retry failed requests","text":"<p>There's a sporadic issue where some requests may raise an <code>SSL: CERTIFICATE_VERIFY_FAILED</code> error.</p> <p>While we will continue investigating solutions to the issue, you can use the <code>retry</code> package to automatically retry requests upon failure.</p> <p>Here's an example snippet:</p> <pre><code>from retry.api import retry_call\nimport ssl\nimport bavapi\n\nretry_call(bavapi.brands, (\"TOKEN\", \"Facebook\"), exceptions=ssl.SSLError, tries=3)\n</code></pre> <p>This will attempt to make the request 3 times upon failure. If none of the tries succeeds, it will raise an exception.</p>"},{"location":"usage/project-tips/#save-load-filters-and-queries","title":"Save &amp; load filters and queries","text":"<p>One beneficial side-effect of using <code>bavapi</code> is the ability to save specific queries or filters in order to be able to reproduce them later on.</p> <p>Imagine that you need to share with your team a query that someone else will need to run.</p> <p>You could share the data if you save the file and then share with them, but another option which might work better if you have to manage multiple audiences/data files is to save the <code>bavapi</code> queries and load them for later use.</p> <p>The recommended (simplest) way to achieve this would be to save the query in a JSON file.</p> <pre><code>import json\n\nto_save = bavapi.filters.BrandsFilters(name=\"Facebook\", country_code=\"GB\")\n\nwith open(\"my_filters.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(to_save.model_dump(), file)\n</code></pre> <p>The code above will save your filters as a JSON file:</p> my_filters.json<pre><code>{\n    \"updated_since\": null,\n    \"country_codes\": \"GB\",\n    \"year_numbers\": null,\n    \"categories\": null,\n    \"countries\": null,\n    \"regions\": null,\n    \"sectors\": null,\n    \"studies\": null,\n    \"years\": null,\n    \"name\": \"Facebook\"\n}\n</code></pre> <p>You can then load the file into a <code>bavapi.filters</code> object like so:</p> <pre><code>with open(\"my_filters.json\", \"r\", encoding=\"utf-8\") as file:\n    loaded = bavapi.filters.BrandsFilters(**json.load(file))\n</code></pre> <p>This should restore all filter values, so you can use it again with other requests:</p> <pre><code>&gt;&gt;&gt; loaded\nBrandsFilters(name=\"Facebook\", country_code=\"GB\", ...)\n</code></pre> <p>Tip</p> <p>This also works for <code>Query</code> objects:</p> <pre><code>to_save = bavapi.Query(...)\n\nwith open(\"my_query.json\", \"w\", encoding=\"utf-8\") as file:\n    json.dump(to_save.model_dump(), file)\n\n# Saved to `my_query.json`\n\nwith open(\"my_query.json\", \"r\", encoding=\"utf-8\") as file:\n    loaded = bavapi.Query(**json.load(file))\n</code></pre> <p>When saving and re-loading <code>Query</code> objects, its filters will be loaded as the base <code>FountFilters</code> class. Everything should work normally, but filter values won't be validated.</p> <p>For that reason, it is recommended NOT to create the filters in JSON directly, but to create the filter in Python and then dump to JSON, so the values get validated before saving the query to a JSON file.</p>"},{"location":"usage/project-tips/#using-bavapi-to-develop-real-time-applications","title":"Using <code>bavapi</code> to develop real-time applications","text":"<p><code>bavapi</code> provides asynchronous functionality for embedding <code>bavapi</code> into applications.</p> <p>Please see the Advanced Usage section for more information.</p>"}]}